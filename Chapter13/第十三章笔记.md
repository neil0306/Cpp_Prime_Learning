# 类继承(inheritance)
- 使用场景: 
  - 复用以往写过的类的代码.
  - 扩展已有功能(有可能只拿到一个编译好的库, 但是没有源码)

概念:
- 基类: 原始类(以往已经写好的类)
- 派生类: 继承基类的类(扩展基类功能而重新构建的类)

公有派生:
- 派生时, 在基类的前面加上public
- 基类的**公有成员**将成为派生类的**公有成员**
- 基类的**私有部分**也将成为派生类的一部分, 但**只能通过基类的公有和保护方法进行访问**

对于派生类:
- 可以根据需要添加自己专属的数据成员和成员函数
- 派生类需要自己添加一个构造函数
  - 构造函数不仅**要给自己的新成员初始化**, **也要给基类的成员初始化**
  - 在写派生类的构造函数时需要注意权限问题:
    - 派生类**必须**`使用基类的构造函数来初始化基类的成员`
    - 基类的数据成员必须在派生类的构造函数的`初始化列表中进行初始化`
      - 这是因为C++要求基类的数据成员**在派生类对象初始化之前就构造完成**, 也就是创建派生类对象之前要先创建基类对象, 所以我们只能使用初始化列表的方式来初始化基类的数据成员.
      - **成员初始化列表**本质上`兼顾地完成了基类对象的初始化`.
    ```cpp
    class Derived : public Base 
    {
        public:
            // 在初始化列表中初始化基类的数据成员
            Derived(int i, int j, int k, int l) : Base(i, j)
            {
                m = k;
                n = l;
            }

            /*
                1. 这个构造函数会先用 i,j调用Base的构造函数创建一个基类的对象
                2. 然后才进入派生类的构造函数, 初始化m和n, 构造派生类的对象

                注: 如果注释掉初始化列表的构造函数Base, 则基类就会调用默认构造函数, 此时i,j这两个参数相当于没有使用
            */
    };
    ```

代码例子:
- 头文件`tabtenn1.h`
```cpp
#ifndef __TABTENN0_H__
#define __TABTENN0_H__

#include <iostream>
#include <string>

using std::string;

class TableTennisPlayer
{
    private:
        string firstname;
        string lastname;
        bool hasTable;
    public:
        TableTennisPlayer(const string &fn = "none",
                            const string &ln = "noen", bool ht = false);
        void Name() const;
        bool HasTable() const {return hasTable;}
        void ResetTable(bool v) {hasTable = v;}
};

class RatedPlayer : public TableTennisPlayer        // 派生出RatedPlayer, public表示这是公有派生
{
    private:
        unsigned int rating;
    public:
        RatedPlayer(unsigned int r = 0, const string &fn = "none", const string &ln = "none", bool ht = false);
        RatedPlayer(unsigned int r, const TableTennisPlayer &tp);       // 此时直接传了一个基类的对象作为参数
        unsigned int Rating() const {return rating;}
        void ResetRating(unsigned int r) {rating = r;}
};

#endif //!__TABTENN0_H__
```

- 源文件`tabtenn1.cpp`
```cpp
#include "tabtenn1.h"

#include <iostream>

TableTennisPlayer::TableTennisPlayer(const string &fn, const string &ln, bool ht) : 
                                firstname(fn), lastname(ln), hasTable(ht)
{}

void TableTennisPlayer::Name() const
{
    std::cout << lastname << ", " << firstname;
}

RatedPlayer::RatedPlayer(unsigned int r, const string &fn, const string &ln, bool ht) : TableTennisPlayer(fn, ln, ht)
{
    // 这里只初始化派生类 RatedPlayer 专属的数据成员
    rating = r;
}

// 使用成员初始化列表初始化所有的成员变量
RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer &tp) : TableTennisPlayer(tp), rating(r)        // 触发基类的复制构造函数, 如果没有自定义, 就会使用默认复制构造
{}
```

- 测试文件`usett1.cpp`
```cpp
#include <iostream>

#include "tabtenn1.h"

using namespace std;

int main(void)
{
    RatedPlayer rplayer1(1140, "Mallory", "Duck", false);
    TableTennisPlayer player1("Tara", "Boomdea", false);

    rplayer1.Name();
    if(rplayer1.HasTable()){
        cout << ": has a table." << endl;
    }
    else{
        cout << ": hasn't a table." << endl;
    }
    rplayer1.Name();
    cout << ": Rating: " << rplayer1.Rating() << endl;


    RatedPlayer rplayer2(1212, player1);        // 使用自定义的第二个构造函数
    cout << "Name: ";
    rplayer2.Name();     // 基类的成员函数
    cout << ", Rating: " << rplayer2.Rating() << endl;

    return 0;
}
```


## 小结
1. 在进行析构时, 先析构派生类对象, 再析构基类的对象
2. 如果在**派生类的构造函数中**没有显式地使用成员初始化列表来构造基类对象, 则基类对象将使用**基类的默认构造函数进行构造**
3. 基类与派生类之间的特殊关系
   1. **派生类对象可以使用基类的 public 方法** (但 private 方法不可直接调用)
   2. `基类指针`可以在不进行显式类型转换的情况下`指向派生类对象`, 并且, `基类对象`可以在不进行显式类型转换的情况下`引用派生类对象`.
      ```cpp
      RatedPlayer rplayer1(1140, "Mallory", "Duck", false);
      TableTennisPlayer &rt = rplayer1;       // 基类对象引用派生类对象
      TableTennisPlayer *pt = &rplayer1;      // 基类指针指向派生类对象
      rt.Name();      // 基类引用使用基类方法
      rt->Name();     // 基类指针使用基类方法
      ```
       - 基类指针或者引用在这种情况下**只能调用基类的方**法, 而不能使用派生类的方法. 
       - 这种规则是`单向`的, **不能将基类的指针和引用赋给派生类**. 
         ```cpp
         base -> derived;   // √
         derived -> base;   // X
         ```
         - 理由是: 如果允许将基类直接赋值给派生类, 则会导致派生类的某些成员和方法不可使用, 毕竟派生类对象本来就没有这部分定义.
         - 简单来说就是:`少的调用多的没事, 多的调用少的就不行`
   3. 基类和派生类的兼容关系的应用场景
      ```cpp
      // 1. 将派生类对象作为基类对象的实参
      void Show(const TableTennisPlayer &rt)       // 传入基类对象
      {
          rt.Name();      // 调用基类的方法
      }

      // 2. 用派生类对象初始化基类对象
      RatedPlayer olaf1(1840, "Olaf", "Loaf", true);    // 派生类对象
      TableTennisPlayer olaf2(olaf1);     // 派生类对象传入基类对象, 触发基类的复制构造函数

      // 3. 用派生类对象赋值给基类对象
      TableTennisPlayer olaf3;       // 基类对象
      olaf3 = olaf1;    // 派生类对象赋值给基类对象, 触发基类的赋值运算符重载函数
                        // 注: 重载的定义为 TableTennisPlayer & operator=(const TableTennisPlayer &) const; 
      ```



