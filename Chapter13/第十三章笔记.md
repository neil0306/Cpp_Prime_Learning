# 类继承(inheritance)
- 使用场景: 
  - 复用以往写过的类的代码.
  - 扩展已有功能(有可能只拿到一个编译好的库, 但是没有源码)

概念:
- 基类: 原始类(以往已经写好的类)
- 派生类: 继承基类的类(扩展基类功能而重新构建的类)

公有派生:
- 派生时, 在基类的前面加上public
- 基类的**公有成员**将成为派生类的**公有成员**
- 基类的**私有部分**也将成为派生类的一部分, 但**只能通过基类的公有和保护方法进行访问**

对于派生类:
- 可以根据需要添加自己专属的数据成员和成员函数
- 派生类需要自己添加一个构造函数
  - 构造函数不仅**要给自己的新成员初始化**, **也要给基类的成员初始化**
  - 在写派生类的构造函数时需要注意权限问题:
    - 派生类**必须**`使用基类的构造函数来初始化基类的成员`
    - 基类的数据成员必须在派生类的构造函数的`初始化列表中进行初始化`
      - 这是因为C++要求基类的数据成员**在派生类对象初始化之前就构造完成**, 也就是创建派生类对象之前要先创建基类对象, 所以我们只能使用初始化列表的方式来初始化基类的数据成员.
      - **成员初始化列表**本质上`兼顾地完成了基类对象的初始化`.
    ```cpp
    class Derived : public Base 
    {
        public:
            // 在初始化列表中初始化基类的数据成员
            Derived(int i, int j, int k, int l) : Base(i, j)
            {
                m = k;
                n = l;
            }

            /*
                1. 这个构造函数会先用 i,j调用Base的构造函数创建一个基类的对象
                2. 然后才进入派生类的构造函数, 初始化m和n, 构造派生类的对象

                注: 如果注释掉初始化列表的构造函数Base, 则基类就会调用默认构造函数, 此时i,j这两个参数相当于没有使用
            */
    };
    ```

代码例子:
- 头文件`tabtenn1.h`
```cpp
#ifndef __TABTENN0_H__
#define __TABTENN0_H__

#include <iostream>
#include <string>

using std::string;

class TableTennisPlayer
{
    private:
        string firstname;
        string lastname;
        bool hasTable;
    public:
        TableTennisPlayer(const string &fn = "none",
                            const string &ln = "noen", bool ht = false);
        void Name() const;
        bool HasTable() const {return hasTable;}
        void ResetTable(bool v) {hasTable = v;}
};

class RatedPlayer : public TableTennisPlayer        // 派生出RatedPlayer, public表示这是公有派生
{
    private:
        unsigned int rating;
    public:
        RatedPlayer(unsigned int r = 0, const string &fn = "none", const string &ln = "none", bool ht = false);
        RatedPlayer(unsigned int r, const TableTennisPlayer &tp);       // 此时直接传了一个基类的对象作为参数
        unsigned int Rating() const {return rating;}
        void ResetRating(unsigned int r) {rating = r;}
};

#endif //!__TABTENN0_H__
```

- 源文件`tabtenn1.cpp`
```cpp
#include "tabtenn1.h"

#include <iostream>

TableTennisPlayer::TableTennisPlayer(const string &fn, const string &ln, bool ht) : 
                                firstname(fn), lastname(ln), hasTable(ht)
{}

void TableTennisPlayer::Name() const
{
    std::cout << lastname << ", " << firstname;
}

RatedPlayer::RatedPlayer(unsigned int r, const string &fn, const string &ln, bool ht) : TableTennisPlayer(fn, ln, ht)
{
    // 这里只初始化派生类 RatedPlayer 专属的数据成员
    rating = r;
}

// 使用成员初始化列表初始化所有的成员变量
RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer &tp) : TableTennisPlayer(tp), rating(r)        // 触发基类的复制构造函数, 如果没有自定义, 就会使用默认复制构造
{}
```

- 测试文件`usett1.cpp`
```cpp
#include <iostream>

#include "tabtenn1.h"

using namespace std;

int main(void)
{
    RatedPlayer rplayer1(1140, "Mallory", "Duck", false);
    TableTennisPlayer player1("Tara", "Boomdea", false);

    rplayer1.Name();
    if(rplayer1.HasTable()){
        cout << ": has a table." << endl;
    }
    else{
        cout << ": hasn't a table." << endl;
    }
    rplayer1.Name();
    cout << ": Rating: " << rplayer1.Rating() << endl;


    RatedPlayer rplayer2(1212, player1);        // 使用自定义的第二个构造函数
    cout << "Name: ";
    rplayer2.Name();     // 基类的成员函数
    cout << ", Rating: " << rplayer2.Rating() << endl;

    return 0;
}
```


## 小结
1. 在进行析构时, 先析构派生类对象, 再析构基类的对象
2. 如果在**派生类的构造函数中**没有显式地使用成员初始化列表来构造基类对象, 则基类对象将使用**基类的默认构造函数进行构造**
3. 基类与派生类之间的特殊关系
   1. **派生类对象可以使用基类的 public 方法** (但 private 方法不可直接调用)
   2. `基类指针`可以在不进行显式类型转换的情况下`指向派生类对象`, 并且, `基类对象`可以在不进行显式类型转换的情况下`引用派生类对象`.
      ```cpp
      RatedPlayer rplayer1(1140, "Mallory", "Duck", false);
      TableTennisPlayer &rt = rplayer1;       // 基类对象引用派生类对象
      TableTennisPlayer *pt = &rplayer1;      // 基类指针指向派生类对象
      rt.Name();      // 基类引用使用基类方法
      rt->Name();     // 基类指针使用基类方法
      ```
       - 基类指针或者引用在这种情况下**只能调用基类的方**法, 而不能使用派生类的方法. 
       - 这种规则是`单向`的, **不能将基类的指针和引用赋给派生类**. 
         ```cpp
         base -> derived;   // √
         derived -> base;   // X
         ```
         - 理由是: 如果允许将基类直接赋值给派生类, 则会导致派生类的某些成员和方法不可使用, 毕竟派生类对象本来就没有这部分定义.
         - 简单来说就是:`少的调用多的没事, 多的调用少的就不行`
   3. 基类和派生类的兼容关系的应用场景
      ```cpp
      // 1. 将派生类对象作为基类对象的实参
      void Show(const TableTennisPlayer &rt)       // 传入基类对象
      {
          rt.Name();      // 调用基类的方法
      }

      // 2. 用派生类对象初始化基类对象
      RatedPlayer olaf1(1840, "Olaf", "Loaf", true);    // 派生类对象
      TableTennisPlayer olaf2(olaf1);     // 派生类对象传入基类对象, 触发基类的复制构造函数

      // 3. 用派生类对象赋值给基类对象
      TableTennisPlayer olaf3;       // 基类对象
      olaf3 = olaf1;    // 派生类对象赋值给基类对象, 触发基类的赋值运算符重载函数
                        // 注: 重载的定义为 TableTennisPlayer & operator=(const TableTennisPlayer &) const; 
      ```


# 多态
简单来说就是`重载基类的方法`, 以实现不同的类(的对象)里的**同名方法实现不同的功能**.

代码例子:
- 头文件`brass.h`
```cpp
#ifndef __BRASS_H__
#define __BRASS_H__

#include <iostream>
#include <string>
using namespace std;

class Brass
{
    private:
        string fullname;        // 用户名
        long accNum;           // 账户
        double balance;         // 存款金额
    public:
        Brass(const string &s = "NullBody", long an = -1, double bal = 0.0);        // 完成创建账号(初始化数据成员)

        // 养成习惯, 基类的析构函数一定要定义成 虚函数!!!!
        virtual ~Brass(){}

        void Deposit(double amt);
        virtual void Widthdraw(double amt);
        double Balance() const;
        virtual void ViewAcc() const;       // 只显示当前账户里有多少钱
};

class BrassPlus : public Brass      // 派生类
{
    private:
        double maxLoan;         // 贷款额度
        double rate;            // 利率
        double owesBank;        // 本金 + 利息
    public:
        BrassPlus(const string &s = "NullBody", long an = -1, double bal = 0.0, double ml = 500.0, double r = 0.11125);
        BrassPlus(const Brass &ba, double ml = 500.0, double r = 0.11125);
        virtual void ViewAcc() const;         // 显示账户有多少钱, 显示欠款和贷款额度
        virtual void WidthDraw(double amt);
        void ResetMax(double m){maxLoan = m;}
        void ResetRate(double r){rate = r;}
        void ResetOwes(){owesBank = 0.0;}
};

#endif //!__BRASS_H__
```

- 源文件`brass.cpp`
```cpp
#include "brass.h"

Brass::Brass(const string &s, long an, double bal)
{
    fullname = s;
    accNum = an;
    balance = bal;
}

void Brass::Deposit(double amt)
{
    if (amt < 0){
        cout << "Negative deposit is not allowed!" << endl;
    }
    balance += amt;
}

void Brass::Widthdraw(double amt)
{
    if (amt < 0){
        cout << "Widthdraw amount must be positive!" << endl;
    }
    else if(amt <= balance){
        balance -= amt; 
    }
    else {
        cout << "Widthdraw amount exceeded your balance!" << endl;
    }
}

double Brass::Balance() const
{
    return balance;
}

void Brass::ViewAcc() const
{
    cout << "Client: " << fullname << endl;
    cout << "Account Number: " << accNum << endl;
    cout << "Balance: $" << balance << endl;
}

BrassPlus::BrassPlus(const string &s, long an, double bal, double ml, double r) : Brass(s, an, bal)
{
    maxLoan = ml;
    rate = r;
    owesBank = 0.0;
}

BrassPlus::BrassPlus(const Brass &ba, double ml, double r) : Brass(ba)
{
    maxLoan = ml;
    rate = r;
    owesBank = 0.0;
}

void BrassPlus::ViewAcc() const         // 虚函数在定义时不需要再加 virtual
{
    Brass::ViewAcc();       // 指明先调用的是基类的ViewAcc函数
    cout << "Maximum Loan: $" << maxLoan << endl;
    cout << "Loan Rate: " << rate << endl;
    cout << "Owed to bank: $" << owesBank << endl;
}

void BrassPlus::WidthDraw(double amt)  // 虚函数在定义时不需要再加 virtual
{
    double bal = Balance();     // 虽然没有在派生类中定义balance, 但是基类中已经有这个函数(且输入public), 直接使用即可

    if(amt <= bal){             // 余额充足, 直接取钱
        Brass::Widthdraw(amt);
    }
    else if(amt <= bal + maxLoan - owesBank){       // 注意此时余额已经不够了, 余额 + 透支额度 - 已有贷款 = 当前能取的金额
        double advance = amt - bal;
        owesBank = advance * (1.0 + rate);          // 更新一下总欠款
        cout << "Bank Advance: $" << advance << endl;       // 显示本次取钱需要向银行借多少钱
        cout << "Finance Charge: $" << advance * rate << endl;      // 显示加上手续费之后一共多少钱
    
        Deposit(advance);           // 向银行借完钱, 刷新可取钱的余额
        Brass::Widthdraw(amt);      // 调用基类的widthdraw
    }
    else{
        cout << "Credit limit exceeded!" << endl;
    }
}
```

- 测试1 `useBrass1.cpp`
```cpp
#include "brass.h"
#include <iostream>

using namespace std;

int main(void)
{
    Brass rick("Rick", 123456, 4000);
    BrassPlus jack("Jack", 654321, 3000);

    // 使用对象调用相应的方法
    rick.ViewAcc();         // 调用基类方法
    cout << endl;
    jack.ViewAcc();         // 调用派生类方法
    cout << endl;
    
    // 测试透支功能
    cout << "Deposit $1000 into the Jack Account. " << endl;
    jack.Deposit(1000);
    cout << "New balance: $" << jack.Balance() << endl;

    cout << "Widthdraw 4200 from the Rick Account." << endl;
    rick.Widthdraw(4200);       // 基类对象, 不允许透支

    cout << "-----------" << endl;
    cout << "Widthdraw 4200 from the Jack Account." << endl;
    jack.WidthDraw(4200);       // 派生类对象, 可以透支
    jack.ViewAcc();             // 打印透支后的情况

    return 0;
}
```

- 测试2: `useBrass2.cpp`
```cpp
#include "brass.h"
#include <iostream>

using namespace std;
const int CLIENTS = 3;

int main(void)
{
    Brass *p_client[CLIENTS];
    string temp;
    long temp_num;
    double temp_bal;
    int kind = 1;
    for (int i = 0; i < CLIENTS; i++){
        // 让用户输入开户信息
        cout << "Enter the client's name: ";
        getline(cin, temp);     // 因为可能存在空格, 所以需要捕获一整行
        cout << "Enter client's account number: ";
        cin >> temp_num;
        cout << "Enter openning balance: $";
        cin >> temp_bal;
        cout << "Enter 1 for Brass account or enter 2 for BrassPlus account: ";
    
        while(cin >> kind && (kind != 1 && kind != 2)){
            cout << "Enter either 1 or 2: ";
        }
        // 创建对象指针
        if (kind == 1){
            p_client[i] = new Brass(temp, temp_num, temp_bal);        // 对类使用new, 会触发构造函数
        }
        else{
            double tmax, trate;
            cout << "Enter the overdraft limit: $";
            cin >> tmax;
            cout << "Enter the rate: ";
            cin >> trate;
            p_client[i] = new BrassPlus(temp, temp_num, temp_bal, tmax, trate);
        }

        // 敲完 1 或 2之后, 缓冲区还有一个回车符
        while(cin.get() != '\n');
    }
    cout << endl;

    // 显示信息
    for (int i = 0; i < CLIENTS; i++){
        // 这里的 ViewAcc 函数是 virtual 的, 所以此时会根据指针所指对象的类型调用相应的函数
        p_client[i] -> ViewAcc();       // 通过指针访问方法, 此时 p_client 可能是Brass对象也可能是BrassPlus对象
        cout << endl;
    }

    // 有 new 就得有 delete !!
    for (int i = 0; i < CLIENTS; i++){
        delete p_client[i];
    }

    /*
        关于这里析构的说明:
            1. 在析构时, 如果是派生类对象, 则应先析构派生类, 再析构基类
            2. 如果派生类的析构函数不是 virtual 的, 则编译器**只会**调用 "指针类型" 对应的析构函数, 也就是说, 如果Brass的析构函数不是virtual的, 那么在这里只有Brass类型的析构函数会被调用
                此时, 哪怕 p_client[i] 指向一个派生类对象, 也不会触发派生类的析构函数!!!
                此时, 需要小心 派生类 里面是否有东西没有析构掉!!!
        
        因此, 如果一个类作为基类使用, 它的析构函数一定要写成虚函数!!!
    */
    return 0;
}
```

---

## virtual 关键字的使用说明
- 当不使用 virtual 关键字时
  - case 1: 如果通过对象来调用, 则通过**对象的类型**来确定使用哪个方法
  - case 2: 如果通过指针或引用来调用, 则通过**指针或引用的类型**来确定使用哪个方法
  ```cpp
  /*
    场景: Brass 是基类, BrassPlus 是派生类
  */

  Brass dom();
  BrassPlus dot();
  // case 1: 通过对象来调用方法
  dom.ViewAcct();     // 调用基类的方法
  dot.ViewAcct();     // 调用派生类的方法

  // case 2: 通过指针来调用方法, 引用类型同理
  Brass *p_dom = &dom;        
  Brass *p_dot = &dot;        // 根据派生类和基类的兼容性, 可以将派生类的对象赋值给基类的指针
  p_dom -> ViewAcct();        // 调用基类的方法(因为指针是基类的)
  p_dot -> ViewAcct();        // 调用基类的方法(因为指针是基类的)
  ```
- 当使用 virtual 关键字时
  - case 1: 如果通过对象来调用, 则通过**对象的类型**来确定使用哪个方法, 这与不使用 virtual 关键字时相同
  - case 2: 如果通过指针或引用来调用, 则通过**指针或引用指向的对象的类型**来确定使用哪个方法
  ```cpp
  /*
    场景: Brass 是基类, BrassPlus 是派生类
  */

  Brass dom();
  BrassPlus dot();

  // case 2: 使用基类的指针指向派生类的对象, 引用类型也是相同的性质
  Brass *p_dom = &dom;
  Brass *p_dot = &dot;        // 注意指向的是派生类对象
  p_dom -> ViewAcct();        // 调用基类的方法(因为指针指向的对象是基类的)
  p_dot -> ViewAcct();        // 调用派生类的方法(因为指针指向的对象是派生类的)
  ```

- 当基类中将方法设置为 virtual 后, 派生类会自动将这个方法自动变成 virtual 的
  - 为了保证易读性, 建议都加上 virtual.
- 如果一个类被设计为`基类`, 则基类的`析构函数`**一定要加上** `virtual` 设置为虚函数!!!
  - 如果基类不加 virtual, 则可能出现派生类的析构函数中有特殊的析构步骤, 但是派生类的析构函数忘记声明为 virtual, 此时如果使用基类类型的引用或者指针来指向派生类, 那么在析构的时候, 派生类的析构函数将永远不会被执行, 从而出现bug(**严重的话可能出现内存泄露**!)


