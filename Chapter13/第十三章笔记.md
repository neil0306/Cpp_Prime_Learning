# 类继承(inheritance)
- 使用场景: 
  - 复用以往写过的类的代码.
  - 扩展已有功能(有可能只拿到一个编译好的库, 但是没有源码)

概念:
- 基类: 原始类(以往已经写好的类)
- 派生类: 继承基类的类(扩展基类功能而重新构建的类)

公有派生:
- 派生时, 在基类的前面加上public
- 基类的**公有成员**将成为派生类的**公有成员**
- 基类的**私有部分**也将成为派生类的一部分, 但**只能通过基类的公有和保护方法进行访问**

对于派生类:
- 可以根据需要添加自己专属的数据成员和成员函数
- 派生类需要自己添加一个构造函数
  - 构造函数不仅**要给自己的新成员初始化**, **也要给基类的成员初始化**
  - 在写派生类的构造函数时需要注意权限问题:
    - 派生类**必须**`使用基类的构造函数来初始化基类的成员`
    - 基类的数据成员必须在派生类的构造函数的`初始化列表中进行初始化`
      - 这是因为C++要求基类的数据成员**在派生类对象初始化之前就构造完成**, 也就是创建派生类对象之前要先创建基类对象, 所以我们只能使用初始化列表的方式来初始化基类的数据成员.
      - **成员初始化列表**本质上`兼顾地完成了基类对象的初始化`.
    ```cpp
    class Derived : public Base 
    {
        public:
            // 在初始化列表中初始化基类的数据成员
            Derived(int i, int j, int k, int l) : Base(i, j)
            {
                m = k;
                n = l;
            }

            /*
                1. 这个构造函数会先用 i,j调用Base的构造函数创建一个基类的对象
                2. 然后才进入派生类的构造函数, 初始化m和n, 构造派生类的对象

                注: 如果注释掉初始化列表的构造函数Base, 则基类就会调用默认构造函数, 此时i,j这两个参数相当于没有使用
            */
    };
    ```

代码例子:
- 头文件`tabtenn1.h`
```cpp
#ifndef __TABTENN0_H__
#define __TABTENN0_H__

#include <iostream>
#include <string>

using std::string;

class TableTennisPlayer
{
    private:
        string firstname;
        string lastname;
        bool hasTable;
    public:
        TableTennisPlayer(const string &fn = "none",
                            const string &ln = "noen", bool ht = false);
        void Name() const;
        bool HasTable() const {return hasTable;}
        void ResetTable(bool v) {hasTable = v;}
};

class RatedPlayer : public TableTennisPlayer        // 派生出RatedPlayer, public表示这是公有派生
{
    private:
        unsigned int rating;
    public:
        RatedPlayer(unsigned int r = 0, const string &fn = "none", const string &ln = "none", bool ht = false);
        RatedPlayer(unsigned int r, const TableTennisPlayer &tp);       // 此时直接传了一个基类的对象作为参数
        unsigned int Rating() const {return rating;}
        void ResetRating(unsigned int r) {rating = r;}
};

#endif //!__TABTENN0_H__
```

- 源文件`tabtenn1.cpp`
```cpp
#include "tabtenn1.h"

#include <iostream>

TableTennisPlayer::TableTennisPlayer(const string &fn, const string &ln, bool ht) : 
                                firstname(fn), lastname(ln), hasTable(ht)
{}

void TableTennisPlayer::Name() const
{
    std::cout << lastname << ", " << firstname;
}

RatedPlayer::RatedPlayer(unsigned int r, const string &fn, const string &ln, bool ht) : TableTennisPlayer(fn, ln, ht)
{
    // 这里只初始化派生类 RatedPlayer 专属的数据成员
    rating = r;
}

// 使用成员初始化列表初始化所有的成员变量
RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer &tp) : TableTennisPlayer(tp), rating(r)        // 触发基类的复制构造函数, 如果没有自定义, 就会使用默认复制构造
{}
```

- 测试文件`usett1.cpp`
```cpp
#include <iostream>

#include "tabtenn1.h"

using namespace std;

int main(void)
{
    RatedPlayer rplayer1(1140, "Mallory", "Duck", false);
    TableTennisPlayer player1("Tara", "Boomdea", false);

    rplayer1.Name();
    if(rplayer1.HasTable()){
        cout << ": has a table." << endl;
    }
    else{
        cout << ": hasn't a table." << endl;
    }
    rplayer1.Name();
    cout << ": Rating: " << rplayer1.Rating() << endl;


    RatedPlayer rplayer2(1212, player1);        // 使用自定义的第二个构造函数
    cout << "Name: ";
    rplayer2.Name();     // 基类的成员函数
    cout << ", Rating: " << rplayer2.Rating() << endl;

    return 0;
}
```


## 小结
1. 在进行析构时, 先析构派生类对象, 再析构基类的对象
2. 如果在**派生类的构造函数中**没有显式地使用成员初始化列表来构造基类对象, 则基类对象将使用**基类的默认构造函数进行构造**
3. 基类与派生类之间的特殊关系
   1. **派生类对象可以使用基类的 public 方法** (但 private 方法不可直接调用)
   2. `基类指针`可以在不进行显式类型转换的情况下`指向派生类对象`, 并且, `基类对象`可以在不进行显式类型转换的情况下`引用派生类对象`.
      ```cpp
      RatedPlayer rplayer1(1140, "Mallory", "Duck", false);
      TableTennisPlayer &rt = rplayer1;       // 基类对象引用派生类对象
      TableTennisPlayer *pt = &rplayer1;      // 基类指针指向派生类对象
      rt.Name();      // 基类引用使用基类方法
      rt->Name();     // 基类指针使用基类方法
      ```
       - 基类指针或者引用在这种情况下**只能调用基类的方**法, 而不能使用派生类的方法. 
       - 这种规则是`单向`的, **不能将基类的指针和引用赋给派生类**. 
         ```cpp
         base -> derived;   // √
         derived -> base;   // X
         ```
         - 理由是: 如果允许将基类直接赋值给派生类, 则会导致派生类的某些成员和方法不可使用, 毕竟派生类对象本来就没有这部分定义.
         - 简单来说就是:`少的调用多的没事, 多的调用少的就不行`
   3. 基类和派生类的兼容关系的应用场景
      ```cpp
      // 1. 将派生类对象作为基类对象的实参
      void Show(const TableTennisPlayer &rt)       // 传入基类对象
      {
          rt.Name();      // 调用基类的方法
      }

      // 2. 用派生类对象初始化基类对象
      RatedPlayer olaf1(1840, "Olaf", "Loaf", true);    // 派生类对象
      TableTennisPlayer olaf2(olaf1);     // 派生类对象传入基类对象, 触发基类的复制构造函数

      // 3. 用派生类对象赋值给基类对象
      TableTennisPlayer olaf3;       // 基类对象
      olaf3 = olaf1;    // 派生类对象赋值给基类对象, 触发基类的赋值运算符重载函数
                        // 注: 重载的定义为 TableTennisPlayer & operator=(const TableTennisPlayer &) const; 
      ```


# 多态
简单来说就是`重载基类的方法`, 以实现不同的类(的对象)里的**同名方法实现不同的功能**.

代码例子:
- 头文件`brass.h`
```cpp
#ifndef __BRASS_H__
#define __BRASS_H__

#include <iostream>
#include <string>
using namespace std;

class Brass
{
    private:
        string fullname;        // 用户名
        long accNum;           // 账户
        double balance;         // 存款金额
    public:
        Brass(const string &s = "NullBody", long an = -1, double bal = 0.0);        // 完成创建账号(初始化数据成员)

        // 养成习惯, 基类的析构函数一定要定义成 虚函数!!!!
        virtual ~Brass(){}

        void Deposit(double amt);
        virtual void Widthdraw(double amt);
        double Balance() const;
        virtual void ViewAcc() const;       // 只显示当前账户里有多少钱
};

class BrassPlus : public Brass      // 派生类
{
    private:
        double maxLoan;         // 贷款额度
        double rate;            // 利率
        double owesBank;        // 本金 + 利息
    public:
        BrassPlus(const string &s = "NullBody", long an = -1, double bal = 0.0, double ml = 500.0, double r = 0.11125);
        BrassPlus(const Brass &ba, double ml = 500.0, double r = 0.11125);
        virtual void ViewAcc() const;         // 显示账户有多少钱, 显示欠款和贷款额度
        virtual void WidthDraw(double amt);
        void ResetMax(double m){maxLoan = m;}
        void ResetRate(double r){rate = r;}
        void ResetOwes(){owesBank = 0.0;}
};

#endif //!__BRASS_H__
```

- 源文件`brass.cpp`
```cpp
#include "brass.h"

Brass::Brass(const string &s, long an, double bal)
{
    fullname = s;
    accNum = an;
    balance = bal;
}

void Brass::Deposit(double amt)
{
    if (amt < 0){
        cout << "Negative deposit is not allowed!" << endl;
    }
    balance += amt;
}

void Brass::Widthdraw(double amt)
{
    if (amt < 0){
        cout << "Widthdraw amount must be positive!" << endl;
    }
    else if(amt <= balance){
        balance -= amt; 
    }
    else {
        cout << "Widthdraw amount exceeded your balance!" << endl;
    }
}

double Brass::Balance() const
{
    return balance;
}

void Brass::ViewAcc() const
{
    cout << "Client: " << fullname << endl;
    cout << "Account Number: " << accNum << endl;
    cout << "Balance: $" << balance << endl;
}

BrassPlus::BrassPlus(const string &s, long an, double bal, double ml, double r) : Brass(s, an, bal)
{
    maxLoan = ml;
    rate = r;
    owesBank = 0.0;
}

BrassPlus::BrassPlus(const Brass &ba, double ml, double r) : Brass(ba)
{
    maxLoan = ml;
    rate = r;
    owesBank = 0.0;
}

void BrassPlus::ViewAcc() const         // 虚函数在定义时不需要再加 virtual
{
    Brass::ViewAcc();       // 指明先调用的是基类的ViewAcc函数
    cout << "Maximum Loan: $" << maxLoan << endl;
    cout << "Loan Rate: " << rate << endl;
    cout << "Owed to bank: $" << owesBank << endl;
}

void BrassPlus::WidthDraw(double amt)  // 虚函数在定义时不需要再加 virtual
{
    double bal = Balance();     // 虽然没有在派生类中定义balance, 但是基类中已经有这个函数(且输入public), 直接使用即可

    if(amt <= bal){             // 余额充足, 直接取钱
        Brass::Widthdraw(amt);
    }
    else if(amt <= bal + maxLoan - owesBank){       // 注意此时余额已经不够了, 余额 + 透支额度 - 已有贷款 = 当前能取的金额
        double advance = amt - bal;
        owesBank = advance * (1.0 + rate);          // 更新一下总欠款
        cout << "Bank Advance: $" << advance << endl;       // 显示本次取钱需要向银行借多少钱
        cout << "Finance Charge: $" << advance * rate << endl;      // 显示加上手续费之后一共多少钱
    
        Deposit(advance);           // 向银行借完钱, 刷新可取钱的余额
        Brass::Widthdraw(amt);      // 调用基类的widthdraw
    }
    else{
        cout << "Credit limit exceeded!" << endl;
    }
}
```

- 测试1 `useBrass1.cpp`
```cpp
#include "brass.h"
#include <iostream>

using namespace std;

int main(void)
{
    Brass rick("Rick", 123456, 4000);
    BrassPlus jack("Jack", 654321, 3000);

    // 使用对象调用相应的方法
    rick.ViewAcc();         // 调用基类方法
    cout << endl;
    jack.ViewAcc();         // 调用派生类方法
    cout << endl;
    
    // 测试透支功能
    cout << "Deposit $1000 into the Jack Account. " << endl;
    jack.Deposit(1000);
    cout << "New balance: $" << jack.Balance() << endl;

    cout << "Widthdraw 4200 from the Rick Account." << endl;
    rick.Widthdraw(4200);       // 基类对象, 不允许透支

    cout << "-----------" << endl;
    cout << "Widthdraw 4200 from the Jack Account." << endl;
    jack.WidthDraw(4200);       // 派生类对象, 可以透支
    jack.ViewAcc();             // 打印透支后的情况

    return 0;
}
```

- 测试2: `useBrass2.cpp`
```cpp
#include "brass.h"
#include <iostream>

using namespace std;
const int CLIENTS = 3;

int main(void)
{
    Brass *p_client[CLIENTS];
    string temp;
    long temp_num;
    double temp_bal;
    int kind = 1;
    for (int i = 0; i < CLIENTS; i++){
        // 让用户输入开户信息
        cout << "Enter the client's name: ";
        getline(cin, temp);     // 因为可能存在空格, 所以需要捕获一整行
        cout << "Enter client's account number: ";
        cin >> temp_num;
        cout << "Enter openning balance: $";
        cin >> temp_bal;
        cout << "Enter 1 for Brass account or enter 2 for BrassPlus account: ";
    
        while(cin >> kind && (kind != 1 && kind != 2)){
            cout << "Enter either 1 or 2: ";
        }
        // 创建对象指针
        if (kind == 1){
            p_client[i] = new Brass(temp, temp_num, temp_bal);        // 对类使用new, 会触发构造函数
        }
        else{
            double tmax, trate;
            cout << "Enter the overdraft limit: $";
            cin >> tmax;
            cout << "Enter the rate: ";
            cin >> trate;
            p_client[i] = new BrassPlus(temp, temp_num, temp_bal, tmax, trate);
        }

        // 敲完 1 或 2之后, 缓冲区还有一个回车符
        while(cin.get() != '\n');
    }
    cout << endl;

    // 显示信息
    for (int i = 0; i < CLIENTS; i++){
        // 这里的 ViewAcc 函数是 virtual 的, 所以此时会根据指针所指对象的类型调用相应的函数
        p_client[i] -> ViewAcc();       // 通过指针访问方法, 此时 p_client 可能是Brass对象也可能是BrassPlus对象
        cout << endl;
    }

    // 有 new 就得有 delete !!
    for (int i = 0; i < CLIENTS; i++){
        delete p_client[i];
    }

    /*
        关于这里析构的说明:
            1. 在析构时, 如果是派生类对象, 则应先析构派生类, 再析构基类
            2. 如果派生类的析构函数不是 virtual 的, 则编译器**只会**调用 "指针类型" 对应的析构函数, 也就是说, 如果Brass的析构函数不是virtual的, 那么在这里只有Brass类型的析构函数会被调用
                此时, 哪怕 p_client[i] 指向一个派生类对象, 也不会触发派生类的析构函数!!!
                此时, 需要小心 派生类 里面是否有东西没有析构掉!!!
        
        因此, 如果一个类作为基类使用, 它的析构函数一定要写成虚函数!!!
    */
    return 0;
}
```

---

## virtual 关键字的使用说明
- 当不使用 virtual 关键字时
  - case 1: 如果通过对象来调用, 则通过**对象的类型**来确定使用哪个方法
  - case 2: 如果通过指针或引用来调用, 则通过**指针或引用的类型**来确定使用哪个方法
  ```cpp
  /*
    场景: Brass 是基类, BrassPlus 是派生类
  */

  Brass dom();
  BrassPlus dot();
  // case 1: 通过对象来调用方法
  dom.ViewAcct();     // 调用基类的方法
  dot.ViewAcct();     // 调用派生类的方法

  // case 2: 通过指针来调用方法, 引用类型同理
  Brass *p_dom = &dom;        
  Brass *p_dot = &dot;        // 根据派生类和基类的兼容性, 可以将派生类的对象赋值给基类的指针
  p_dom -> ViewAcct();        // 调用基类的方法(因为指针是基类的)
  p_dot -> ViewAcct();        // 调用基类的方法(因为指针是基类的)
  ```
- 当使用 virtual 关键字时
  - case 1: 如果通过对象来调用, 则通过**对象的类型**来确定使用哪个方法, 这与不使用 virtual 关键字时相同
  - case 2: 如果通过指针或引用来调用, 则通过**指针或引用指向的对象的类型**来确定使用哪个方法
  ```cpp
  /*
    场景: Brass 是基类, BrassPlus 是派生类
  */

  Brass dom();
  BrassPlus dot();

  // case 2: 使用基类的指针指向派生类的对象, 引用类型也是相同的性质
  Brass *p_dom = &dom;
  Brass *p_dot = &dot;        // 注意指向的是派生类对象
  p_dom -> ViewAcct();        // 调用基类的方法(因为指针指向的对象是基类的)
  p_dot -> ViewAcct();        // 调用派生类的方法(因为指针指向的对象是派生类的)
  ```

- 当基类中将方法设置为 virtual 后, 派生类会自动将这个方法自动变成 virtual 的
  - 为了保证易读性, 建议都加上 virtual.



- 类的`构造函数`**禁止**设置为虚函数! 原因如下
  1. 派生类的类名就与基类不一致了, 这种情况并不符合继承的情况
  2. 派生类中如果存在与构造函数重名的方法, 则此时可能存在误调用那个方法而不是构造函数, 从而引发bug



- 如果一个类被设计为`基类`, 则基类的`析构函数`**一定要加上** `virtual` 设置为虚函数!!!
  - 如果基类不加 virtual, 则可能出现派生类的析构函数中有特殊的析构步骤, 但是派生类的析构函数忘记声明为 virtual, 此时如果使用基类类型的引用或者指针来指向派生类, 那么在析构的时候, 派生类的析构函数将永远不会被执行, 从而出现bug(**严重的话可能出现内存泄露**!)
  - 如果添加了 virtual, 哪怕这个类不用做基类, 它也不会触发任何错误, 这仅仅会增加一些额外的开销(具体看下面的虚函数工作原理笔记)


- `友元函数`**不能**设置为虚函数!
  - 因为友元函数**不是类的成员函数**!

- 派生类里`重新定义的虚函数`都会**隐藏掉基类的同名函数**, 注意**不是重载**而是重新定义.
    ```cpp 
    class Dwelling
    {
      public:
          virtual void showperks(int a) const;
    };

    class Hovel : public Dwelling
    {
      public:
          virtual void showperks() const;       // 重新定义了基类的虚函数, 此时基类的同名函数将被隐藏
    };
    ```
    - 经验规则:
      1. 如果重新定义继承的方法, 应确保新方法与原方法具有`相同的参数列表`, 但如果**返回类型**是基类引用或指针, 则`可以修改为指向派生类的引用或指针`, 这种做法称为`返回类型协变(covariance of return types)`, 因为允许返回类型随类类型的变化而变化.
      2. 如果基类中某个虚函数声明被重新定义了, 则应在派生类中重新定义所有的基类版本(基类中如果有多个重载版本就都需要重新定义!), 如果没有全部重新定义, 则没有被重新定义的基类里的版本将在派生类对象中无法使用.
        ```cpp
        // 基类中名字为 showperks 的函数有2个重载版本, 共计3个, 派生类中如果重新定义了其中一个, 则其他2个也要重新定义
        class Dwelling
        {
          public:
            virtual void showperks(int a) const;
            virtual void showperks(double x) const;
            virtual void showperks() const;
        };

        // 如果需要重新定义任何一个继承过来的虚函数, 则派生类中需要把基类的所有重载版本都重新定义
        class Hovel : public Dwelling
        {
          public:
          // 基类中的3个版本都需要全部重新定义
            virtual void showperks(int a) const;
            virtual void showperks(double x) const;
            virtual void showperks() const;
        };
        ```

- 使用虚函数的核心思想:
  - 如果**要在派生类中重新定义基类的方法**, 则应该将它设置为虚函数, 否则应该设置为普通函数.

### 虚函数的工作原理
C++ 只规定了虚函数的行为, 但如何实现虚函数是由编译器决定的(不同厂商会推出不同的编译器, 也就有不同的虚函数实现方法, 这里不是指用户怎么写的代码, 这个方法是指怎么实现虚函数的特性).

通常来说, 编译器处理虚函数的方法是`给每一个对象添加一个隐藏成员`, 该成员里保存了一个指针, 这个指针指向一个`函数地址数组`, 这种数组被称为`虚函数表(virtual function table, vtbl)`, 它记录了为当前类对象进行声明的`虚函数地址`.
- 如果派生类重新定义了某个虚函数, 则虚函数表里对应的地址将被更新为当前定义的函数地址, 没有重新定义的话就保持原来的虚函数地址.

因此, 使用虚函数将增加以下3个额外开销:
1. `每个对象`都将增大, 增大的空间为一个指针的大小(这个指针指向虚函数表)
2. 对于`每一个类`, 编译器将创建一个虚函数地址表(虚函数表, 一个数组)
3. 对于每个函数调用, 都需要执行额外的`查表操作`(查虚函数表).


## 静态联编和动态联编
将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding), 在C++中, 由于存在函数重载这种概念, 故无法直接跟用函数名直接匹配需要运行的代码块, 编译器需要根据函数的参数列表进行匹配后才能确认执行哪一个函数, 因此, 函数名联编细分出了`静态联编`和`动态联编`.
  - 在编译器编译的过程中就能确定执行哪个函数的代码块的过程, 称为静态联编(static binding), 又叫早期联编(early binding).
  - 由于`虚函数`的存在, 编译器必须在执行过程中才能确定需要执行的函数代码块(比如前面例子里的 p_client指针, 它指向的对象类型是通过用户反馈才能确定的), 这种被称为动态联编(dynamic binding), 又称为晚期联编(late binding)

优缺点:
1. 静态联编比动态联编执行效率更高(额外开销看前面虚函数的工作原理笔记), 如果一个类没有派生类, 则使用静态联编就好.
2. 如果派生类需要修改基类的方法, 就需要将该方法声明为虚函数, 此时就是动态联编.

# 访问限制 (protected)
除了 `private` 之外, 还有一个 `protected` 关键字用来保护数据成员, 但是protected只有在基类**派生的类中才能起作用**.
- 派生类可以直接访问基类的`public成员和protected成员`, 但是不能访问基类的`private成员`
- 在对象的外部来说, protected成员和private成员是一样的, 都不能直接用成员运算符`.`进行访问, 只能通过基类的`公有方法`来访问, 但对于派生类来说, protected 成员可以在派生类的方法中进行直接访问, 就像public成员一样进行任意修改.
  - 鉴于这种特性:
    - **最好对**`数据成员`**采用 privated 进行访问控制, 不要使用protected**, 在派生类中使用 基类的public方法 来访问 基类private成员 才是安全的做法. 
    - 对于`成员函数`来说, 它能`让派生类访问公众不能使用的基类内部函数`!
      - 简单来说就是: 当某个函数不希望用户使用, 但又希望能给派生类使用, 就加 protected.


# 抽象基类 (Abstract Base Class, ABC)
场景: 当基类相比派生类来说过于庞大, 或者派生类只会用到基类的很少一部分数据成员和方法时,通常就需要使用抽象基类了.
- 比如圆(Circle)和椭圆(Ellipse), 圆是椭圆的一种特殊情况, 椭圆有长短轴, 而圆只有半径, 如果把椭圆作为基类, 圆作为派生类, 就存在一些资源浪费, 比较好的解决方案就是重新设计一个抽象类, 这个抽象类描述了圆和椭圆的共同特征(中心点), 然后把圆和椭圆都作为派生类即可.
  - 这样做的好处是: 使用基类指针同时管理 Circle 和 Ellipse 对象(依靠多态), 从而避免了资源浪费.

抽象基类:
1. 用于描述多个类的共同特征, 它的存在意义是为了让派生类继承它, 从而实现多态.
2. 为了实现多态, 一般抽象基类都会使用`纯虚函数(pure virtual function)`
   1. **抽象基类必须有一个纯虚函数**
3. 抽象基类不可以实例化



## 纯虚函数 (pure virtual function)
- 纯虚函数的写法:
  - `virtual 函数名() = 0;`
- 纯虚函数表明当前这个类**一定是**`抽象基类`
- 如果一个成员函数被声明为纯虚函数, 则可以不提供函数实现(提供实现也行)


# 继承和动态内存分配
本节主要探讨`基类使用了new`, 并自定义了`复制构造函数`和`重载了赋值运算符`, 此时派生类中会发生什么.

## 基类使用new, 派生类不使用new
- 派生类的成员变量如果**没有用到 new**, 则`可以使用默认的复制构造函数`, 并且`不需要重载赋值运算符`.
  - 因为在执行复制时, 编译器会先调用基类的复制构造函数, 然后再触发派生类的复制构造函数, 因此, 基类中需要new的变量会自动完成, 派生类使用默认的复制构造函数不会出任何问题.
- 派生类**没有用到 new 的话**, 可以不写析构函数.


## 基类使用new, 派生类也使用new
当基类和派生类都使用动态内存分配(`new`)时:
- 派生类需要**显式地**编写`析构函数`
- 派生类需要**显式地**重新定义`复制构造函数`
- 派生类需要**显式地**重新定义`赋值运算符`


代码例子:
- 头文件`dma.h`
```cpp
#ifndef __DMA_H__
#define __DMA_H__

#include <iostream>
using namespace std;

class baseDMA
{
    private:
        char *label;
        int rating;
    public:
        baseDMA(const char *l = "null", int r = 0);     // 默认构造
        virtual ~baseDMA();                             // 基类就应该写一个虚析构函数
        
        baseDMA(const baseDMA &rs);
        baseDMA & operator=(const baseDMA &rs);         // 有复制构造函数就一定要重载赋值运算符
        
        friend ostream & operator<<(ostream &os, const baseDMA &rs);        // 输出
};

// 不带new的派生类
class lacksDMA : public baseDMA
{
    private:
        enum {COL_LEN = 40};
        char color[COL_LEN];        // 这里已经分配好内存了. 没有动态分配内存, 可以不写当前派生类的析构函数
    public:
        lacksDMA(const char *l = "null", int r = 0, const char *c = "blank");
        lacksDMA(const baseDMA &rs, const char *c = "blank");
        // 注: 由于派生类中没有使用new为成员变量分配空间, 所以派生类可以不写复制构造函数; 同样也不需要重载赋值运算符
        friend  ostream & operator<<(ostream &os, const lacksDMA &rs);
}; 

// 带new的派生类
class hasDMA : public baseDMA
{
    private:
        char * style;
    public:
    hasDMA(const char *l = "null", int r = 0, const char *s = "null");
    hasDMA(const baseDMA &rs, const char *s);
    hasDMA(const hasDMA &hs);       // 复制构造函数
    virtual ~hasDMA();      // 由于这个派生类的数据成员是用了 new, 所以一定要自定义析构函数

    hasDMA & operator=(const hasDMA &hs);   // 重写了复制构造函数, 就一定要重写赋值运算符
    friend ostream & operator<<(ostream &os, const hasDMA &rs);
};

#endif //!__DMA_H__
```

- 源文件`dma.cpp`
```cpp
#include "dma.h"
#include <cstring>      // strcpy 和 strlen 需要用到

baseDMA::baseDMA(const char *l, int r)
{
    label = new char [strlen(l) +1];
    strcpy(label,l);
    rating = r;
}

baseDMA::baseDMA(const baseDMA &rs)
{
    label = new char [strlen(rs.label) + 1];
    strcpy(label, rs.label);

    rating = rs.rating;
}

baseDMA::~baseDMA()
{
    delete [] label;
}

baseDMA & baseDMA::operator=(const baseDMA &rs)
{
    /*
        赋值运算符一共包含4步:
        1. 查看当前对象是否为自己本身
        2. 释放自身对象
        3. 开辟内存空间
        4. 拷贝数据
    */

    // step1:
    if (this == &rs){
        return *this;
    }

    // step2:
    delete [] label;

    // step3:
    label = new char[strlen(rs.label) + 1]; // +1 为空字符 '\0'

    // step4:
    strcpy(label, rs.label);
    rating = rs.rating;

    return *this;
}

ostream & operator<<(ostream &os, const baseDMA & rs)
{
    os << rs.label << endl;
    os << rs.rating << endl;
    return os;
}

lacksDMA::lacksDMA(const char *l, int r, const char *c) : baseDMA(l, r)
{
    strncpy(color, c, COL_LEN -1);      // 别忘记-1, 留给 '\0'
    color[COL_LEN -1] = '\0';
}

lacksDMA::lacksDMA(const baseDMA &rs, const char *c) : baseDMA(rs)
{
    strncpy(color, c, COL_LEN -1);      // 别忘记-1, 留给 '\0'
    color[COL_LEN -1] = '\0';
}

ostream & operator<<(ostream &os, const lacksDMA &ls)
{
    // 由于派生类无法直接访问基类的数据成员, 这里巧妙地是用了基类重载的输出运算符
    os << (const baseDMA &)ls;   // 把派生类强制类型转换成基类, 注意还是 const 并且是 引用!!
    os << ls.color << endl;
    return os;
}

// 使用了 new 的派生类 hasDMA
hasDMA::hasDMA(const char *l, int r, const char *s) : baseDMA(l,r)
{
    style = new char[strlen(s) +1];
    strcpy(style, s);
}

hasDMA::hasDMA(const baseDMA &rs, const char *s) : baseDMA(rs)
{
    style = new char[strlen(s) +1];
    strcpy(style, s);
}

hasDMA::hasDMA(const hasDMA &hs) : baseDMA(hs)          // 利用基类可以兼容派生类的规则, 这里会触发基类的复制构造函数
{
    cout << "Copy construct function." << endl;
    style = new char[strlen(hs.style) + 1];
    strcpy(style, hs.style);
}

hasDMA::~hasDMA()
{
    delete [] style;
}

hasDMA & hasDMA::operator=(const hasDMA &hs)
{
    cout << "Operator function." << endl;

    // 赋值运算符重载一共4步: 1. 检查是否为当前对象; 2. 释放此前new的空间; 3. 开辟新的空间; 4.拷贝数据

    // step1
    if (this == &hs){
        return *this;
    }

    // step2
    baseDMA::operator=(hs);     // 这里面会包含基类new出来的对象的释放, 拷贝等步骤
    /*
    使用重载运算符有两种方法: 
        1. 运算符表示法;
        2. 函数表示法
        注意: 
            这里只能使用函数表示法, 因为运算符表示法没办法指定是基类的还是派生类的运算符.
            在调用基类重载的赋值运算符过程中, 在重载函数内部, 隐藏的参数this会指向当前需要拷贝数据的对象, 因此我们可以不用接它的返回值.
                形象地说: n1 = n2 这个语句中, =号被替换为 baseDMA::operator=, 而 n1 是在operator=这个函数里面用 this 来替换的
    */
    delete [] style;

    // step3
    style = new char[strlen(hs.style) + 1];

    // step4
    strcpy(style, hs.style);

    return *this;
}

ostream & operator<<(ostream &os, const hasDMA &rs)
{
    os << (const baseDMA &) rs;   // 先转基类, 然后触发基类的重载运算符
    os << "Style: " << rs.style << endl;
    return os;
}
```

- 测试文件`usedma.cpp`
```cpp
#include "dma.h"

using namespace std;

int main(void)
{
    // 测试基类
    baseDMA shirt("Protabelly", 8);
    cout << "Displaying baseDMA object: " << endl;
    cout << shirt;
    cout << "-----------------" << endl;

    // 测试不用new的派生类
    lacksDMA ballon("Blimpo", 4, "red");
    cout << "Displaying lacksDMA object: " << endl;
    cout << ballon;
    cout << "-----------------" << endl;

    lacksDMA ballon2(ballon);       // 调用复制构造(基类自定义的复制构造+派生类的默认复制构造)
    cout << "Result of lacksDMA object: " << endl;
    cout << ballon2;                // 从显示结果看, 基类和派生类的数据都成功拷贝到了 ballon2
    cout << "-----------------" << endl;

    // 测试使用new的派生类
    hasDMA map("Keys", 5, "Mercator");
    cout << "Displaying hasDMA object: " << endl;
    cout << map;
    cout << "-----------------" << endl;

    hasDMA map2 = map;              // 这是初始化, 触发 复制构造函数 (从输出可以看到)
    map2 = map;                     // 这里是调用赋值运算符
    cout << "Result of hasDMA copy: " << endl;
    cout << map2;
}
```


# 设计类的回顾(总结)

## 编译器生成的成员函数
1. 默认构造函数
   1. 要么没有参数, 要么所有参数都有初始值
   2. 一个功能是让我们能创建对象, 另一个功能则是调用`基类的默认构造函数`
   3. 如果派生类的构造函数中没在成员初始化列表调用基类的构造函数, 则编译器会调用基类的默认构造函数
   4. 自定义的构造函数会优先被调用, 建议是显式地自定义一个构造函数

2. 默认的复制构造函数
   1. 调用场景:
      1. 将**新对象初始化为一个同类对象**
      2. **按值将对象传递**给函数
      3. 函数**按值返回对象**
      4. 编译器**生成临时对象**
   2. 需要自定义复制构造函数的场景:
      1. 使用new初始化的成员指针, 它们通常要求执行**深拷贝**, 或者类**可能包含需要修改的静态变量**, 此时就一定要显示地定义一个复制构造函数.

3. 赋值运算符
   1. 首先需要注意不要将`赋值`和`初始化`搞混! 
      1. 初始化语句通常是声明变量的过程中完成的, 形如`类型名 变量名 = 初始值;`, 特点是左侧有`类型名`
      2. 赋值语句则是在已声明变量后, 对变量进行值的更改, 形如 `变量名 = 某个值;`.
   2. 需要自定义赋值运算符的场景:
      1. 成员变量涉及 new 动态分配内存空间时, 一定要显式地自定义赋值运算符. 根本原因也是它们通常要求执行**深拷贝**, 或者类**可能包含需要修改的静态变量**.
      2. 一个简单且必要的习惯是: **只要自定义了复制构造函数, 就一定要重定义赋值运算符**.
      3. 由于编译器**不会**生成**由一个类型赋值给另一种类型的赋值运算**符, 故如果需要这种功能, 就必须自定义赋值运算符(也叫**转换函数**).
         1. 如 `star & Star::operator(const char *) {...}`, 它主要实现的是`将字符串直接赋值给Star的对象`.

第十八章还会介绍 C++11 中新增的`移动构造`和`移动赋值运算符`.

## 其他类的方法
1. 构造函数
   - 构造函数是用来创建对象的, 它无法被对象调用, 因此构造函数不会被继承.

2. 析构函数
   - 用来释放构造函数中new出来的内存空间
   - 对于基类, `一定要写虚析构函数`
     - 用虚析构函数才能保证在析构派生类的对象时, 析构顺序是正确的.
3. 转换函数 (**尽量少用**)
   - 用来**当前类的对象**转换成**另一个类的对象**
     - 构造函数则是将 **某种类型** 转换为 **当前类类型**
   - 一般来说, 转换函数的返回类型是`目标类型`, 而不是`源类型`
   - 转换函数的名称必须是`operator type()`, 其中type是目标类型
   - 显示转换和隐式转换
     - 使用`explicit`关键词修饰的转换函数只能显示地调用
        ```cpp
        class Star
        {
            public:
                explicit Star(const char*);     // 用explicit表明禁止隐式转换
        }
        //...
        Star north;
        north = Star("Polaris");        // 显示调用
        north = "Polaris";              // 隐式调用, 此时会报错
        ```
   - 转换函数既可以是`没有参数的类成员函数`, 也可以是`返回类型为目标类型的类成员函数`
     - 要小心**有些情况下编写转换函数可能会引发二义性**
        ```cpp
        Vector ius(6.0, 0.0);
        Vector lux = ius + 20.2;
        /*
            假如定义了一个 Vector 转 double 的转换函数, 则第二行代码就存在二义性:
                1. 编译器可以将ius转换为 double, 与20.2使用 double 的加法相加
                2. 编译器可以将20.2转换为 Vector (触发构造函数), 与 ius 使用 Vector 的加法相加
        */
        ```

4. 按值传递对象和按引用传递
编写使用`对象作为参数的函数时`, 应按引用而不是按值传递对象, 因为按值传递就会触发数据拷贝(赋值构造 + 析构), 消耗资源&降低效率.
   - 如果是按引用传递, 则应尽可能考虑是否需要加**const**
     - 如果走腾讯的代码分析规则, 按引用传递也是不推荐的, 它推荐的是使用`对象指针进行传递`.
   - 如果使用了按引用/指针传递, 则根据基类兼容派生类的规则, 这个函数甚至可以将派生类传进去.

5. 返回对象和返回引用
   - 使用返回引用的场景更多, 因为返回对象会生成一个临时副本(拷贝构造+析构), 会消耗资源
   - 如果返回的是`局部/临时对象`, 则**必须使用返回对象的方式**, 因为局部对象在函数结束后就会被销毁, 此时返回引用就会出现悬空引用的问题.


6. 使用const
  1. 函数形参里带const
    - 用来确保**函数内部不会修改**`传入的参数`
  2. 成员函数末尾加const
    - 用来确保**函数内部不会修改**`成员变量`
  3. 函数返回值加const
    - 通常是根据 **入参对象有没有加const** 以及 **函数末尾有没有const** 来做决定的, 返回类型需要根据返回的那个变量本身是否带const来决定

## 公有继承的考虑因素
### 要遵循 is-a 关系
所谓 遵循is-a关系 简单描述就是: 如果派生类不是一种特殊的基类, 就不要使用公有派生.
- 当不确定两个类是否完美地具备互相包含的关系时, 一个比较科学的方式是: 建立一个抽象类, 然后将这两个类都作为它的派生类.
- 表示 is-a 关系的方式之一是`无需使用显示类型转换`, 即基类指针可以直接指向派生类对象.
  - 但反过来不行, 派生类指针一定要进行**显式的类型转换**才可以指向基类对象.

### 什么不能被继承
1. 构造, 析构函数都不能被继承
2. **赋值运算符**不能被继承
   - 因为赋值运算符的`特征标`随类的改变而改变.

### 赋值运算符
1. 只要类的成员变量涉及到new运算动态分配内存, 那么就一定要**显式地**定义赋值运算符(以及复制构造函数)
2. 赋值运算符的左侧为基类对象, 右侧为派生类对象是允许的. 但反过来不可以, 除非有转换函数.
   ```cpp
   Brass blips;     // 基类对象
   BrassPlus snips("rafe plosh", 91191, 3993.19, 600.0, 0.12);  // 派生类对象
   blips = snips;   // 可行: 左侧是基类对象, 右侧是派生类对象
    /*
        此时这条语句相当于 Brass.operator=(snips);  
                因为按照成员函数来说, 使用成员函数时, 类的对象一定位于左侧.
            这个运算符的声明为 Brass.operator=(const Brass &);
            根据 is-a 规则, 派生类对象可以赋值给基类对象的引用, 只不过在这种情况下, 只有snips里对应的基类成员会被赋值给blips.
    */

   // 如果反过来
   Brass gp("Griff Hexbait", 21234, 1200);  // 基类
   BrassPlus temp;
   temp = gp;       // 不合法
   /*
        这条语句相当于 BrassPlus.operator=(gp);
            而对应的声明为 BrassPlus.operator=(const BrassPlus &);
            根据 is-a 规则, 基类对象不能赋值给派生类对象的引用, 因此这条语句不合法.
   */
   ```
- 例外的情况有以下两种:
    1. 定义了转换构造函数, 此时编译器会调用这个构造函数临时创建一个对象, 把基类转成了派生类.
        - 如: `BrassPlus(const Brass &)`, `BrassPlus(const Brass &ba, double ml = 500, double r = 0.1)`
        - 写这种构造函数时, 要注意派生类的成员变量一定要写全, 不能漏.
    2. 单独编写了一个`将基类赋值给派生类的赋值运算符重载`.

### 私有成员与保护成员 
1. 对于派生类而言, 保护成员相当于公有成员, 而私有成员则无法被派生类直接访问.
   1. 这就说明, 为了安全起见, 最好`不要将数据成员设置为protected`, 而是全部将数据成员设置为`private`
2. 对于外部而言, 保护成员与私有成员类似, 都不能直接访问.
3. 设计原则: 只要是数据成员就都设置为**private**, 如果只希望派生类能访问某些基类的成员函数, 则将这些成员函数设置为**protected**.  

### 虚函数/虚函数
- 如果希望派生类能重新定义该方法, 则应在基类中将方法定义为虚方法 (实现动态联编)
- 如果不希望派生类重新定义它, 则基类中不必将这个方法声明为 virtual (静态联编).

### 析构函数
基类的析构函数一定要写, 且**一定要定义成虚函数**!
- 因为在进行析构时, 编译器将首先调用派生类的析构函数, 然后再调用基类的析构函数, 通过虚函数我们才能实现这种动态的调用方式.

### 友元函数
- 友元函数不是成员函数, 所以`友元函数不能被继承`. 
  - 如果希望派生类也能使用基类的友元函数, 则应该`先通过强制类型转换, 将派生类引用/指针转为基类的引用/指针`, 然后再使用转换后的东西来调用友元函数.
    ```cpp
    ostream & operator<<(ostream &os, const hasDMA &hs)
    {
        os << (const baseDMA &) rs;   // 先转基类, 然后触发基类的重载运算符, 注意这个重载的运算符是基类的友元函数
        os << "Style: " << rs.style << endl;
        return os;
    }
    ```


### 有关使用基类方法的说明
1. 如果派生类中没有重新定义这个方法, 派生类对象将自动使用继承而来的基类方法
2. 派生类的构造函数会自动调用基类的构造函数
3. 如果在派生类的构造函数的`成员初始化列表中没有指明基类的构造函数`, 则派生类的构造函数自动调用基类的默认构造函数, 如果指定了基类的构造函数, 则执行指定的.
4. 派生类方法可以通过作用`域解析运算符`来调用**公有的**和**受保护的**基类方法.
5. 派生类的友元函数可以通过`强制类型转换`, 将派生类的引用/指针转换为基类的引用/指针, 从而实现调用基类的友元函数.


