# 题目
![](第十六章_编程题_images/第十六章_编程题_1-3.png)
![](第十六章_编程题_images/第十六章_编程题_4-8.png)
![](第十六章_编程题_images/第十六章_编程题_9.png)
![](第十六章_编程题_images/第十六章_编程题_10.png)


# 1. 
判断回文串, 不判断大小写和空格.
```cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

bool same_after_reverse(const string &s);

int main(void)
{
    string str;

    cout << "Please enter a string: ";
    cin >> str;

    if(same_after_reverse(str)){
        cout << "Palindromic" << endl;
    }
    else{
        cout << "Not Palindromic." << endl;
    }
    return 0;
}

bool same_after_reverse(const string &s)
{
    string temp;
    temp = s;
    reverse(temp.begin(), temp.end());      // 用到 reverse 函数
    return temp == s;
}
```

# 2.
```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>       // tolower, isalpha

using namespace std;

bool same_after_reverse(const string &s);

int main(void)
{
    string str;

    cout << "Please enter a string: ";
    getline(cin, str);

    if(same_after_reverse(str)){
        cout << "Palindromic" << endl;
    }
    else{
        cout << "Not Palindromic." << endl;
    }
    return 0;
}

bool same_after_reverse(const string &s)
{
    string temp;
    for(int i = 0; i < s.size(); i++){
        if(isalpha(s[i])){
            temp += tolower(s[i]);      // 直接追加到 temp 末尾
        }
    }
    string temp1 = temp;
    reverse(temp1.begin(), temp1.end());
    return temp1 == temp;
}
```

# 3.
```cpp
#include <iostream>
#include <string>
#include <cctype>   // 用到 tolower 就要引入
#include <ctime>    
#include <cstdlib>
#include <fstream>
#include <vector>

using namespace std;

const int NUM = 26;
// const string wordlist[NUM] = {
// 	"apiary", "beetle", "cereal", "danger", "ensign", "florid",
// 	"health", "insult", "jackal", "keeper", "loaner", "manage",
// 	"nonce",  "onset",  "plaid",  "quilt",  "remote", "stolid",
// 	"train",  "useful", "valid",  "whence", "xenon",  "yearn",
// 	"zippy"
// };

int main(void)
{

    // 从文件中读取字符串
    ifstream fin;
    fin.open("wordlist.txt");

    if(fin.is_open() == false){
        cerr  << "Can't open flie. Bye. ";   // cerr 只能輸出到標準輸出設備上(cout則還可以輸出到比如文本等其他位置上)
        exit(EXIT_FAILURE);
    }

    string item;
    vector<string> wordlist;
    while(fin){
        getline(fin, item, ','); 
        wordlist.push_back(item);
    }
    fin.close();

    // 处理字符串
    char play;
    srand(time(0));     // 設置隨機數種子

    cout << "Will you play a word game? <y/n> ";
    cin >> play;
    tolower(play);  // 為了方便判斷, 全部轉小寫

    while(play == 'y'){
        string target = wordlist[rand() % NUM];     // 0~25 中隨機選一個數
        int length = target.length();
        string attempt(length, '-');
        string badchars;    // 歷史猜錯的字符
        int guess = 6;      // 最多允許猜 6 次
        cout << "Guess my secret word, it has " << length << " length, and you guess one character at a time. You get " << guess << " wrong guesses." << endl;

        cout << attempt << endl;
        while(guess > 0 && attempt != target){
            char letter;
            cout << "Guess a letter: ";
            cin >> letter;

            // 檢查是否猜過
            if(badchars.find(letter) != string::npos || attempt.find(letter) != string::npos){      // 如果輸入的字符有出現在輸錯的記錄中, 或者 正確字符中曾經出現過
                cout << "You have already guessed that, try again!" << endl;
                continue;
            }

            // 沒出現過:
            int loc = target.find(letter);
            if(loc == string::npos){        // 當前猜的字符在target中找到末尾也沒有找到 ==> 猜錯了
                cout << "Oh, Bad Guess!" << endl;
                guess --;
                badchars += letter;
            }
            else{                           // 猜對的情況
                cout << "Good Guess!" << endl;
                attempt[loc] = letter;      // 這裡只替換了一個字符
                while(loc != string::npos){
                    attempt[loc] = letter;
                    loc = target.find(letter, loc +1);
                };
                
            }
            // 猜完一輪, 輸出當前猜測狀態
            cout << "Your word: " << attempt << endl;
            if(attempt != target){
                if(badchars.length() > 0){
                    cout << "Bad choices: " << badchars << endl;
                }
                cout << guess << " bad guess left!" << endl;
            }
        }
        // 判斷猜完之後是否正確
        if( guess > 0 || attempt == target){
            cout << "That's right!" << endl;
        }
        else{
            cout << "Sorry, the word is: " << target <<  endl;
        }

        cout << "Will you play another time? <y/n>" << endl;
        cin >> play;
        tolower(play);  // 為了方便判斷, 全部轉小寫
    }

    return 0;
}
```

# 4.
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

int reduce(long arr[], int n);

int main(void)
{
    long arr[5] = {200, 100, 300, 100, 200};

    int size = reduce(arr, 5);
    for(int i = 0; i < size; i++){
        cout << arr[i] << " ";
    }
    cout << endl;
    return 0;
}

int reduce(long arr[], int n)
{
    sort(arr, arr + n);     // 排序
    long *pt = unique(arr, arr + n);       // 去重, 返回超尾指针
    return pt - arr;
}
```

# 5.
```cpp
#include <iostream>
#include <algorithm>
#include <list>

using namespace std;

template <class T>
int reduce(T arr[], int n);

int main(void)
{
    long arr[5] = {200, 100, 300, 100, 200};

    int size = reduce(arr, 5);
    for(int i = 0; i < size; i++){
        cout << arr[i] << " ";
    }
    cout << endl;

    string str[5] = {"hello", "world", "good", "morning", "world"};
    size = reduce(str, 5);
    for(int i = 0; i < size; i++){
        cout << str[i] << " ";
    }
    cout << endl;
    return 0;
}

template <class T>
int reduce(T arr[], int n)
{
    list <T> ls;
    for (int i = 0; i < n; i++){
        ls.push_back(arr[i]);           // 元素放入链表
    }

    ls.sort();
    ls.unique();

    auto pt = ls.begin();               // 取出迭代器, 类型交给编译器判断
    for(int i = 0; i < ls.size(); i++, pt++){
        arr[i] = *pt;                   // 获取元素, 重新填充到 arr 中(覆盖写)
    }

    return ls.size();
}
```


# 6.
```cpp
#include <iostream>
#include <queue>
#include <cstdlib>

using namespace std;

class Customer
{
    private:
        long arrive;            // 开始操作ATM的时间(单位:秒)
        int processtime;        // 操作ATM机的总时间

    public:
        Customer(){arrive = processtime = 0; }
        void set(long when);                    // 设置开始操作ATM的时间
        long when() const {return arrive;}      // 用来查询开始操作ATM的时间
        int ptime() const{return processtime;}  // 用来查询操作ATM的总时间
};

typedef Customer Item;     // 用来统一改变链表节点的数据类型, 这里用自定义的类型作为链表节点数据类型

void Customer::set(long when)
{
    arrive = when;
    processtime = rand() % 3 + 1;       // 这里只是模拟, 所以真正的操作时间是个随机值(限制在3分钟以内).
}

int main(void)
{
    int qs;
    Item temp;      // 对应为 Customer 类的对象
    long i = 0;
    int customers = 0;

    cout << "Enter maximum size of queue: ";
    cin >> qs;

    // Queue line(qs);     // 初始化一个队列
    queue<Item> line;

    // 往队列填充内容
    while(line.size() != qs)  // while(!line.isFull())
    {
        temp.set(i++);        // 先使用i, 再对i增加
        line.push(temp);      // line.enqueue(temp);
        customers++;
    }
    cout << "Customers: " << customers << endl;

    // 出队列
    while(!line.empty())       // while(!line.isEmpty())
    {
        temp = line.front();   // 这里的front只是取元素, 没有删除, 所以还需要pop一下
        line.pop(); 
        customers--;
    }
    cout << "Now Customers: " << customers << endl;

    return 0;
}
```

# 7.

