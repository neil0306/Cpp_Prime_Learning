# string 類
C++11之前, stirng類就擁有下面前7個構造函數, 然後在C++11之後繼續引入了兩個, `一共9個`構造函數:
![](第十六章筆記_images/string類的構造函數.png)

代碼示例:
```cpp
#include <iostream>
#include <string>
using namespace std;

int main(void)
{
    string one("Lottery Winner.");      // 使用構造函數1: string(const char *s)
    cout << one << endl;

    string two(20, '$');                // 使用構造函數2: string(size_type n, char c)
    cout << two << endl;

    string three(one);
    cout << three << endl;              // 使用構造函數3: string(const string &str)

    one += " Oops!";                    // 加法運算符重載
    cout << one << endl;                // 調用 "<<" 重載函數, 在末尾追加字符串

    two = "Sorry, That was ";           // 調用賦值運算符, 重新賦值
    three[0] = 'P';                     // 替換第一個字符

    string four = two + three;          // 調用了構造函數4: string()
    cout << four << endl;

    char alla[] = "All's well that ends well.";
    string five(alla, 20);              // 調用了構造函數5: string(const char *s, size_type n).  注意: 數組名就是指針
    cout << five << endl;

    string six(alla + 6, alla + 10);    // 調用了構造函數6: template<class Iter> string (Iter begin, Iter end).   注意: 索引區間是 "左閉右開" 的
    cout << six << ", ";

    string seven(&five[6], &five[10]);  // 還是使用第六個構造函數, 本質上來說, 這個構造函數填入的參數都是地址
    cout << seven << "..." << endl;

    // 從 four 字符串的第7個字符開始, 往後面取16個字符出來, 賦值給 eight
    string eight(four, 7, 16);          // 構造函數7: string(const string &str, string size_type pos = 0, size_type n = npos)
    cout << eight << endl;

    // C++ 11新增的構造函數
    // 新增1: 移動構造函數 string(string && str) noexcept, 這個構造函數的效果類似於拷貝構造, 但是它的入參不是 const, 意味著輸入的參數 str 是可以修改的(這裡會把str幹掉)
        // 在 18章 再詳細討論

    // 新增2: string(initializer_list<char> il)
    // string piano_man = {'L', 'i', 's', 'z', 't'};   // 其實就是允許一個個字符拼一起來初始化一個字符串

    return 0;
}
```


## string 類輸入
1. cin >> string 對象
2. getline(cin, string 對象)

這裡的區別是:
- 在第一種方法中, cin 是對象, 使用的是cin裡的成員函數, 而getline 中, cin 是作為參數

string 對象能**自動根據輸入的字符數量調整大小**, 但它是有存儲上限的:
- 其上限由 `string::npos` 指定.
- string 存儲的上限也跟內存大小有關

代碼例子 -- 從文件中輸入字符串:
```cpp
#include <iostream>
#include <fstream>      // 在第十七章詳細講解
#include <string>
#include <cstdlib>      // 用到了 EXIT_FAILURE

using namespace std;

int main(void)
{
    ifstream fin;

    fin.open("abc.txt");

    if(fin.is_open() == false){
        cerr  << "Can't open flie. Bye. ";   // cerr 只能輸出到標準輸出設備上(cout則還可以輸出到比如文本等其他位置上)
        exit(EXIT_FAILURE);
    }

    string item;
    int count = 0;
    getline(fin, item, ':');        // 從fin中讀取內容, 讀取的內容放到 item 中, 但遇到指定的 ':' 字符時停止讀取(不包含指定的字符)
    while(fin){
        ++count;
        cout << count << ": " << item << endl;
        getline(fin, item, ':'); 
    }

    fin.close();
    return 0;
}
```



## string 類的常用成員函數
在書本的`覆綠F`中有關於 stirng 類的詳細描述, 可以用到的時候去查表. (中文版書的page 862頁)

### find 方法
代碼例子 -- 猜字遊戲
- 最多有6次猜錯的機會
- 猜錯有提示還有幾次機會, 猜對的字符顯示出對應的位置

```cpp
#include <iostream>
#include <string>
#include <cctype>   // 用到 tolower 就要引入
#include <ctime>    // 用來設置隨機數種子
#include <cstdlib>  // 用到 rand() 就要引入

using namespace std;

const int NUM = 26;
const string wordlist[NUM] = {
	"apiary", "beetle", "cereal", "danger", "ensign", "florid",
	"health", "insult", "jackal", "keeper", "loaner", "manage",
	"nonce",  "onset",  "plaid",  "quilt",  "remote", "stolid",
	"train",  "useful", "valid",  "whence", "xenon",  "yearn",
	"zippy"
};

int main(void)
{
    char play;

    srand(time(0));     // 設置隨機數種子

    cout << "Will you play a word game? <y/n> ";
    cin >> play;
    tolower(play);  // 為了方便判斷, 全部轉小寫

    while(play == 'y'){
        string target = wordlist[rand() % NUM];     // 0~25 中隨機選一個數
        int length = target.length();
        string attempt(length, '-');
        string badchars;    // 歷史猜錯的字符
        int guess = 6;      // 最多允許猜 6 次
        cout << "Guess my secret word, it has " << length << " length, and you guess one character at a time. You get " << guess << " wrong guesses." << endl;

        cout << attempt << endl;
        while(guess > 0 && attempt != target){
            char letter;
            cout << "Guess a letter: ";
            cin >> letter;

            // 檢查是否猜過
            if(badchars.find(letter) != string::npos || attempt.find(letter) != string::npos){      // 如果輸入的字符有出現在輸錯的記錄中, 或者 正確字符中曾經出現過
                cout << "You have already guessed that, try again!" << endl;
                continue;
            }

            // 沒出現過:
            int loc = target.find(letter);
            if(loc == string::npos){        // 當前猜的字符在target中找到末尾也沒有找到 ==> 猜錯了
                cout << "Oh, Bad Guess!" << endl;
                guess --;
                badchars += letter;
            }
            else{                           // 猜對的情況
                cout << "Good Guess!" << endl;
                attempt[loc] = letter;      // 這裡只替換了一個字符
                while(loc != string::npos){
                    attempt[loc] = letter;
                    loc = target.find(letter, loc +1);
                };
                
            }
            // 猜完一輪, 輸出當前猜測狀態
            cout << "Your word: " << attempt << endl;
            if(attempt != target){
                if(badchars.length() > 0){
                    cout << "Bad choices: " << badchars << endl;
                }
                cout << guess << " bad guess left!" << endl;
            }
        }
        // 判斷猜完之後是否正確
        if( guess > 0 || attempt == target){
            cout << "That's right!" << endl;
        }
        else{
            cout << "Sorry, the word is: " << target <<  endl;
        }

        cout << "Will you play another time? <y/n>" << endl;
        cin >> play;
        tolower(play);  // 為了方便判斷, 全部轉小寫
    }
    return 0;
}
```

### reserve方法 和 capacity方法
在拼接字符串時, 我們知道 string 會自動調整存儲的大小, 以便放入新的的內容, 但如果大量執行這樣的操作將非常耗時
- 不能僅僅將已有字符串加大, 因為相鄰的內存空間可能已經被使用過了, 此時多半要重新找一塊內存才能完成這個過程.
  - 為此, C++一般在第一次分配空間的時候會**分配一個比指定字符串更大一些的空間**, 但是當字符串繼續增大並超過第一次分配的空間時, 此時**重新分配空間的時候會直接分配原來字符空間兩倍大小的內存塊**, 以此減少分配次數.

- capacity 方法: `返回當前分配`的內存塊大小
- reserve 方法: 用來`指定`分配的內存塊大小

代碼例子 -- 測試 capacity 和 reserve 方法
```cpp
#include <iostream>
#include <string>

using namespace std;

int main(void)
{
    string empty;
    string small = "bit";
    string larger = "Elephants are a girl's best friends.";

    cout << "Sizes: " << endl;
    cout << "\t Empty: " << empty.size() << endl;
    cout << "\t Small: " << small.size() << endl;
    cout << "\t Larger: " << larger.size() << endl;

    cout << "Capacities: " << endl;
    cout << "\t Empty: " << empty.capacity() << endl;
    cout << "\t Small: " << small.capacity() << endl;
    cout << "\t Larger: " << larger.capacity() << endl;

    empty.reserve(50);
    cout << "Capacity after empty.reserve(50): " << empty.capacity() << endl;
    return 0;
}
```
輸出:
![](第十六章筆記_images/第十五章_string_capacity和reserve方法代碼例子_輸出.png)


