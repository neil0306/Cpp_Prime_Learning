# 友元類
類**並非只能擁有友元函數**, 也能擁有友元類, 對於友元類而言, 友元類的所有方法都`可以訪問原始類的私有成員和保護成員`.
- 友元這個概念本就是**為了訪問私有和保護的成員**, 因此友元類的目的也是一樣的.

- 使用友元類的場景:
  - 兩個類之間`不存在繼承關係`也`不存在包含關係`, 但是**想讓其中一個類訪問另一個類的私有成員或保護成員**, 此時就應該使用友元類的方式. 


代碼例子 -- 電視機和遙控器相互訪問
- `tv.h`
    ```cpp
    #ifndef __TV_H__
    #define __TV_H__

    #include <iostream>

    using namespace std;

    class Tv
    {
        private:
            enum {off, on};
            enum {MinVol = 0, MaxVol = 20};
            enum {MinChan = 1, MaxChan = 100};
            enum {TV, DVD};

            int state;      // 表示電視的狀態: 0打開, 1關閉
            int volume;     // 音量
            int channel;    // 頻道
            int input;      // 輸入方式: TV, DVD

        public:
            Tv(int s = off) : state(s), volume(5), channel(2), input(TV){}
            void onoff(){ state = (state == on ? off : on);}       // 切換電視開關
            bool volup();    // 音量增
            bool voldown();  // 音量減  
            void chanup();       // 頻道增
            void chandown();     // 頻道減
            void setInput() {input = (input == TV ? DVD : TV);}     // 修改輸入方式(信號源)
            void showSettings() const;

            friend class Remote;        // 友元類
    };


    // 遙控器類 應該成為 電視機類 的友元類, 因為從邏輯上講, 遙控器和電視機之間沒有繼承關係, 也不應該是包含關係
    class Remote
    {
        private:
            int mode;
        public:
            Remote(int m = Tv::TV) : mode(m){}     // 因為是友元關係, 允許使用另一個類的私有枚舉

            // 操作輸入的Tv類對象(遙控器控制某個電視)
            void onoff(Tv &t) {t.onoff();}; 
            bool volup(Tv &t){ return t.volup();}
            bool voldown(Tv &t){ return t.voldown();}
            void chanup(Tv &t){t.chanup();}
            void chandonw(Tv &t){t.chandown();}
            void setChannel(Tv &t, int c){t.channel = c;}   // 直接訪問了私有成員, 並賦值!
            void setInput(Tv &t) {t.setInput();}
    };

    #endif //!__TV_H__
    ```

- `tv.cpp`
    ```cpp
    #include "tv.h"

    bool Tv::volup()
    {
        if(volume < MaxVol){
            volume ++;
            return true;
        }
        else{
            return false;
        }
    }

    bool Tv::voldown()
    {
        if(volume > MinVol){
            volume ++;
            return true;
        }
        else{
            return false;
        }
    }

    void Tv::chanup()
    {
        if(channel < MaxChan){
            channel++;
        }
        else{
            channel = MinChan;        // 達到最大頻道時, 回到最小頻道即可
        }
    }

    void Tv::chandown()
    {
        if(channel > MinChan){
            channel --;
        }
        else{
            channel = MaxChan;        // 達到最小頻道時, 回到最大頻道即可
        }
    }

    void Tv::showSettings() const
    {
        cout << "TV is " << (state == off ? "off" : "on") << endl;
        if (state == on){
            cout << "Volume = " << volume << endl;
            cout << "Channel = " << channel << endl;
            cout << "Input = " << (input == TV ? "TV" : "DVD") << endl;
        }
    }
    ```


- `useTV.cpp`
    ```cpp
    #include <iostream>

    #include "tv.h"

    using namespace std;

    int main(void)
    {
        Tv Panda;
        cout << "Initial Settings for Panda TV: " << endl;
        Panda.showSettings();

        Panda.onoff();
        Panda.showSettings();

        cout << "---------" << endl;
        Panda.volup();
        Panda.chanup();
        Panda.showSettings();

        // 定義遙控器對象(友元類對象), 然後控制電視機
        Remote rt;
        cout << "---------" << endl;
        rt.setChannel(Panda, 88);
        rt.volup(Panda);
        rt.volup(Panda);
        Panda.showSettings();

        cout << "---------" << endl;
        rt.onoff(Panda);
        Panda.showSettings();
        return 0;
    }
    ```



## 嵌套類
在一個類中聲明(定義)另一個類就叫嵌套類.
- 類的包含: 在一個類的數據成員中有**另一個類的對象**, 就叫類的包含.
- 類嵌套只寫嵌套類的定義而**不創建這個嵌套類的對象**.

代碼例子 -- 修改隊列這個類
- 頭文件`queue.h`
    ```cpp
    /*
        嵌套類
    */
    #ifndef __QUEUE_H__
    #define __QUEUE_H__

    #include <iostream>
    using namespace std;

    // 一般作為 **容器** 的類型, 都是使用類模板來實現的
    template <class T>
    class Queue
    {
        private:
            enum{Q_SIZE = 10};      // 通过枚举来定义常量, 此时枚举类型是匿名的

            // struct Node{T item; Node *next;};  // 注意next指针是一个结构体指针
            // 現在把結構體換成一個類來實現 (嵌套類)
            class Node
            {
                public:     // 為了讓 Queue能直接訪問Node的數據, 這裡定義為public
                    T item;
                    Node * next;
                    Node(const T &t) : item(t), next(nullptr){}
            };

            Node *front;      // 头结点
            Node *rear;       // 尾结点
            int items;        // 记录队列中有多少个节点
            const int qsize;        // 队列最大长度(不希望被修改)

        public:
            Queue(int qs = Q_SIZE);
            ~Queue();
            bool isEmpty() const;
            bool isFull() const;
            int queueCount() const;
            bool enqueue(const T &item); // 入队列
            bool dequere(T &item);       // 出队列, 出队列的节点要赋值给 item, 所以不加const
    };

    template <class T>
    Queue<T>::Queue(int qs) : qsize(qs)        // 这是 "成员初始化列表" 的赋值方式, 专门用于 const 变量在构造过程中进行初始化
    {
        front = rear = nullptr; // 头,尾结点指针
        items = 0;      // 记录节点个数
    }

    // 当队列使用完之后, 如果仍有元素没有出队, 则需要靠析构函数进行内存释放
    template <class T>
    Queue<T>::~Queue()
    {
        while(front != nullptr){
            Node * temp = front;     // 1. 取出即将释放的节点
            front = front->next;     // 2. 移动链表头到下一个位置, 防止丢失链表
            delete temp;             // 3. 释放节点
        }
    }

    template <class T>
    bool Queue<T>::isEmpty() const
    {
        return items == 0;
    }

    template <class T>
    bool Queue<T>::isFull() const
    {
        return items == qsize; 
    }

    template <class T>
    int Queue<T>::queueCount() const
    {
        return items;
    }

    // 入队操作是在链表尾部增加节点
    template <class T>
    bool Queue<T>::enqueue(const T &item)
    {
        // 入队需要先判断是否为满
        if(isFull())
        {
            return false;
        }

        // 队列没有满的前提下才新增节点
        // Node *add = new Node;
        // add->item = item;       // 新节点的数据赋值
        // add->next = nullptr;    // 新增节点后面应该为空

        // 嵌套類的寫法:
        Node *add = new Node(item);   // 动态开辟新节点,  注意: 由於現在使用了嵌套類來實現, 所以這裡會觸發 Node 類的構造函數創建對象 (中文書 page454, 指針和類對象的小結)
        items++;

        if(front == nullptr){
            front = add;    // 如果一开始链表为空, 则直接把头结点设置为当前新增的节点
        }
        else{                   // 原链表本身不为空链表时, 只需要更新尾结点
            rear->next = add;   // 注意: 把原来链表的尾结点的next指向当前新增的节点, 没进行这个操作之前, rear的next节点是 nullptr
        }
        rear = add;             // 这个操作才是把原来的尾结点移动到新增节点上

        return true;
    }

    template <class T>
    bool Queue<T>::dequere(T &item)
    {
        if(isEmpty())
            return false;
        
        item = front->item;  // 队列是"先入先出", 故取头节点 (此处执行了一次拷贝)

        // 开始删节点, 更新头结点
        items--;             // 1. 更新链表数量
        Node *temp = front;  // 2. 保留原来的头结点, 用于释放内存
        front = front->next; // 3. 把当前的头结点移动到下一个位置
        delete temp;         // 4. 删除原来不要的节点

        // 更新尾结点
        if (items == 0){
            rear = nullptr;
        }

        return true;
    }

    #endif //!__QUEUE_H__
    ```


- 測試文件`nested.cpp`
    ```cpp
    #include <iostream>
    #include <string>
    #include "queue.h"

    using namespace std;

    int main(void)
    {
        Queue<string> cs(5);

        string temp;

        while(!cs.isFull())
        {
            cout << "Please enter client's name, then push to queue: " << endl;
            getline(cin, temp);
            cs.enqueue(temp);
        }

        cout << "The Queue is full, processing begin!" << endl;

        while(!cs.isEmpty())
        {
            cs.dequere(temp);
            cout << "Now processing: " << temp << endl;
        }

        return 0;
    }
    ```


