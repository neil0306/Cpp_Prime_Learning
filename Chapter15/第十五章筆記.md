# 友元類
類**並非只能擁有友元函數**, 也能擁有友元類, 對於友元類而言, 友元類的所有方法都`可以訪問原始類的私有成員和保護成員`.
- 友元這個概念本就是**為了訪問私有和保護的成員**, 因此友元類的目的也是一樣的.

- 使用友元類的場景:
  - 兩個類之間`不存在繼承關係`也`不存在包含關係`, 但是**想讓其中一個類訪問另一個類的私有成員或保護成員**, 此時就應該使用友元類的方式. 


代碼例子 -- 電視機和遙控器相互訪問
- `tv.h`
    ```cpp
    #ifndef __TV_H__
    #define __TV_H__

    #include <iostream>

    using namespace std;

    class Tv
    {
        private:
            enum {off, on};
            enum {MinVol = 0, MaxVol = 20};
            enum {MinChan = 1, MaxChan = 100};
            enum {TV, DVD};

            int state;      // 表示電視的狀態: 0打開, 1關閉
            int volume;     // 音量
            int channel;    // 頻道
            int input;      // 輸入方式: TV, DVD

        public:
            Tv(int s = off) : state(s), volume(5), channel(2), input(TV){}
            void onoff(){ state = (state == on ? off : on);}       // 切換電視開關
            bool volup();    // 音量增
            bool voldown();  // 音量減  
            void chanup();       // 頻道增
            void chandown();     // 頻道減
            void setInput() {input = (input == TV ? DVD : TV);}     // 修改輸入方式(信號源)
            void showSettings() const;

            friend class Remote;        // 友元類
    };


    // 遙控器類 應該成為 電視機類 的友元類, 因為從邏輯上講, 遙控器和電視機之間沒有繼承關係, 也不應該是包含關係
    class Remote
    {
        private:
            int mode;
        public:
            Remote(int m = Tv::TV) : mode(m){}     // 因為是友元關係, 允許使用另一個類的私有枚舉

            // 操作輸入的Tv類對象(遙控器控制某個電視)
            void onoff(Tv &t) {t.onoff();}; 
            bool volup(Tv &t){ return t.volup();}
            bool voldown(Tv &t){ return t.voldown();}
            void chanup(Tv &t){t.chanup();}
            void chandonw(Tv &t){t.chandown();}
            void setChannel(Tv &t, int c){t.channel = c;}   // 直接訪問了私有成員, 並賦值!
            void setInput(Tv &t) {t.setInput();}
    };

    #endif //!__TV_H__
    ```

- `tv.cpp`
    ```cpp
    #include "tv.h"

    bool Tv::volup()
    {
        if(volume < MaxVol){
            volume ++;
            return true;
        }
        else{
            return false;
        }
    }

    bool Tv::voldown()
    {
        if(volume > MinVol){
            volume ++;
            return true;
        }
        else{
            return false;
        }
    }

    void Tv::chanup()
    {
        if(channel < MaxChan){
            channel++;
        }
        else{
            channel = MinChan;        // 達到最大頻道時, 回到最小頻道即可
        }
    }

    void Tv::chandown()
    {
        if(channel > MinChan){
            channel --;
        }
        else{
            channel = MaxChan;        // 達到最小頻道時, 回到最大頻道即可
        }
    }

    void Tv::showSettings() const
    {
        cout << "TV is " << (state == off ? "off" : "on") << endl;
        if (state == on){
            cout << "Volume = " << volume << endl;
            cout << "Channel = " << channel << endl;
            cout << "Input = " << (input == TV ? "TV" : "DVD") << endl;
        }
    }
    ```


- `useTV.cpp`
    ```cpp
    #include <iostream>

    #include "tv.h"

    using namespace std;

    int main(void)
    {
        Tv Panda;
        cout << "Initial Settings for Panda TV: " << endl;
        Panda.showSettings();

        Panda.onoff();
        Panda.showSettings();

        cout << "---------" << endl;
        Panda.volup();
        Panda.chanup();
        Panda.showSettings();

        // 定義遙控器對象(友元類對象), 然後控制電視機
        Remote rt;
        cout << "---------" << endl;
        rt.setChannel(Panda, 88);
        rt.volup(Panda);
        rt.volup(Panda);
        Panda.showSettings();

        cout << "---------" << endl;
        rt.onoff(Panda);
        Panda.showSettings();
        return 0;
    }
    ```



## 嵌套類
在一個類中聲明(定義)另一個類就叫嵌套類.
- 類的包含: 在一個類的數據成員中有**另一個類的對象**, 就叫類的包含.
- 類嵌套只寫嵌套類的定義而**不創建這個嵌套類的對象**.

代碼例子 -- 修改隊列這個類
- 頭文件`queue.h`
    ```cpp
    /*
        嵌套類
    */
    #ifndef __QUEUE_H__
    #define __QUEUE_H__

    #include <iostream>
    using namespace std;

    // 一般作為 **容器** 的類型, 都是使用類模板來實現的
    template <class T>
    class Queue
    {
        private:
            enum{Q_SIZE = 10};      // 通过枚举来定义常量, 此时枚举类型是匿名的

            // struct Node{T item; Node *next;};  // 注意next指针是一个结构体指针
            // 現在把結構體換成一個類來實現 (嵌套類)
            class Node
            {
                public:     // 為了讓 Queue能直接訪問Node的數據, 這裡定義為public
                    T item;
                    Node * next;
                    Node(const T &t) : item(t), next(nullptr){}
            };

            Node *front;      // 头结点
            Node *rear;       // 尾结点
            int items;        // 记录队列中有多少个节点
            const int qsize;        // 队列最大长度(不希望被修改)

        public:
            Queue(int qs = Q_SIZE);
            ~Queue();
            bool isEmpty() const;
            bool isFull() const;
            int queueCount() const;
            bool enqueue(const T &item); // 入队列
            bool dequere(T &item);       // 出队列, 出队列的节点要赋值给 item, 所以不加const
    };

    template <class T>
    Queue<T>::Queue(int qs) : qsize(qs)        // 这是 "成员初始化列表" 的赋值方式, 专门用于 const 变量在构造过程中进行初始化
    {
        front = rear = nullptr; // 头,尾结点指针
        items = 0;      // 记录节点个数
    }

    // 当队列使用完之后, 如果仍有元素没有出队, 则需要靠析构函数进行内存释放
    template <class T>
    Queue<T>::~Queue()
    {
        while(front != nullptr){
            Node * temp = front;     // 1. 取出即将释放的节点
            front = front->next;     // 2. 移动链表头到下一个位置, 防止丢失链表
            delete temp;             // 3. 释放节点
        }
    }

    template <class T>
    bool Queue<T>::isEmpty() const
    {
        return items == 0;
    }

    template <class T>
    bool Queue<T>::isFull() const
    {
        return items == qsize; 
    }

    template <class T>
    int Queue<T>::queueCount() const
    {
        return items;
    }

    // 入队操作是在链表尾部增加节点
    template <class T>
    bool Queue<T>::enqueue(const T &item)
    {
        // 入队需要先判断是否为满
        if(isFull())
        {
            return false;
        }

        // 队列没有满的前提下才新增节点
        // Node *add = new Node;
        // add->item = item;       // 新节点的数据赋值
        // add->next = nullptr;    // 新增节点后面应该为空

        // 嵌套類的寫法:
        Node *add = new Node(item);   // 动态开辟新节点,  注意: 由於現在使用了嵌套類來實現, 所以這裡會觸發 Node 類的構造函數創建對象 (中文書 page454, 指針和類對象的小結)
        items++;

        if(front == nullptr){
            front = add;    // 如果一开始链表为空, 则直接把头结点设置为当前新增的节点
        }
        else{                   // 原链表本身不为空链表时, 只需要更新尾结点
            rear->next = add;   // 注意: 把原来链表的尾结点的next指向当前新增的节点, 没进行这个操作之前, rear的next节点是 nullptr
        }
        rear = add;             // 这个操作才是把原来的尾结点移动到新增节点上

        return true;
    }

    template <class T>
    bool Queue<T>::dequere(T &item)
    {
        if(isEmpty())
            return false;
        
        item = front->item;  // 队列是"先入先出", 故取头节点 (此处执行了一次拷贝)

        // 开始删节点, 更新头结点
        items--;             // 1. 更新链表数量
        Node *temp = front;  // 2. 保留原来的头结点, 用于释放内存
        front = front->next; // 3. 把当前的头结点移动到下一个位置
        delete temp;         // 4. 删除原来不要的节点

        // 更新尾结点
        if (items == 0){
            rear = nullptr;
        }

        return true;
    }

    #endif //!__QUEUE_H__
    ```


- 測試文件`nested.cpp`
    ```cpp
    #include <iostream>
    #include <string>
    #include "queue.h"

    using namespace std;

    int main(void)
    {
        Queue<string> cs(5);

        string temp;

        while(!cs.isFull())
        {
            cout << "Please enter client's name, then push to queue: " << endl;
            getline(cin, temp);
            cs.enqueue(temp);
        }

        cout << "The Queue is full, processing begin!" << endl;

        while(!cs.isEmpty())
        {
            cs.dequere(temp);
            cout << "Now processing: " << temp << endl;
        }

        return 0;
    }
    ```




# 異常 (運行時)
C++的異常機制一般分為以下3步:
1. 引發異常
2. 使用處理程序捕獲異常
3. 使用try模塊

- 引發異常的常用方式:
  - `throw` 關鍵字
    - throw 會**終止當前函數, 但是整個程序還不會終止, 它只是跳轉會調用函數的位置**!!
    - throw 後面可以接`字符串`或者`合法的C++類型(包含自定義的類型)`

- 使用處理程序捕獲異常的方法(遇到異常馬上終止程序): 
  - `abort();` 需要使用 `#include <cstdlib>`
    - abort會**直接終止程序**!!
  - 使用`catch`捕獲異常
    - 通常需要搭配`引發異常`來使用, 一般在使用`throw`引發異常後添加catch來捕獲拋出來的異常.

- 使用try模塊
  - 使用 try 模塊將可能存在異常的代碼塊包起來執行(throw需要包含在這裡面)
  - 注意: **如果存在異常的代碼不在try裡面, 則catch是無法捕捉到的**!!

如果函數引發了異常, 但是`沒有 try 塊` 或者 `沒有匹配的處理程序` 時, **默認情況下編譯器將使用** `abort()` **函數直接終止程序**.
- 但是這種行為也是可以修改的 (後面的筆記討論).


**運行階段**暫時忽略異常的方法:
- 返回一個錯誤狀態/某個代表錯誤的值


## 代碼例子 -- 調和平均數
- 異常情況是 **除靈**.

異常的處理方式1 -- **使用abort()**, 遇到錯誤時直接終止程序
```cpp
#include <iostream>
#include <cstdlib>

using namespace std;

double hmean(double a, double b);

int main(void)
{
    double x, y, z;

    cout << "Enter two numbers: ";
    while(cin >> x >> y )
    {
        z = hmean(x,y);
        cout << "Harmonic mean of " << x << " and " << y << " is " << z << endl;
        cout << "Enter next set of numbers: ";
    }

    return 0;
}

double hmean(double a, double b)
{
    // 如果 a b 互為相反數就會出問題, 這裡採用直接終止程序的方式
    if(a == -b){
        cout << "Invalid arguments to hmean()" << endl;
        abort();        // 加了這個函數之後, 如果運行時進入這個代碼段, 程序就會直接終止
    }
    return 2.0 * a * b / (a + b);
}
```

異常的處理方式2: 不終止程序, 使用**函數返回值**判斷程序運行是否異常
```cpp
#include <iostream>
#include <cstdlib>

using namespace std;

bool hmean(double a, double b, double *ans);

int main(void)
{
    double x, y, z;

    cout << "Enter two numbers: ";
    while(cin >> x >> y )
    {
        if(hmean(x, y, &z)){
            cout << "Harmonic mean of " << x << " and " << y << " is " << z << endl;
        }
        else{
            cout << "One value should not be the negative of the other, try again!" << endl;
        }
        cout << "Enter next set of numbers: ";
    }

    return 0;
}

bool hmean(double a, double b, double *ans)
{
    // 如果 a b 互為相反數就會出問題, 這裡讓函數 返回錯誤碼
    if(a == -b){
        return false;
    }
    else{
        *ans = 2.0 * a * b / (a + b);
        return true;
    }
}
```

代碼例子 -- 走一遍異常機制
1. 使用 **throw 關鍵字引發異常**
2. 使用 **catch 捕獲throw拋出的異常**
3. 使用 **try 模塊**

出現異常時的運行流程:
![](第十五章筆記_images/第十五章_hmean代碼例子_出現異常時的運行流程.png)

    ```cpp
    #include <iostream>
    #include <cstdlib>

    using namespace std;

    double hmean(double a, double b);

    int main(void)
    {
        double x, y, z;

        cout << "Enter two numbers: ";
        while(cin >> x >> y )
        {
            // step 3: 使用 try 模塊包住可能有異常的代碼 (throw語句包含在這裡面)
            try{
                // 容易出現異常的代碼通常放在 try 裡的代碼塊
                z = hmean(x,y);
            }
            // step 2: 利用處理程序捕獲異常
            // 在 hmean 中已經使用了 throw 引發異常, 這裡接著使用 catch 捕獲這個異常
            catch(const char *s)       // 處理字符串的異常, 此時 s 中存放的是 throw 拋出來的字符串賦值
            {
                cout << s << endl;
                cout << "Enter a new pair of arguments." << endl;
                continue;
            }

            cout << "Harmonic mean of " << x << " and " << y << " is " << z << endl;
            cout << "Enter next set of numbers: ";
        }

        return 0;
    }

    double hmean(double a, double b)
    {
        // 如果 a b 互為相反數就會出問題, 這裡使用 throw 引發異常, 並且是 "字符串類型的異常(const char *)"
        if(a == -b){
            // step 1: 在可能引發異常的代碼中增加 throw 語句以拋出異常
            throw "Bad hmean() arguments, a=-b is not allowed!";        // throw 後可以加字符串 或者 C++的類型(包括類類型), 它會終止函數的運行(程序還會繼續走)
        }
        return 2.0 * a * b / (a + b);
    }
    ```




