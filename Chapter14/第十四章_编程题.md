# 题目
![](第十四章_编程题_images/第十四章编程题_1_1.png)
![](第十四章_编程题_images/第十四章编程题_1_2.png)
![](第十四章_编程题_images/第十四章编程题_2-4.png)
![](第十四章_编程题_images/第十四章编程题_5_1.png)
![](第十四章_编程题_images/第十四章编程题_5_2.png)
![](第十四章_编程题_images/第十四章编程题_5_3.png)

# 1.
头文件`winec.h`
```cpp
#ifndef __WINEC_H__
#define __WINEC_H__

#include <iostream>
#include <string>
#include <valarray>

using namespace std;

template <class T1, class T2> class Pair;       // 声明一下, 为了让 typedef 能识别 Pair
typedef valarray<int> ArrInt;
typedef Pair< ArrInt, ArrInt > PairArray;

// Pair模板类
template <class T1, class T2>
class Pair
{
    private:
        T1 a;
        T2 b;
    public:
        Pair(const T1 &aval, const T2 &bval) : a(aval), b(bval){}
        T1 & first();
        T2 & second();
        T1 first() const{return a;}
        T2 second() const{return b;}
};

template <class T1, class T2>
T1 & Pair<T1, T2>::first()
{
    return a;
}

template <class T1, class T2>
T2 & Pair<T1, T2>::second()
{
    return b;
}

// 酒 类
class Wine
{
    private:
        string label;
        // Pair<valarray<int>, valarray<int> > info;   // 第一个数组存放年份, 第二个是酒的数量
        // Pair< ArrInt, ArrInt > info;      
        PairArray info;                                 // 用 typedef 简化名字
        int year;
    public:
        Wine(const char *l, int y, const int yr[], const int bot[]);
        Wine(const char *l, int y);
        void GetBottles();      // 用于录入信息
        const string & Label() const;
        int sum() const;
        void Show() const;
};

#endif //!__WINEC_H__
```

源文件`winec.cpp`
```cpp
#include "winec.h"

/*
    在成员初始化列表中, 我们使用 valarray 的构造函数来完成类型转换:
        valarray<类型> 变量名字(数组名, 数组元素个数)
        valarray<类型> 变量名字(数组元素初始化的默认值, 数组元素个数)

        在代码中, 我们使用了typdef改名, 所以下面的 ArrInt(yr, y) 就是在使用 valarray 的构造函数
*/
Wine::Wine(const char *l, int y, const int yr[], const int bot[]) : label(l), year(y), info(ArrInt(yr, y), ArrInt(bot, y))
{
}

Wine::Wine(const char *l, int y) : label(l), year(y), info(ArrInt(0, 0), ArrInt(0, 0))      // ArrInt(0, 0) 表示数组中所有元素都是初始化为0, 然后数组内部设置为没有元素
{
}

void Wine::GetBottles()
{
    cout << "Enter " << label << " data for " << year << endl;
    for (int i = 0; i < year; i++){
        cout << "Enter year: ";
        cin >> info.first()[i];
        cout << "Enter bottles for that year: ";
        cin >> info.second()[i];
    }
}

const string & Wine::Label() const
{
    return label;
}

int Wine::sum() const
{
    return info.second().sum();     // 使用 valarray<int> 类型提供的sum方法
}

void Wine::Show() const
{
    cout << "Wine: " << label << endl;
    cout << "\t\t" << "Year\t\tBottles" << endl;
    for (int i = 0; i < year; i++){
        cout << "\t\t" << info.first()[i] << "\t\t" << info.second()[i] << endl;
    }
}
```

测试文件`p1.cpp`
```cpp
#include <iostream>
#include "winec.h"

using namespace std;

int main(void)
{
	cout << "Enter name of wine: ";
	char lab[50];
	cin.getline(lab, 50);
	cout << "Enter number of years: ";
	int yrs;
	cin >> yrs;

	Wine holding(lab, yrs);
	holding.GetBottles();
	holding.Show();

	const int YRS = 3;
	int y[YRS] = {1993, 1995, 1998};
	int b[YRS] = {48, 60, 72};

	Wine more("Gushing Grape Red", YRS, y, b);
	more.Show();

	cout << "Total bottles for " << more.Label()
        << ": " << more.sum() << endl;

	cout << "Bye\n";

	return 0;
}
```

# 2.
- 头文件`winec.h`
```cpp
#ifndef __WINEC_H__
#define __WINEC_H__

#include <iostream>
#include <string>
#include <valarray>

using namespace std;

template <class T1, class T2> class Pair;       // 声明一下, 为了让 typedef 能识别 Pair
typedef valarray<int> ArrInt;
typedef Pair< ArrInt, ArrInt > PairArray;

// Pair模板类
template <class T1, class T2>
class Pair
{
    private:
        T1 a;
        T2 b;
    public:
        Pair(const T1 &aval, const T2 &bval) : a(aval), b(bval){}
        T1 & first();
        T2 & second();
        T1 first() const{return a;}
        T2 second() const{return b;}
};

template <class T1, class T2>
T1 & Pair<T1, T2>::first()
{
    return a;
}

template <class T1, class T2>
T2 & Pair<T1, T2>::second()
{
    return b;
}

// 酒 类
class Wine : private string, private PairArray
{
    private:
        // string label;            // 私有继承之后, 将自动获得一个匿名的 string 对象, 因此这里可以不写label了
        // PairArray info;          // 同理, 可以不写info了, 它是一个匿名的 PairArray 对象
        int year;
    public:
        Wine(const char *l, int y, const int yr[], const int bot[]);
        Wine(const char *l, int y);
        void GetBottles();      // 用于录入信息
        const string & Label() const;
        int sum() const;
        void Show() const;
};

#endif //!__WINEC_H__
```

- 源文件`winec.cpp`
```cpp
#include "winec.h"

/*
    在成员初始化列表中, 我们使用 valarray 的构造函数来完成类型转换:
        valarray<类型> 变量名字(数组名, 数组元素个数)
        valarray<类型> 变量名字(数组元素初始化的默认值, 数组元素个数)

        在代码中, 我们使用了私有继承, 所以这里就需要使用类名(而不是成员名)来获得基类的对象
*/
Wine::Wine(const char *l, int y, const int yr[], const int bot[]) : string(l), year(y), PairArray(ArrInt(yr, y), ArrInt(bot, y))
{
}

Wine::Wine(const char *l, int y) : string(l), year(y), PairArray(ArrInt(0, y), ArrInt(0, y))      // ArrInt(0, 0) 表示数组中所有元素都是初始化为0, 然后数组内部设置为没有元素
{
}

void Wine::GetBottles()
{
    cout << "Enter " << (const string &)*this << " data for " << year << endl;      // 用(const string &)*this 替代了 label, 通过强制类型转换可以获得基类的匿名对象
    for (int i = 0; i < year; i++){
        cout << "Enter year: ";
        cin >> PairArray::first()[i];       // 通过类名 + 作用域解析运算符 来调用基类的方法
        cout << "Enter bottles for that year: ";
        cin >> PairArray::second()[i];
    }
}

const string & Wine::Label() const
{
    return (const string &)*this;
}

int Wine::sum() const
{
    return PairArray::second().sum();     // // 通过类名 + 作用域解析运算符 来调用基类的方法, 并且使用 valarray<int> 类型提供的sum方法
}

void Wine::Show() const
{
    cout << "Wine: " << (const string &) *this << endl;         // 用(const string &)*this 替代了 label, 通过强制类型转换可以获得基类的匿名对象
    cout << "\t\t" << "Year\t\tBottles" << endl;
    for (int i = 0; i < year; i++){
        cout << "\t\t" << PairArray::first()[i] << "\t\t" << PairArray::second()[i] << endl;  // 通过类名 + 作用域解析运算符 来调用基类的方法
    }
}
```

- 测试文件`p2.cpp`
```cpp
#include <iostream>
#include "winec.h"

using namespace std;

int main(void)
{
	cout << "Enter name of wine: ";
	char lab[50];
	cin.getline(lab, 50);
	cout << "Enter number of years: ";
	int yrs;
	cin >> yrs;

	Wine holding(lab, yrs);
	holding.GetBottles();
	holding.Show();

	const int YRS = 3;
	int y[YRS] = {1993, 1995, 1998};
	int b[YRS] = {48, 60, 72};

	Wine more("Gushing Grape Red", YRS, y, b);
	more.Show();

	cout << "Total bottles for " << more.Label()
        << ": " << more.sum() << endl;

	cout << "Bye\n";

	return 0;
}
```


# 3.
任务: 
1. 创建队列模板类
2. 队列里面存放**Worker类的对象的指针**

- 头文件`queue.h`
```cpp
#ifndef __QUEUE_H__
#define __QUEUE_H__

#include <iostream>
#include <string>

using namespace std;

class Worker
{
    private:
        string fullname;
        long id;
    public:
        Worker() : fullname("none one"), id(0){}
        Worker(const string &s, long n) : fullname(s), id(n){}
        ~Worker(){}
        void Set();
        void Show() const;
};

template <typename T>
class Queue
{
    private:
        enum{Q_SIZE = 10};      // 通过枚举来定义常量, 此时枚举类型是匿名的
        struct Node{T item; Node *next;};  // 注意next指针是一个结构体指针
        Node *front;      // 头结点
        Node *rear;       // 尾结点
        int items;        // 记录队列中有多少个节点
        const int qsize;        // 队列最大长度(不希望被修改)

    public:
        Queue(int qs = Q_SIZE);
        ~Queue();
        bool isEmpty() const;
        bool isFull() const;
        int queueCount() const;
        bool enqueue(const T &item); // 入队列
        bool dequere(T &item);       // 出队列, 出队列的节点要赋值给 item, 所以不加const

};

template<class T>
Queue<T>::Queue(int qs) : qsize(qs)        // 这是 "成员初始化列表" 的赋值方式, 专门用于 const 变量在构造过程中进行初始化
{
    front = rear = nullptr; // 头,尾结点指针
    items = 0;      // 记录节点个数
}

// 当队列使用完之后, 如果仍有元素没有出队, 则需要靠析构函数进行内存释放
template<class T>
Queue<T>::~Queue()
{
    while(front != nullptr){
        Node * temp = front;     // 1. 取出即将释放的节点
        front = front->next;     // 2. 移动链表头到下一个位置, 防止丢失链表
        delete temp;             // 3. 释放节点
    }
}

template<class T>
bool Queue<T>::isEmpty() const
{
    return items == 0;
}

template<class T>
bool Queue<T>::isFull() const
{
    return items == qsize; 
}

template<class T>
int Queue<T>::queueCount() const
{
    return items;
}

// 入队操作是在链表尾部增加节点
template<class T>
bool Queue<T>::enqueue(const T &item)
{
    // 入队需要先判断是否为满
    if(isFull())
    {
        return false;
    }

    // 队列没有满的前提下才新增节点
    Node *add = new Node;   // 动态开辟新节点
    add->item = item;       // 新节点的数据赋值
    add->next = nullptr;    // 新增节点后面应该为空
    items++;

    if(front == nullptr){
        front = add;    // 如果一开始链表为空, 则直接把头结点设置为当前新增的节点
    }
    else{                   // 原链表本身不为空链表时, 只需要更新尾结点
        rear->next = add;   // 注意: 把原来链表的尾结点的next指向当前新增的节点, 没进行这个操作之前, rear的next节点是 nullptr
    }
    rear = add;             // 这个操作才是把原来的尾结点移动到新增节点上

    return true;
}

template<class T>
bool Queue<T>::dequere(T &item)
{
    if(isEmpty())
        return false;
    
    item = front->item;  // 队列是"先入先出", 故取头节点 (此处执行了一次拷贝)

    // 开始删节点, 更新头结点
    items--;             // 1. 更新链表数量
    Node *temp = front;  // 2. 保留原来的头结点, 用于释放内存
    front = front->next; // 3. 把当前的头结点移动到下一个位置
    delete temp;         // 4. 删除原来不要的节点

    // 更新尾结点
    if (items == 0){
        rear = nullptr;
    }

    return true;
}

#endif //!__QUEUE_H__
```

- 源文件`worker.cpp`
```cpp
#include "queue.h"

void Worker::Set()
{
    cout << "Enter worker's full name: " ;
    getline(cin, fullname);
    cout << "Enter worker's ID: ";
    cin >> id;
    while(cin.get()!= '\n');        // 但凡字符串和数字交替输入, 就要写这个语句, 清掉缓冲区的回车
}

void Worker::Show() const
{
    cout << "Name: " << fullname << endl;
    cout << "Employee ID: " << id << endl;
}
```

- 测试文件`p3.cpp`
```cpp
#include <iostream>

#include "queue.h"

using namespace std;

int main(void)
{
    Queue<Worker *> wk(3);         // 队列里存放的是 Worker 类对象的指针

    Worker w1;
    w1.Set();
    w1.Show();
    wk.enqueue(&w1);                // 把Worker类对象的地址入队列

    cout << "Now Queue has: " << wk.queueCount() << " items" << endl;   // 显式当前队列中有多少元素

    Worker w2;
    w1.Set();
    w1.Show();
    wk.enqueue(&w2);                // 把Worker类对象的地址入队列
    cout << "Now Queue has: " << wk.queueCount() << " items" << endl;   // 显式当前队列中有多少元素

    Worker w3;
    w1.Set();
    w1.Show();
    wk.enqueue(&w3);                // 把Worker类对象的地址入队列
    cout << "Now Queue has: " << wk.queueCount() << " items" << endl;   // 显式当前队列中有多少元素

    return 0;
}
```

