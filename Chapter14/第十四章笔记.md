# C++ 代码重用

## 包含对象成员的类
设计类时, 类的数据成员是`其他类的对象`.
### valarraly 模板类
可以把它理解为一个数组模板. 使用时需要包含头文件`valarray`, 即:
```
#include <valarray>
```

- 可以创建长度为零的空数组
  - `valarray<int> a;`
- 也可以创建指定长度的数组
  - `valaaray<int> v1 = {20, 30, 40, 50};`, 使用**初始化列表**的方式创建数组
  - `valarray<int> a(10);`, 创建一个数组, 一共有10个元素, 但是元素都没有初始化
  - `valarray<int> a(10, 8);`, 创建一个数组, 一共有8个元素, 每个元素的数值都是10
- 创建数组时, 还可以把**常规数组**作为参数, 用来初始化新数组
  ```cpp
    double gpa = {3.1, 3.5, 3.8, 2.9, 3.3};
    valarray<double> v1(gpa, 4);
    /*
        v1 数组只能容纳4个元素, 此时会将 gpa 数组的前四个元素复制到 v1 数组中
    */
  ```

### has-a 关系
如果一个类包含另一个类的对象, 就称为**has-a**关系. 例如:
```cpp
#include <string>
#include <valarray>

using namespace std;

class Student
{
    private:
        string name;                // 包含了string类型的对象, 此时 类型Student 和 string 之间是 has-a 关系.
        valarray<double> scores;    // 此时 类型Student 和 valarray 之间是 has-a 关系.
};
```
- has-a 关系有个特性, 这个student类包含了 string类 和 valarray类 的成员对象的实现, 但**没有继承这两个类的接口**. 
  - 此时, Student里面的 name 和 scores 这两个对象可以分别调用它们本身所属的类的方法.
  - 这说明 Student 类里面**间接地**获得了 string类 和 valarray类 的方法的使用权限, 虽然使用时需要用 name 和 scores 这两个对象.
    ![](第十四章笔记_images/对象中的对象_包含.png)


代码例子:
- `studentc.h`
```cpp
#ifndef __STUDENTC_H__
#define __STUDENTC_H__

#include <iostream>
#include <string>
#include <valarray>

using namespace std;

class Student
{
    private:
        typedef valarray<double> ArrayDb;       // 使用别名, 方便简写, 此时只能在类内部使用这个别名
        string name;
        ArrayDb scores;         // 等价于 valarray<double> scores;
    public:
        Student() : name("Null Student"), scores(){}

        // 转换函数(同时也是构造函数): string类型 转换为 Student类型
        explicit Student(const string &s) : name(s), scores(){}      // 注意是显式转换(此时不允许隐式转换), 加了关键字 explicit
        explicit Student(int n) : name("Nully"), scores(n){}         // 这里也是不允许隐式转换
        
        Student(const string &s, int n) : name(s), scores(n){}
        Student(const string &s, const ArrayDb &a ) : name(s), scores(a){}      // score 部分对应的是 valarray(valarray对象) 的使用方式
        Student(const string &s, const double *pd, int n) : name(s), scores(pd, n){}  // score 部分对应的是 valarray(double数组, 数组长度) 的使用方式

        ~Student(){}

        double Average() const;
        const string & Name() const;
        double & operator[](int n);   // 注意返回的是引用类型, 返回的是"左值"(可写/修改), 此时才可以写成 stu[0] = 100, 此时的 stu[0] 是可读可写的
        double operator[](int n) const;  // 如果把返回值写"非引用"的形式, 那么调用[]运算符得到的对象是"右值", 它是"只读"的, 合法的使用只能是 a = stu[0], 因为 stu[0] 是右值(只读, 不可修改)

        friend istream & operator>>(istream &is, Student &stu); // 用于捕获输入时中间有空格的情况
        friend istream & getline(istream &is, Student &stu);    // 重载捕获一整行的输入情况
        friend ostream & operator<<(ostream &os, const Student &stu);
};

#endif //!__STUDENTC_H__
```

- `studentc.cpp`
```cpp
#include "studentc.h"

double Student::Average() const
{
    if (scores.size() > 0){
        return scores.sum() / scores.size();
    }
    else{
        return 0.0;
    }
}

const string &Student::Name() const
{
    return name;
}

// 这个函数返回的是可操作的左值
double & Student::operator[](int n)     // 注意返回的是引用
{
    return scores[n];
}

// 这个函数返回的是"不可写"的右值
double Student::operator[](int n) const // 按值返回, 不是引用
{
    return scores[n];
}

istream & operator>>(istream &is, Student &stu)
{
    is >> stu.name;
    return is;
}

istream & getline(istream &is, Student &stu)        // 重载了getline函数
{
    getline(is, stu.name);          // 这里调用的是原生的 getline 函数, 对应的函数声明是 getline(istream &, string &)
    return is;
}

ostream & operator<<(ostream &os, const Student &stu)
{
    os << "Scores for " << stu.name << ": " << endl;

    int limit = stu.scores.size();  // 获取科目的数量
    if (limit > 0)
    {
        int i = 0;
        for (i = 0; i < limit; i++){
            os << stu.scores[i] << " ";

            // 每显示5门成绩就换行
            if (i % 5 == 4){        // 因为索引从0开始, 所以当余数为4时, 说明当前刚好显示了5门成绩
                os << endl;
            }
        }

        // 如果课程数量不是5的整数倍, 则需要额外换行一次
        if (i % 5 != 0){
            os << endl;
        }
    }
    else{
        os << "Empty array!" << endl;
    }
    return os;
}
```

- `useStudentc.cpp`
```cpp
#include <iostream>
#include "studentc.h"

using namespace std;

const int pupils = 3;
const int quizzes =5;

void set(Student &sa, int n);

int main(void)
{
    Student ada[pupils] = {Student(quizzes), Student(quizzes), Student(quizzes)};
    int i = 0;;

    // 录入信息
    for (i = 0; i < pupils; i++){
        set(ada[i], quizzes);       // 这里的 ada[i] 访问的是 "不同的Student对象"
    }
    cout << " -------- " << endl;

    // 输出
    cout << "Student List: " << endl;
    for (i = 0; i < pupils; i++){
        cout << ada[i].Name() << endl;
    }
    cout << " -------- " << endl;

    cout << "Result List: " << endl;
    for (i = 0; i < pupils; i++){
        cout << ada[i];             // 使用友元函数 operator<<()
        cout << "Average: " << ada[i].Average() << endl;
    }

    return 0;
}

void set(Student &sa, int n)
{
    cout << "Please enter the student's name: " << endl;
    getline(cin, sa);
    cout << "Please enter " << n << " quizzes scores: " << endl;
    for (int i = 0; i < n; i++){
        cin >> sa[i];           // 这里的 sa[i] 访问的是 Student对象里的[]重载运算符, 填充的是对象里面的 scores 数组
    }

    // 每当输入数字之后, 缓冲区都会存在一个多余的回车, 记得干掉.
    while(cin.get() != '\n');
}
```

## 私有继承
回顾公有继承:
- 基类的所有 public 方法都自动变成派生类的 public 方法
- 基类的 public 成员自动变成派生类的 public 成员 (虽然这种case非常少见, 数据基本都是private)

对于`私有继承`来说:
在声明派生类时, 如果使用关键词`private`来继承基类, 此时就是私有继承.
- 此时的基类称为`私有基类`, 派生类称为`私有派生类`

私有继承的特点:
- 基类的所有 **public** 方法都会变成 派生类的 **private** 方法.
  - 基类中本来属于 private 的部分仍旧只能使用**基类的public接口进行访问**, 派生类依然不能直接访问它们.
- 基类中的**public 成员**和**protected 成员** 会变成派生类的 **private成员**
  - 此时**派生类的成员函数可以访问它们**, 但是在派生类之外不能访问, 即使是派生类的对象也不能直接访问(这与前面讲过的类的基本知识一致)
    - 注意: **友元函数不属于类的成员函数**, 因此友元函数并不属于派生类的**内部**, 故`友元函数不能直接使用私有基类的方法`!! 但可以想办法通过`强制类型转换`的方式将派生类转成基类, 然后间接地进行访问.
- 私有派生类将**继承私有基类的实现**.
  - 比如说: Student 是 string 的 私有派生类 (这时候string就是私有基类了), 此时, Student将包含一个**string的对象**(也被称为string的实现/string类组件), 也就是说, 在Student类里面起码会自带一个string对象可以存储数据, 只不过这个对象是`无名对象`, 这种对象需要通过基类的方法才能访问.
    - 这个无名对象也可以理解为像 this指针 那样的隐式对象成员.





代码例子 -- 用私有继承的方式重写前面的 Student类:
- 区别有:
  - 使用了多重继承(multiple inheritance, MI), 同时继承了 string 和 valarray<double> 类, 而且是私有继承
  - 由于是私有继承, Student会分别从 string 和 valarray<double> 中各继承到一个`无名对象`, 因此 Student类中不再包含数据成员 name 和 scores
    - 由于没有存储数据的成员名字, 所以在构造函数中初始化继承过来的无名对象时, 需要直接使用 **基类的构造函数** 来完成无名对象的初始化.
    - 在调用string 和 valarray<double> 里面的公有方法时, 由于没有了对象的名字, 这里直接使用`类名::方法名()`就相当于是通过对象来调用了相应的方法.
    - string, valarray 和 Student 之间是继承关系, 因此为了获得继承而来的隐式对象, 我们可以通过`强制类型转换的方式`来完成.
      - 将当前对象转换为基类对象: `(string &)*this;`, `(valarray<double> &)*this;`
      - 将Student类的对象转换为基类对象: `(string &)stu;`, `(valarray<double> &)stu;`
  - 新增函数 `arr_out`, 因为友元函数无法访问私有基类的方法, 所以把这部分代码搬到私有派生类的 arr_out 函数中, 此时友元函数借助派生类的函数去间接访问私有基类的方法即可.


- 修改后的`studentc.h`
```cpp
#ifndef __STUDENTC_H__
#define __STUDENTC_H__

#include <iostream>
#include <string>
#include <valarray>

using namespace std;

class Student : private string, private valarray<double>    // 私有继承了两个类 (多重继承, multiple inheritance, MI)
{
    private:
        typedef valarray<double> ArrayDb;       // 使用别名, 方便简写, 此时只能在类内部使用这个别名
        ostream & arr_out(ostream &os) const;      // 用来替代非私有继承时写过的输出运算符重载函数

    public:
        Student() : string("Null Student"), ArrayDb(){}

        // 转换函数(同时也是构造函数): string类型 转换为 Student类型
        explicit Student(const string &s) : string(s), ArrayDb(){}      // 注意是显式转换(此时不允许隐式转换), 加了关键字 explicit
        explicit Student(int n) : string("Nully"), ArrayDb(n){}         // 这里也是不允许隐式转换
        
        Student(const string &s, int n) : string(s), ArrayDb(n){}
        Student(const string &s, const ArrayDb &a ) : string(s), ArrayDb(a){}      // score 部分对应的是 valarray(valarray对象) 的使用方式
        Student(const string &s, const double *pd, int n) : string(s), ArrayDb(pd, n){}  // score 部分对应的是 valarray(double数组, 数组长度) 的使用方式

        ~Student(){}

        double Average() const;
        const string & Name() const;
        double & operator[](int n);   // 注意返回的是引用类型, 返回的是"左值"(可写/修改), 此时才可以写成 stu[0] = 100, 此时的 stu[0] 是可读可写的
        double operator[](int n) const;  // 如果把返回值写"非引用"的形式, 那么调用[]运算符得到的对象是"右值", 它是"只读"的, 合法的使用只能是 a = stu[0], 因为 stu[0] 是右值(只读, 不可修改)

        friend istream & operator>>(istream &is, Student &stu); // 用于捕获输入时中间有空格的情况
        friend istream & getline(istream &is, Student &stu);    // 重载捕获一整行的输入情况
        friend ostream & operator<<(ostream &os, const Student &stu);
};

#endif //!__STUDENTC_H__
```

- 修改后的`studentc.cpp`

```cpp
#include "studentc.h"

double Student::Average() const
{
    // if (scores.size() > 0){
    //     return scores.sum() / scores.size();
    // }
    // else{
    //     return 0.0;
    // }

    if (ArrayDb::size() > 0){
        return ArrayDb::sum() / ArrayDb::size();
    }
    else{
        return 0.0;
    }
}

const string & Student::Name() const
{
    return (const string &)(*this);     // 通过强制类型转换的方式获得从string继承而来的隐式对象
}

// 这个函数返回的是可操作的左值
double & Student::operator[](int n)     // 注意返回的是引用
{
    return ArrayDb::operator[](n);      // scores[n] 本质上就是在调用基类重载的运算符[], 因此这里直接使用 "类名::" 的方式替换
}

// 这个函数返回的是"不可写"的右值
double Student::operator[](int n) const // 按值返回, 不是引用
{
    return ArrayDb::operator[](n);      // 理由同上
}

// 友元函数 (注意它不属于成员函数, 不能直接使用私有基类的方法!)
istream & operator>>(istream &is, Student &stu)
{
    is >> (string &)stu;                // 强制类型转换之后, 得到的string类型的引用本质上等价于 此前的 name 成员
    return is;
}

istream & getline(istream &is, Student &stu)        // 重载了getline函数
{
    getline(is, (string &)stu);          // 这里调用的是原生的 getline 函数, 对应的函数声明是 getline(istream &, string &)
    return is;
}

// 友元函数
ostream & operator<<(ostream &os, const Student &stu)
{
    os << "Scores for " << (const string &)stu << ": " << endl;

    // 原来写在这里的代码由于不能访问私有基类的方法, 所以把这部分代码写到了派生类的 arr_out 函数中, 此时就能间接访问了(曲线救国)
    stu.arr_out(os);

    return os;
}

ostream & Student::arr_out (ostream &os) const
{
    int limit = ArrayDb::size();  // 获取科目的数量
    if (limit > 0)
    {
        int i = 0;
        for (i = 0; i < limit; i++){
            os << ArrayDb::operator[](i) << " ";

            // 每显示5门成绩就换行
            if (i % 5 == 4){        // 因为索引从0开始, 所以当余数为4时, 说明当前刚好显示了5门成绩
                os << endl;
            }
        }

        // 如果课程数量不是5的整数倍, 则需要额外换行一次
        if (i % 5 != 0){
            os << endl;
        }
    }
    else{
        os << "Empty array!" << endl;
    }

    return os;
}
```

### 使用私有继承还是"包含"(has-a)
1. "包含"的写法更易于理解
2. 继承容易引起很多问题, 尤其从多个基类继承时, 如果两个基类包含了同名的方法就比较麻烦了.
3. "包含"可以包括多个独立的子对象(如多个string对象), 但是**私有继承只能包含一个继承过来的无名对象**(由于没有名字, 肯定只能有1个咯)


但是:
1. 私有继承提供的特性更多
  - 如果基类中有 protected 成员(数据或者成员函数), 此时在派生类中是可以使用的, 而在继承层次结构之外是不可用的(友元函数不能用他们)
    - 对比"包含" 的情况, 我们是无法通过对象来访问这些 protected 成员的. (因为不是继承关系)
2. 私有继承可以重新定义虚函数, 但是"包含"的方式不行.
  - 重新定义的虚函数只能在类中访问, 因为它将是私有成员而不是公有的.


小结: 
- 应使用"包含"来建立`has-a`关系.
- 如果新类`需要访问原有类的保护成员`, 或者`需要重新定义虚函数`, 则应使用私有继承.
  - 实际开发的使用场景是:
  ```txt
  假设业务代码中有一个屎山类, 这个类写得很垃圾, 但目前得维护它, 并且不敢随便删除或修改它原有方法. 

  如果客户要求我们提供一个类给他们进行二次开发, 为了安全, 我们不希望后续的任何客户触碰到这堆屎山, 怎么办呢? 

  此时, 就可以使用私有继承来新建一个 "基类", 这时候就只有这个基类的**内部**才可以访问那些垃圾屎山代码, 而客户那边通过继承这个基类的任何操作就都不能访问了.

  在这个过程中, 由于新的基类是走的继承的模式来获取屎山里面的所有方法, 它本身并没有发生任何改动, 因此这种操作是很安全的.
  ```

## 保护继承
在继承时使用`protected`关键字的继承方式.
- 使用保护继承时, 积累的 **公有成员**和**保护成员**都将成为派生类的`保护成员`. 
- 和私有继承一样, 基类的(公有&保护)接口在派生类内部可以访问, 在继承层级结构之外不可访问.
  - 私有继承和保护继承的区别是:
  ```cpp
  class L1
  {};

  class L2 : private L1
  {};

  class L3 : private L2
  {}; 

  // 此时, L3 将无法访问 L1 的任何方法, 因为在 L2 这一层已经把 L1 的所有方法变成私有的.

  class V1
  {};

  class V2 : protected V1
  {};

  class V3 : protected V2
  {};

  // 此时 V3 还能访问到 V1 的方法, 因为 V2 这一层仅仅是把V1的方法变成 protected, 到 V3 的时候仍然是可见的.
  ```


## 继承方式特性表
![](第十四章笔记_images/继承方式特性表.png)
- 隐式向上转换(implicit upcasting)表示`无需进行显式转换就可以将基类指针/引用指向派生类对象`.

## 用using重新定义访问权限
如果想要在**派生类之外**使用基类的方法, 一般有两种方式:
1. 在派生类中定义一个**使用所需基类方法的函数**, 然后在派生类外面调用这个函数. (前面私有继承的studentc的例子使用的就是这种办法)
2. 使用 using 语句声明
   - 在派生类中, 将私有基类的特定方法用using语句声明为**public**的一部分, 此时, 派生类对象就可以直接使用声明过的私有基类方法了.


代码例子 -- 修改Student类的私有继承版本:
- `studentc.h`
```cpp
#ifndef __STUDENTC_H__
#define __STUDENTC_H__

#include <iostream>
#include <string>
#include <valarray>

using namespace std;

class Student : private string, private valarray<double>    // 私有继承了两个类 (多重继承, multiple inheritance, MI)
{
    private:
        typedef valarray<double> ArrayDb;       // 使用别名, 方便简写, 此时只能在类内部使用这个别名
        ostream & arr_out(ostream &os) const;      // 用来替代非私有继承时写过的输出运算符重载函数

    public:
        Student() : string("Null Student"), ArrayDb(){}

        // 转换函数(同时也是构造函数): string类型 转换为 Student类型
        explicit Student(const string &s) : string(s), ArrayDb(){}      // 注意是显式转换(此时不允许隐式转换), 加了关键字 explicit
        explicit Student(int n) : string("Nully"), ArrayDb(n){}         // 这里也是不允许隐式转换
        
        Student(const string &s, int n) : string(s), ArrayDb(n){}
        Student(const string &s, const ArrayDb &a ) : string(s), ArrayDb(a){}      // score 部分对应的是 valarray(valarray对象) 的使用方式
        Student(const string &s, const double *pd, int n) : string(s), ArrayDb(pd, n){}  // score 部分对应的是 valarray(double数组, 数组长度) 的使用方式

        ~Student(){}

        double Average() const;
        const string & Name() const;
        double & operator[](int n);   // 注意返回的是引用类型, 返回的是"左值"(可写/修改), 此时才可以写成 stu[0] = 100, 此时的 stu[0] 是可读可写的
        double operator[](int n) const;  // 如果把返回值写"非引用"的形式, 那么调用[]运算符得到的对象是"右值", 它是"只读"的, 合法的使用只能是 a = stu[0], 因为 stu[0] 是右值(只读, 不可修改)

        friend istream & operator>>(istream &is, Student &stu); // 用于捕获输入时中间有空格的情况
        friend istream & getline(istream &is, Student &stu);    // 重载捕获一整行的输入情况
        friend ostream & operator<<(ostream &os, const Student &stu);

    public:
        // 使友元函数能调用 私有基类方法 的 "解决方案2": 用 using 声明
        using valarray<double>::size;
        using valarray<double>::operator[];
};

#endif //!__STUDENTC_H__
```
  - 代码中最后的public部分用using声明的两个方法就是这里提到的主要知识点
    - 需要注意, **声明方法时不要加圆括号**`()`!!!

- `studentc.cpp`
```cpp
#include "studentc.h"

double Student::Average() const
{
    // if (scores.size() > 0){
    //     return scores.sum() / scores.size();
    // }
    // else{
    //     return 0.0;
    // }

    if (ArrayDb::size() > 0){
        return ArrayDb::sum() / ArrayDb::size();
    }
    else{
        return 0.0;
    }
}

const string & Student::Name() const
{
    return (const string &)(*this);     // 通过强制类型转换的方式获得从string继承而来的隐式对象
}

// 这个函数返回的是可操作的左值
double & Student::operator[](int n)     // 注意返回的是引用
{
    return ArrayDb::operator[](n);      // scores[n] 本质上就是在调用基类重载的运算符[], 因此这里直接使用 "类名::" 的方式替换
}

// 这个函数返回的是"不可写"的右值
double Student::operator[](int n) const // 按值返回, 不是引用
{
    return ArrayDb::operator[](n);      // 理由同上
}

// 友元函数 (注意它不属于成员函数, 不能直接使用私有基类的方法!)
istream & operator>>(istream &is, Student &stu)
{
    is >> (string &)stu;                // 强制类型转换之后, 得到的string类型的引用本质上等价于 此前的 name 成员
    return is;
}

istream & getline(istream &is, Student &stu)        // 重载了getline函数
{
    getline(is, (string &)stu);          // 这里调用的是原生的 getline 函数, 对应的函数声明是 getline(istream &, string &)
    return is;
}

// 友元函数
ostream & operator<<(ostream &os, const Student &stu)
{
    os << "Scores for " << (const string &)stu << ": " << endl;

    // ---- 方案1 ----
    // 原来写在这里的代码由于不能访问私有基类的方法, 所以把这部分代码写到了派生类的 arr_out 函数中, 此时就能间接访问了(曲线救国)
    // stu.arr_out(os);
    // -------------

    // ---- 方案2 ----
    int i = 0;
    int limit = stu.size();     // 用 using 声明为 public方法 之后就能使用私有基类的 size方法
    if (limit > 0){
        for (i = 0; i < limit; i++){
            os << stu.operator[](i) << " ";   // 用 using 声明为 public方法 之后就能使用私有基类的[]运算符

            // 每显示5门成绩就换行
            if (i % 5 == 4){        // 因为索引从0开始, 所以当余数为4时, 说明当前刚好显示了5门成绩
                os << endl;
            }
        }

        // 如果课程数量不是5的整数倍, 则需要额外换行一次
        if (i % 5 != 0){
            os << endl;
        }
    }
    else{
        os << "Empty array!" << endl;
    }
    // -------------

    return os;
}

// 使友元函数能调用 私有基类方法 的 "解决方案1" (方案2在头文件)
ostream & Student::arr_out (ostream &os) const
{
    int limit = ArrayDb::size();  // 获取科目的数量
    if (limit > 0)
    {
        int i = 0;
        for (i = 0; i < limit; i++){
            os << ArrayDb::operator[](i) << " ";

            // 每显示5门成绩就换行
            if (i % 5 == 4){        // 因为索引从0开始, 所以当余数为4时, 说明当前刚好显示了5门成绩
                os << endl;
            }
        }

        // 如果课程数量不是5的整数倍, 则需要额外换行一次
        if (i % 5 != 0){
            os << endl;
        }
    }
    else{
        os << "Empty array!" << endl;
    }

    return os;
}
```

## 多重继承 (Multiple Inheritance, MI)
主要容易出现以下两个问题:
1. 从两个**不同的基类**继承了`同名方法`
2. 从**两个或更多相关基类**那里`继承同一个类的多个实例`

### 非多重继承时的例子
代码例子 -- 未使用多重继承的版本:
- `worker.h`
```cpp
#ifndef __WORKER_H__
#define __WORKER_H__

#include <iostream>
#include <string>

using namespace std;

class Worker
{
    private:
        string fullname;
        long id;
    public:
        Worker() : fullname("none one"), id(0){}
        Worker(const string &s, long n) : fullname(s), id(n){}
        virtual ~Worker(){}

        virtual void Set();
        virtual void Show() const;
};

class Waiter : public Worker            // 如果不写public, 则默认是private (私有继承)
{
    private:
        int panache;
    public:
        Waiter() : Worker(), panache(0){}
        Waiter(const string &s, long n, int p = 0) : Worker(s, n), panache(p){}
        Waiter(const Worker &wk, int p = 0 ) : Worker(wk), panache(p){}
        virtual ~Waiter(){}

        // Set和Show 也可以不加 virtual, 因为基类已经声明为虚函数
        virtual void Set();
        virtual void Show() const;
};

class Singer : public Worker
{
    protected:          // 保护成员: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问
        enum{other, alto, contralto, soprano, bass, baritone, tenor};
        enum{Vtypes = 7};
    private:
        // 静态数据成员在类声明中声明, 在包含类方法的文件中**初始化**(需用到作用域运算符::),
        //      如果静态成员是 int类型 或 enum const 类型, 则可以直接在类的声明中进行初始化.
        static const char *pv[Vtypes];
        int voice;
    public:
        Singer() : Worker(), voice(other){}
        Singer(const string &s, long n, int v = other) : Worker(s, n), voice(v){}
        Singer(const Worker &wk, int v = other) : Worker(wk), voice(v){}
        virtual ~Singer(){}

        // 本质上 Set和Show 都是虚函数, 只不过这里可以省略 virtual, 因为基类已经声明为virtual了
        void Set();      
        void Show() const; 
};

#endif //!__WORKER_H__
```

- `worker.cpp`
```cpp
#include "worker.h"


// 基类 Worker
void Worker::Set()
{
    cout << "Enter worker's full name: " ;
    getline(cin, fullname);
    cout << "Enter worker's ID: ";
    cin >> id;
    while(cin.get()!= '\n');        // 但凡字符串和数字交替输入, 就要写这个语句, 清掉缓冲区的回车
}

void Worker::Show() const
{
    cout << "Name: " << fullname << endl;
    cout << "Employee ID: " << id << endl;
}

// 派生类 Waiter
void Waiter::Set()
{
    // 派生类, 首先需要调用一下基类的对应方法, 以确保基类被赋值
    Worker::Set();
    cout << "Enter waiter's panache rating: ";
    cin >> panache;
    while(cin.get() != '\n');
}

void Waiter::Show() const
{
    Worker::Show();     // 先完成基类的输出
    cout << "Panache rating: " << panache << endl;
}

// 派生类 Singer
const char *Singer::pv[] = {"other", "alto", "contralto", "soprano", "bass", "baritone", "tenor"};        // 静态成员! 需要另外初始化

void Singer::Set()
{
    Worker::Set();
    int i;
    for (i = 0; i < Vtypes; i++){
        cout << i << ": " << pv[i];
        if(i%4 == 3){
            cout << endl;
        }
    }
    if(i%4 != 0){
        cout << endl;
    }

    cout << "Please enter a value >=0 and <" << Vtypes << endl;
    cin >> voice;

    while(cin.get() != '\n');
}

void Singer::Show() const
{
    Worker::Show();
    cout << "Voice range: " << pv[voice] << endl;
}

```

- 测试代码 `workerTest.cpp`
```cpp
#include <iostream>
#include "worker.h"

using namespace std;

const int LIM = 4;

int main(void)
{
    Waiter bob("Bob", 314,5);
    Singer bev("Bev", 522, 3);
    Waiter w_temp;
    Singer s_temp;


    // 用抽象基类指针管理所有派生类对象!!
    Worker *pw[LIM] = {&bob, &bev, &w_temp, &s_temp};

    // 填充后两个对象的元素
    int i;
    for (i = 2; i < LIM; i++){
        pw[i]->Set();               // Set 是虚函数, 可以动态调用对应的函数
    }

    for (i = 0; i < LIM; i++){
        pw[i]->Show();
        cout << endl;
    }

    return 0;
}
```

---

### 多重继承版本的例子 
![](第十四章笔记_images/多重继承_祖先相同的MI.png)
- 抽象基类 `Worker` 派生出两个新的类`Singer`和`Waiter`
- SingingWaiter 同时继承了 Singer 和 Waiter 这两个类.
  - 此时 SingingWaiter 将包含两个 Worker组件(worker对象), 这在输入数据的时候就会造成麻烦, 需要输入两次, 解决问题的办法是使用`虚基类` (它与虚函数是完全不同的概念, 它们没有联系)
  ![](第十四章笔记_images/多重继承_继承两个基类对象.png)
  - 使用虚基类之后:
  ![](第十四章笔记_images/多重继承_虚基类继承.png)

#### 虚基类
虚基类是的从多个类 (它们的基类相同) 派生出的对象只继承一个基类对象. (具体例子参考下面的SingerWaiter类)

使用方法示例:
```cpp
class Singer : virtual public Worker {};      // 这里的 virtual public 顺序没有要求, 也可以写成 class Singer : public virtual Worker {};
class Waiter : virtual public Worker {};

// 在创建多重继承时, 就能解决多个子对象的问题
class SingingWaiter : public Singer, public Waiter {};
```

##### 虚基类不允许信息自动传递
信息自动传递是指: 处于继承关系底层(距离祖先较远的派生类)在使用构造函数时, 会自动将参数传递给当前派生类上一层的"基类"构造函数, 并一路细分, 直至数据传递到祖先"基类"(或叫`间接基类`), 以完成整个继承链条的所有成员变量的初始化.
  - 值得注意的是: 如果没有使用虚基类, 我们**只能依靠信息自动传递**的方式来初始化祖先基类.
- 用下面的例子可以辅助理解:
```cpp
class A
{
  private:
    int a;
  public:
    A(int n = 0) : a(n){}
};

class B : public A      // B 公有继承了 A
{
  private:
    int b;
  public:
    B(int m = 0, int n = 0) : A(n), b(m){}    // B 只能调用 A 的构造函数初始化A里的数据成员
};

class C : public B
{
  private: 
    int c;
  public:
    C(int q = 0, int m = 0, int n = 0) : B(m, n), c(q){}
    /*
      注意:
        这里C无法直接调用A的构造函数而只能调用B的构造函数(C直接继承的是B类, 它够不着A), 因为它属于第三代目.

        此时就触发了所谓的 "信息传递", 在这里调用B的构造函数时, B(m, n) 的 n 会传递给A的构造函数, 从而完成变量 a 的初始化.
    */
};
```

在虚基类中`不允许自动信息传递`的原因就在于当两个基类有共同祖先时, 基类A的信息和基类B的信息 **分别&同时** 传到"祖先"时就会出现信息冲突问题.
- 因此, 当使用虚基类时, 不允许自动传递信息后就不会出现信息冲突.
  - 此时, "祖先"基类(或叫`间接基类`)的对象会默认地使用`默认构造函数`.
    - 如果要使用祖先基类的**自定义构造函数**, 则需要`显示地使用它`, 这**仅限于虚基类的情况才可以显示调用**, 其他情况下是不允许的!
  ```cpp
  SingingWaiter(const Worker &wk, int p = 0, int v = Singer::other) : Waiter(wk, p), Singer(wk, v){}    // 此时, 祖先基类Worker使用的是默认构造函数.

  SingingWaiter(const Worker &wk, int p = 0, int v = Singer::other) : Worker(wk), Waiter(wk, p), Singer(wk, v){}   // 由于使用了虚基类, 此时允许直接调用祖先基类Worker的自定义构造函数
  ```

#### 代码 (多重继承中使用虚基类)
- `worker.h`
```cpp
#ifndef __WORKER_H__
#define __WORKER_H__

#include <iostream>
#include <string>

using namespace std;

class Worker
{
    private:
        string fullname;
        long id;
    protected:
        virtual void Data() const;      // 模块化输出: 这里只输出自己的数据部分; 我们希望派生类也能实现不同的功能(多态), 于是定义成虚函数
        virtual void Get();       // 同上
    public:
        Worker() : fullname("none one"), id(0){}
        Worker(const string &s, long n) : fullname(s), id(n){}
        virtual ~Worker(){}

        virtual void Set() = 0;         // 纯虚函数(此时Worker就变成抽象基类, 不可再进行实例化)
        virtual void Show() const = 0;  // 纯虚函数(此时Worker就变成抽象基类, 不可再进行实例化)
};

// 继承虚基类 Worker
class Waiter : virtual public Worker            // 如果不写public, 则默认是private (私有继承)
{
    private:
        int panache;
    protected:
        virtual void Data() const;      // 模块化输出: 这里只输出自己的数据部分; 我们希望派生类也能实现不同的功能(多态), 于是定义成虚函数
        virtual void Get();       // 同上
    public:
        Waiter() : Worker(), panache(0){}
        Waiter(const string &s, long n, int p = 0) : Worker(s, n), panache(p){}
        Waiter(const Worker &wk, int p = 0 ) : Worker(wk), panache(p){}
        virtual ~Waiter(){}

        // Set和Show 也可以不加 virtual, 因为基类已经声明为虚函数
        virtual void Set();
        virtual void Show() const;
};

// 继承虚基类 Worker
class Singer : public virtual Worker
{
    protected:          // 保护成员: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问
        enum{other, alto, contralto, soprano, bass, baritone, tenor};
        enum{Vtypes = 7};
    private:
        // 静态数据成员在类声明中声明, 在包含类方法的文件中**初始化**(需用到作用域运算符::),
        //      如果静态成员是 int类型 或 enum const 类型, 则可以直接在类的声明中进行初始化.
        static const char *pv[Vtypes];
        int voice;
    protected:
        virtual void Data() const;      // 模块化输出: 这里只输出自己的数据部分; 我们希望派生类也能实现不同的功能(多态), 于是定义成虚函数
        virtual void Get();       // 同上
    public:
        Singer() : Worker(), voice(other){}
        Singer(const string &s, long n, int v = other) : Worker(s, n), voice(v){}
        Singer(const Worker &wk, int v = other) : Worker(wk), voice(v){}
        virtual ~Singer(){}

        // 本质上 Set和Show 都是虚函数, 只不过这里可以省略 virtual, 因为基类已经声明为virtual了
        void Set();      
        void Show() const; 
};


// 多重继承的派生类
class SingingWaiter : public Waiter, public Singer
{
    protected:  // 虽然没有属于自己的数据, 但由于基类已经把Data和Get定义为虚函数了, 所以派生类一定要有这两个函数
        virtual void Data() const {};      // 啥都不干就行, 但是不能缺
        virtual void Get() {};       // 啥都不干就行, 但是不能缺
    public:
        // 由于Singer和Waiter都采用了虚基类的写法, 所以这里会自动禁用"信息传递", 并允许使用间接基类(祖先基类)的构造函数 Worker(const string &, long n);
        SingingWaiter(){};
        SingingWaiter(const string &s, long n, int p = 0, int v = Singer::other) : Worker(s, n), Waiter(s, n, p), Singer(s, n, v){}
        SingingWaiter(const Worker &wk, int p = 0, int v = Singer::other) : Worker(wk), Waiter(wk, p), Singer(wk, v) {}

        virtual void Set();
        virtual void Show() const;      // 注意, 如果多重继承的派生类想要调用其中一个基类里的函数, 最安全的做法是使用作用域解析运算符(::)来避免二义性, 而为了避免多次输出基类的成员, 还推荐使用模块化拆分的方式
};

#endif //!__WORKER_H__
```

- `worker.cpp`
```cpp
#include "worker.h"

// 基类 Worker
void Worker::Get()
{
    cout << "Enter worker's full name: " ;
    getline(cin, fullname);
    cout << "Enter worker's ID: ";
    cin >> id;
    while(cin.get()!= '\n');        // 但凡字符串和数字交替输入, 就要写这个语句, 清掉缓冲区的回车
}

void Worker::Data() const
{
    cout << "Name: " << fullname << endl;
    cout << "Employee ID: " << id << endl;
}

// 派生类 Waiter
void Waiter::Get()
{
    // 派生类, 首先需要调用一下基类的对应方法, 以确保基类被赋值
    cout << "Enter waiter's panache rating: ";
    cin >> panache;
    while(cin.get() != '\n');
}

void Waiter::Data() const
{
    cout << "Panache rating: " << panache << endl;
}

void Waiter::Set()
{
    Worker::Get();
    Waiter::Get();
}

void Waiter::Show() const
{
    Worker::Data();
    Waiter::Data();
}

// 派生类 Singer

// 首先初始化静态成员
const char *Singer::pv[] = {"other", "alto", "contralto", "soprano", "bass", "baritone", "tenor"};        // 静态成员! 需要另外初始化

void Singer::Get()
{
    int i;
    for (i = 0; i < Vtypes; i++){
        cout << i << ": " << pv[i] << " ";
        if(i%4 == 3){
            cout << endl;
        }
    }
    if(i%4 != 0){
        cout << endl;
    }

    cout << "Please enter a value >=0 and <" << Vtypes << endl;
    cin >> voice;

    while(cin.get() != '\n');
}

void Singer::Data() const
{
    cout << "Voice range: " << pv[voice] << endl;
}

void Singer::Set()
{
    Worker::Get();
    Singer::Get();
}

void Singer::Show() const
{
    Worker::Data();
    Singer::Data();
}


// 多重继承的 SingingWaiter
void SingingWaiter::Set()
{
    Worker::Get();
    Waiter::Get();
    Singer::Get();
}

void SingingWaiter::Show() const
{
    Worker::Data();
    Waiter::Data();
    Singer::Data();
}
```

- 测试代码`workerTest.cpp`
```cpp
#include <iostream>
#include <cstring>
#include "worker.h"

using namespace std;

const int SIZE = 3;

int main(void)
{
    Worker *lolas[SIZE];        // 用间接基类(祖先基类)来管理所有的派生类
    int i;
    char choice;
    for (i = 0; i < SIZE; i++){
        cout << "Enter the employee category: " << endl
            << "w: Waiter   s: Singer   t: Singing Waiter    q: quit" << endl;
            cin >> choice;
        
        // 判断输入是否合理, 不合理则继续输入
        while(strchr("wstq", choice) == nullptr){      // strchr 用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置。
            cout << "Please enter a character from w, s, t, q: ";
            cin >> choice;
        }

        if (choice == 'q'){
            break;
        }

        // 用默认构造函数创建对应的类对象的存储空间
        switch (choice){
        case 'w':
            lolas[i] = new Waiter;
            break;
        case 's':
            lolas[i] = new Singer;
            break;
        case 't':
            lolas[i] = new SingingWaiter;
            break;
        }
        while(cin.get() != '\n') {};       // 干掉回车
        
        lolas[i]->Set();    // 填充信息到对应的类
    }

    if (i > 0){
        cout << "\nHere is your staff: " << endl;
        for(i = 0; i < SIZE; i++){
            lolas[i]->Show();
            cout << endl;
        }

        // 释放内存空间
        for(i = 0; i < SIZE; i++){
            delete lolas[i];
        }
    }

    return 0;
}
```


