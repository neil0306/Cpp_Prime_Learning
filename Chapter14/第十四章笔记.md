# C++ 代码重用

## 包含对象成员的类
设计类时, 类的数据成员是`其他类的对象`.
### valarraly 模板类
可以把它理解为一个数组模板. 使用时需要包含头文件`valarray`, 即:
```
#include <valarray>
```

- 可以创建长度为零的空数组
  - `valarray<int> a;`
- 也可以创建指定长度的数组
  - `valaaray<int> v1 = {20, 30, 40, 50};`, 使用**初始化列表**的方式创建数组
  - `valarray<int> a(10);`, 创建一个数组, 一共有10个元素, 但是元素都没有初始化
  - `valarray<int> a(10, 8);`, 创建一个数组, 一共有8个元素, 每个元素的数值都是10
- 创建数组时, 还可以把**常规数组**作为参数, 用来初始化新数组
  ```cpp
    double gpa = {3.1, 3.5, 3.8, 2.9, 3.3};
    valarray<double> v1(gpa, 4);
    /*
        v1 数组只能容纳4个元素, 此时会将 gpa 数组的前四个元素复制到 v1 数组中
    */
  ```

### has-a 关系
如果一个类包含另一个类的对象, 就称为**has-a**关系. 例如:
```cpp
#include <string>
#include <valarray>

using namespace std;

class Student
{
    private:
        string name;                // 包含了string类型的对象, 此时 类型Student 和 string 之间是 has-a 关系.
        valarray<double> scores;    // 此时 类型Student 和 valarray 之间是 has-a 关系.
};
```
- has-a 关系有个特性, 这个student类包含了 string类 和 valarray类 的成员对象的实现, 但**没有继承这两个类的接口**. 
  - 此时, Student里面的 name 和 scores 这两个对象可以分别调用它们本身所属的类的方法.
  - 这说明 Student 类里面**间接地**获得了 string类 和 valarray类 的方法的使用权限, 虽然使用时需要用 name 和 scores 这两个对象.
    ![](第十四章笔记_images/对象中的对象_包含.png)


代码例子:
- `studentc.h`
```cpp
#ifndef __STUDENTC_H__
#define __STUDENTC_H__

#include <iostream>
#include <string>
#include <valarray>

using namespace std;

class Student
{
    private:
        typedef valarray<double> ArrayDb;       // 使用别名, 方便简写, 此时只能在类内部使用这个别名
        string name;
        ArrayDb scores;         // 等价于 valarray<double> scores;
    public:
        Student() : name("Null Student"), scores(){}

        // 转换函数(同时也是构造函数): string类型 转换为 Student类型
        explicit Student(const string &s) : name(s), scores(){}      // 注意是显式转换(此时不允许隐式转换), 加了关键字 explicit
        explicit Student(int n) : name("Nully"), scores(n){}         // 这里也是不允许隐式转换
        
        Student(const string &s, int n) : name(s), scores(n){}
        Student(const string &s, const ArrayDb &a ) : name(s), scores(a){}      // score 部分对应的是 valarray(valarray对象) 的使用方式
        Student(const string &s, const double *pd, int n) : name(s), scores(pd, n){}  // score 部分对应的是 valarray(double数组, 数组长度) 的使用方式

        ~Student(){}

        double Average() const;
        const string & Name() const;
        double & operator[](int n);   // 注意返回的是引用类型, 返回的是"左值"(可写/修改), 此时才可以写成 stu[0] = 100, 此时的 stu[0] 是可读可写的
        double operator[](int n) const;  // 如果把返回值写"非引用"的形式, 那么调用[]运算符得到的对象是"右值", 它是"只读"的, 合法的使用只能是 a = stu[0], 因为 stu[0] 是右值(只读, 不可修改)

        friend istream & operator>>(istream &is, Student &stu); // 用于捕获输入时中间有空格的情况
        friend istream & getline(istream &is, Student &stu);    // 重载捕获一整行的输入情况
        friend ostream & operator<<(ostream &os, const Student &stu);
};

#endif //!__STUDENTC_H__
```

- `studentc.cpp`
```cpp
#include "studentc.h"

double Student::Average() const
{
    if (scores.size() > 0){
        return scores.sum() / scores.size();
    }
    else{
        return 0.0;
    }
}

const string &Student::Name() const
{
    return name;
}

// 这个函数返回的是可操作的左值
double & Student::operator[](int n)     // 注意返回的是引用
{
    return scores[n];
}

// 这个函数返回的是"不可写"的右值
double Student::operator[](int n) const // 按值返回, 不是引用
{
    return scores[n];
}

istream & operator>>(istream &is, Student &stu)
{
    is >> stu.name;
    return is;
}

istream & getline(istream &is, Student &stu)        // 重载了getline函数
{
    getline(is, stu.name);          // 这里调用的是原生的 getline 函数, 对应的函数声明是 getline(istream &, string &)
    return is;
}

ostream & operator<<(ostream &os, const Student &stu)
{
    os << "Scores for " << stu.name << ": " << endl;

    int limit = stu.scores.size();  // 获取科目的数量
    if (limit > 0)
    {
        int i = 0;
        for (i = 0; i < limit; i++){
            os << stu.scores[i] << " ";

            // 每显示5门成绩就换行
            if (i % 5 == 4){        // 因为索引从0开始, 所以当余数为4时, 说明当前刚好显示了5门成绩
                os << endl;
            }
        }

        // 如果课程数量不是5的整数倍, 则需要额外换行一次
        if (i % 5 != 0){
            os << endl;
        }
    }
    else{
        os << "Empty array!" << endl;
    }
    return os;
}
```

- `useStudentc.cpp`
```cpp
#include <iostream>
#include "studentc.h"

using namespace std;

const int pupils = 3;
const int quizzes =5;

void set(Student &sa, int n);

int main(void)
{
    Student ada[pupils] = {Student(quizzes), Student(quizzes), Student(quizzes)};
    int i = 0;;

    // 录入信息
    for (i = 0; i < pupils; i++){
        set(ada[i], quizzes);       // 这里的 ada[i] 访问的是 "不同的Student对象"
    }
    cout << " -------- " << endl;

    // 输出
    cout << "Student List: " << endl;
    for (i = 0; i < pupils; i++){
        cout << ada[i].Name() << endl;
    }
    cout << " -------- " << endl;

    cout << "Result List: " << endl;
    for (i = 0; i < pupils; i++){
        cout << ada[i];             // 使用友元函数 operator<<()
        cout << "Average: " << ada[i].Average() << endl;
    }

    return 0;
}

void set(Student &sa, int n)
{
    cout << "Please enter the student's name: " << endl;
    getline(cin, sa);
    cout << "Please enter " << n << " quizzes scores: " << endl;
    for (int i = 0; i < n; i++){
        cin >> sa[i];           // 这里的 sa[i] 访问的是 Student对象里的[]重载运算符, 填充的是对象里面的 scores 数组
    }

    // 每当输入数字之后, 缓冲区都会存在一个多余的回车, 记得干掉.
    while(cin.get() != '\n');
}
```

## 私有继承
回顾公有继承:
- 基类的所有 public 方法都自动变成派生类的 public 方法
- 基类的 public 成员自动变成派生类的 public 成员 (虽然这种case非常少见, 数据基本都是private)

对于`私有继承`来说:
在声明派生类时, 如果使用关键词`private`来继承基类, 此时就是私有继承.
- 此时的基类称为`私有基类`, 派生类称为`私有派生类`

私有继承的特点:
- 基类的所有 **public** 方法都会变成 派生类的 **private** 方法.
  - 基类中本来属于 private 的部分仍旧只能使用**基类的public接口进行访问**, 派生类依然不能直接访问它们.
- 基类中的**public 成员**和**protected 成员** 会变成派生类的 **private成员**
  - 此时**派生类的成员函数可以访问它们**, 但是在派生类之外不能访问, 即使是派生类的对象也不能直接访问(这与前面讲过的类的基本知识一致)
    - 注意: **友元函数不属于类的成员函数**, 因此友元函数并不属于派生类的**内部**, 故`友元函数不能直接使用私有基类的方法`!! 但可以想办法通过`强制类型转换`的方式将派生类转成基类, 然后间接地进行访问.
- 私有派生类将**继承私有基类的实现**.
  - 比如说: Student 是 string 的 私有派生类 (这时候string就是私有基类了), 此时, Student将包含一个**string的对象**(也被称为string的实现/string类组件), 也就是说, 在Student类里面起码会自带一个string对象可以存储数据, 只不过这个对象是`无名对象`, 这种对象需要通过基类的方法才能访问.
    - 这个无名对象也可以理解为像 this指针 那样的隐式对象成员.





代码例子 -- 用私有继承的方式重写前面的 Student类:
- 区别有:
  - 使用了多重继承(multiple inheritance, MI), 同时继承了 string 和 valarray<double> 类, 而且是私有继承
  - 由于是私有继承, Student会分别从 string 和 valarray<double> 中各继承到一个`无名对象`, 因此 Student类中不再包含数据成员 name 和 scores
    - 由于没有存储数据的成员名字, 所以在构造函数中初始化继承过来的无名对象时, 需要直接使用 **基类的构造函数** 来完成无名对象的初始化.
    - 在调用string 和 valarray<double> 里面的公有方法时, 由于没有了对象的名字, 这里直接使用`类名::方法名()`就相当于是通过对象来调用了相应的方法.
    - string, valarray 和 Student 之间是继承关系, 因此为了获得继承而来的隐式对象, 我们可以通过`强制类型转换的方式`来完成.
      - 将当前对象转换为基类对象: `(string &)*this;`, `(valarray<double> &)*this;`
      - 将Student类的对象转换为基类对象: `(string &)stu;`, `(valarray<double> &)stu;`
  - 新增函数 `arr_out`, 因为友元函数无法访问私有基类的方法, 所以把这部分代码搬到私有派生类的 arr_out 函数中, 此时友元函数借助派生类的函数去间接访问私有基类的方法即可.


- 修改后的`studentc.h`
```cpp
#ifndef __STUDENTC_H__
#define __STUDENTC_H__

#include <iostream>
#include <string>
#include <valarray>

using namespace std;

class Student : private string, private valarray<double>    // 私有继承了两个类 (多重继承, multiple inheritance, MI)
{
    private:
        typedef valarray<double> ArrayDb;       // 使用别名, 方便简写, 此时只能在类内部使用这个别名
        ostream & arr_out(ostream &os) const;      // 用来替代非私有继承时写过的输出运算符重载函数

    public:
        Student() : string("Null Student"), ArrayDb(){}

        // 转换函数(同时也是构造函数): string类型 转换为 Student类型
        explicit Student(const string &s) : string(s), ArrayDb(){}      // 注意是显式转换(此时不允许隐式转换), 加了关键字 explicit
        explicit Student(int n) : string("Nully"), ArrayDb(n){}         // 这里也是不允许隐式转换
        
        Student(const string &s, int n) : string(s), ArrayDb(n){}
        Student(const string &s, const ArrayDb &a ) : string(s), ArrayDb(a){}      // score 部分对应的是 valarray(valarray对象) 的使用方式
        Student(const string &s, const double *pd, int n) : string(s), ArrayDb(pd, n){}  // score 部分对应的是 valarray(double数组, 数组长度) 的使用方式

        ~Student(){}

        double Average() const;
        const string & Name() const;
        double & operator[](int n);   // 注意返回的是引用类型, 返回的是"左值"(可写/修改), 此时才可以写成 stu[0] = 100, 此时的 stu[0] 是可读可写的
        double operator[](int n) const;  // 如果把返回值写"非引用"的形式, 那么调用[]运算符得到的对象是"右值", 它是"只读"的, 合法的使用只能是 a = stu[0], 因为 stu[0] 是右值(只读, 不可修改)

        friend istream & operator>>(istream &is, Student &stu); // 用于捕获输入时中间有空格的情况
        friend istream & getline(istream &is, Student &stu);    // 重载捕获一整行的输入情况
        friend ostream & operator<<(ostream &os, const Student &stu);
};

#endif //!__STUDENTC_H__
```

- 修改后的`studentc.cpp`

```cpp
#include "studentc.h"

double Student::Average() const
{
    // if (scores.size() > 0){
    //     return scores.sum() / scores.size();
    // }
    // else{
    //     return 0.0;
    // }

    if (ArrayDb::size() > 0){
        return ArrayDb::sum() / ArrayDb::size();
    }
    else{
        return 0.0;
    }
}

const string & Student::Name() const
{
    return (const string &)(*this);     // 通过强制类型转换的方式获得从string继承而来的隐式对象
}

// 这个函数返回的是可操作的左值
double & Student::operator[](int n)     // 注意返回的是引用
{
    return ArrayDb::operator[](n);      // scores[n] 本质上就是在调用基类重载的运算符[], 因此这里直接使用 "类名::" 的方式替换
}

// 这个函数返回的是"不可写"的右值
double Student::operator[](int n) const // 按值返回, 不是引用
{
    return ArrayDb::operator[](n);      // 理由同上
}

// 友元函数 (注意它不属于成员函数, 不能直接使用私有基类的方法!)
istream & operator>>(istream &is, Student &stu)
{
    is >> (string &)stu;                // 强制类型转换之后, 得到的string类型的引用本质上等价于 此前的 name 成员
    return is;
}

istream & getline(istream &is, Student &stu)        // 重载了getline函数
{
    getline(is, (string &)stu);          // 这里调用的是原生的 getline 函数, 对应的函数声明是 getline(istream &, string &)
    return is;
}

// 友元函数
ostream & operator<<(ostream &os, const Student &stu)
{
    os << "Scores for " << (const string &)stu << ": " << endl;

    // 原来写在这里的代码由于不能访问私有基类的方法, 所以把这部分代码写到了派生类的 arr_out 函数中, 此时就能间接访问了(曲线救国)
    stu.arr_out(os);

    return os;
}

ostream & Student::arr_out (ostream &os) const
{
    int limit = ArrayDb::size();  // 获取科目的数量
    if (limit > 0)
    {
        int i = 0;
        for (i = 0; i < limit; i++){
            os << ArrayDb::operator[](i) << " ";

            // 每显示5门成绩就换行
            if (i % 5 == 4){        // 因为索引从0开始, 所以当余数为4时, 说明当前刚好显示了5门成绩
                os << endl;
            }
        }

        // 如果课程数量不是5的整数倍, 则需要额外换行一次
        if (i % 5 != 0){
            os << endl;
        }
    }
    else{
        os << "Empty array!" << endl;
    }

    return os;
}
```

### 使用私有继承还是"包含"(has-a)
1. "包含"的写法更易于理解
2. 继承容易引起很多问题, 尤其从多个基类继承时, 如果两个基类包含了同名的方法就比较麻烦了.
3. "包含"可以包括多个独立的子对象(如多个string对象), 但是**私有继承只能包含一个继承过来的无名对象**(由于没有名字, 肯定只能有1个咯)


但是:
1. 私有继承提供的特性更多
  - 如果基类中有 protected 成员(数据或者成员函数), 此时在派生类中是可以使用的, 而在继承层次结构之外是不可用的(友元函数不能用他们)
    - 对比"包含" 的情况, 我们是无法通过对象来访问这些 protected 成员的. (因为不是继承关系)
2. 私有继承可以重新定义虚函数, 但是"包含"的方式不行.
  - 重新定义的虚函数只能在类中访问, 因为它将是私有成员而不是公有的.


小结: 
- 应使用"包含"来建立`has-a`关系.
- 如果新类`需要访问原有类的保护成员`, 或者`需要重新定义虚函数`, 则应使用私有继承.
  - 实际开发的使用场景是:
  ```txt
  假设业务代码中有一个屎山类, 这个类写得很垃圾, 但目前得维护它, 并且不敢随便删除或修改它原有方法. 

  如果客户要求我们提供一个类给他们进行二次开发, 为了安全, 我们不希望后续的任何客户触碰到这堆屎山, 怎么办呢? 

  此时, 就可以使用私有继承来新建一个 "基类", 这时候就只有这个基类的**内部**才可以访问那些垃圾屎山代码, 而客户那边通过继承这个基类的任何操作就都不能访问了.

  在这个过程中, 由于新的基类是走的继承的模式来获取屎山里面的所有方法, 它本身并没有发生任何改动, 因此这种操作是很安全的.
  ```

## 保护继承
在继承时使用`protected`关键字的继承方式.
- 使用保护继承时, 积累的 **公有成员**和**保护成员**都将成为派生类的`保护成员`. 
- 和私有继承一样, 基类的(公有&保护)接口在派生类内部可以访问, 在继承层级结构之外不可访问.
  - 私有继承和保护继承的区别是:
  ```cpp
  class L1
  {};

  class L2 : private L1
  {};

  class L3 : private L2
  {}; 

  // 此时, L3 将无法访问 L1 的任何方法, 因为在 L2 这一层已经把 L1 的所有方法变成私有的.

  class V1
  {};

  class V2 : protected V1
  {};

  class V3 : protected V2
  {};

  // 此时 V3 还能访问到 V1 的方法, 因为 V2 这一层仅仅是把V1的方法变成 protected, 到 V3 的时候仍然是可见的.
  ```


## 继承方式特性表
![](第十四章笔记_images/继承方式特性表.png)
- 隐式向上转换(implicit upcasting)表示`无需进行显式转换就可以将基类指针/引用指向派生类对象`.

## 用using重新定义访问权限
如果想要在**派生类之外**使用基类的方法, 一般有两种方式:
1. 在派生类中定义一个**使用所需基类方法的函数**, 然后在派生类外面调用这个函数. (前面私有继承的studentc的例子使用的就是这种办法)
2. 使用 using 语句声明
   - 在派生类中, 将私有基类的特定方法用using语句声明为**public**的一部分, 此时, 派生类对象就可以直接使用声明过的私有基类方法了.


代码例子 -- 修改Student类的私有继承版本:
- `studentc.h`
```cpp
#ifndef __STUDENTC_H__
#define __STUDENTC_H__

#include <iostream>
#include <string>
#include <valarray>

using namespace std;

class Student : private string, private valarray<double>    // 私有继承了两个类 (多重继承, multiple inheritance, MI)
{
    private:
        typedef valarray<double> ArrayDb;       // 使用别名, 方便简写, 此时只能在类内部使用这个别名
        ostream & arr_out(ostream &os) const;      // 用来替代非私有继承时写过的输出运算符重载函数

    public:
        Student() : string("Null Student"), ArrayDb(){}

        // 转换函数(同时也是构造函数): string类型 转换为 Student类型
        explicit Student(const string &s) : string(s), ArrayDb(){}      // 注意是显式转换(此时不允许隐式转换), 加了关键字 explicit
        explicit Student(int n) : string("Nully"), ArrayDb(n){}         // 这里也是不允许隐式转换
        
        Student(const string &s, int n) : string(s), ArrayDb(n){}
        Student(const string &s, const ArrayDb &a ) : string(s), ArrayDb(a){}      // score 部分对应的是 valarray(valarray对象) 的使用方式
        Student(const string &s, const double *pd, int n) : string(s), ArrayDb(pd, n){}  // score 部分对应的是 valarray(double数组, 数组长度) 的使用方式

        ~Student(){}

        double Average() const;
        const string & Name() const;
        double & operator[](int n);   // 注意返回的是引用类型, 返回的是"左值"(可写/修改), 此时才可以写成 stu[0] = 100, 此时的 stu[0] 是可读可写的
        double operator[](int n) const;  // 如果把返回值写"非引用"的形式, 那么调用[]运算符得到的对象是"右值", 它是"只读"的, 合法的使用只能是 a = stu[0], 因为 stu[0] 是右值(只读, 不可修改)

        friend istream & operator>>(istream &is, Student &stu); // 用于捕获输入时中间有空格的情况
        friend istream & getline(istream &is, Student &stu);    // 重载捕获一整行的输入情况
        friend ostream & operator<<(ostream &os, const Student &stu);

    public:
        // 使友元函数能调用 私有基类方法 的 "解决方案2": 用 using 声明
        using valarray<double>::size;
        using valarray<double>::operator[];
};

#endif //!__STUDENTC_H__
```
  - 代码中最后的public部分用using声明的两个方法就是这里提到的主要知识点
    - 需要注意, **声明方法时不要加圆括号**`()`!!!

- `studentc.cpp`
```cpp
#include "studentc.h"

double Student::Average() const
{
    // if (scores.size() > 0){
    //     return scores.sum() / scores.size();
    // }
    // else{
    //     return 0.0;
    // }

    if (ArrayDb::size() > 0){
        return ArrayDb::sum() / ArrayDb::size();
    }
    else{
        return 0.0;
    }
}

const string & Student::Name() const
{
    return (const string &)(*this);     // 通过强制类型转换的方式获得从string继承而来的隐式对象
}

// 这个函数返回的是可操作的左值
double & Student::operator[](int n)     // 注意返回的是引用
{
    return ArrayDb::operator[](n);      // scores[n] 本质上就是在调用基类重载的运算符[], 因此这里直接使用 "类名::" 的方式替换
}

// 这个函数返回的是"不可写"的右值
double Student::operator[](int n) const // 按值返回, 不是引用
{
    return ArrayDb::operator[](n);      // 理由同上
}

// 友元函数 (注意它不属于成员函数, 不能直接使用私有基类的方法!)
istream & operator>>(istream &is, Student &stu)
{
    is >> (string &)stu;                // 强制类型转换之后, 得到的string类型的引用本质上等价于 此前的 name 成员
    return is;
}

istream & getline(istream &is, Student &stu)        // 重载了getline函数
{
    getline(is, (string &)stu);          // 这里调用的是原生的 getline 函数, 对应的函数声明是 getline(istream &, string &)
    return is;
}

// 友元函数
ostream & operator<<(ostream &os, const Student &stu)
{
    os << "Scores for " << (const string &)stu << ": " << endl;

    // ---- 方案1 ----
    // 原来写在这里的代码由于不能访问私有基类的方法, 所以把这部分代码写到了派生类的 arr_out 函数中, 此时就能间接访问了(曲线救国)
    // stu.arr_out(os);
    // -------------

    // ---- 方案2 ----
    int i = 0;
    int limit = stu.size();     // 用 using 声明为 public方法 之后就能使用私有基类的 size方法
    if (limit > 0){
        for (i = 0; i < limit; i++){
            os << stu.operator[](i) << " ";   // 用 using 声明为 public方法 之后就能使用私有基类的[]运算符

            // 每显示5门成绩就换行
            if (i % 5 == 4){        // 因为索引从0开始, 所以当余数为4时, 说明当前刚好显示了5门成绩
                os << endl;
            }
        }

        // 如果课程数量不是5的整数倍, 则需要额外换行一次
        if (i % 5 != 0){
            os << endl;
        }
    }
    else{
        os << "Empty array!" << endl;
    }
    // -------------

    return os;
}

// 使友元函数能调用 私有基类方法 的 "解决方案1" (方案2在头文件)
ostream & Student::arr_out (ostream &os) const
{
    int limit = ArrayDb::size();  // 获取科目的数量
    if (limit > 0)
    {
        int i = 0;
        for (i = 0; i < limit; i++){
            os << ArrayDb::operator[](i) << " ";

            // 每显示5门成绩就换行
            if (i % 5 == 4){        // 因为索引从0开始, 所以当余数为4时, 说明当前刚好显示了5门成绩
                os << endl;
            }
        }

        // 如果课程数量不是5的整数倍, 则需要额外换行一次
        if (i % 5 != 0){
            os << endl;
        }
    }
    else{
        os << "Empty array!" << endl;
    }

    return os;
}
```

## 多重继承 (Multiple Inheritance, MI)
主要容易出现以下两个问题:
1. 从两个**不同的基类**继承了`同名方法`
2. 从**两个或更多相关基类**那里`继承同一个类的多个实例`

### 例子 
![](第十四章笔记_images/多重继承_祖先相同的MI.png)
- 抽象基类 `Worker` 派生出两个新的类`Singer`和`Waiter`
- SingingWaiter 同时继承了 Singer 和 Waiter 这两个类.


