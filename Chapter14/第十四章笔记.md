# C++ 代码重用

## 包含对象成员的类
设计类时, 类的数据成员是`其他类的对象`.
### valarraly 模板类
可以把它理解为一个数组模板. 使用时需要包含头文件`valarray`, 即:
```
#include <valarray>
```

- 可以创建长度为零的空数组
  - `valarray<int> a;`
- 也可以创建指定长度的数组
  - `valaaray<int> v1 = {20, 30, 40, 50};`, 使用**初始化列表**的方式创建数组
  - `valarray<int> a(10);`, 创建一个数组, 一共有10个元素, 但是元素都没有初始化
  - `valarray<int> a(10, 8);`, 创建一个数组, 一共有8个元素, 每个元素的数值都是10
- 创建数组时, 还可以把**常规数组**作为参数, 用来初始化新数组
  ```cpp
    double gpa = {3.1, 3.5, 3.8, 2.9, 3.3};
    valarray<double> v1(gpa, 4);
    /*
        v1 数组只能容纳4个元素, 此时会将 gpa 数组的前四个元素复制到 v1 数组中
    */
  ```

### has-a 关系
如果一个类包含另一个类的对象, 就称为**has-a**关系. 例如:
```cpp
#include <string>
#include <valarray>

using namespace std;

class Student
{
    private:
        string name;                // 包含了string类型的对象, 此时 类型Student 和 string 之间是 has-a 关系.
        valarray<double> scores;    // 此时 类型Student 和 valarray 之间是 has-a 关系.
};
```
- has-a 关系有个特性, 这个student类包含了 string类 和 valarray类 的成员对象的实现, 但**没有继承这两个类的接口**. 
  - 此时, Student里面的 name 和 scores 这两个对象可以分别调用它们本身所属的类的方法.
  - 这说明 Student 类里面**间接地**获得了 string类 和 valarray类 的方法的使用权限, 虽然使用时需要用 name 和 scores 这两个对象.
    ![](第十四章笔记_images/对象中的对象_包含.png)


代码例子:
- `studentc.h`
```cpp
#ifndef __STUDENTC_H__
#define __STUDENTC_H__

#include <iostream>
#include <string>
#include <valarray>

using namespace std;

class Student
{
    private:
        typedef valarray<double> ArrayDb;       // 使用别名, 方便简写, 此时只能在类内部使用这个别名
        string name;
        ArrayDb scores;         // 等价于 valarray<double> scores;
    public:
        Student() : name("Null Student"), scores(){}

        // 转换函数(同时也是构造函数): string类型 转换为 Student类型
        explicit Student(const string &s) : name(s), scores(){}      // 注意是显式转换(此时不允许隐式转换), 加了关键字 explicit
        explicit Student(int n) : name("Nully"), scores(n){}         // 这里也是不允许隐式转换
        
        Student(const string &s, int n) : name(s), scores(n){}
        Student(const string &s, const ArrayDb &a ) : name(s), scores(a){}      // score 部分对应的是 valarray(valarray对象) 的使用方式
        Student(const string &s, const double *pd, int n) : name(s), scores(pd, n){}  // score 部分对应的是 valarray(double数组, 数组长度) 的使用方式

        ~Student(){}

        double Average() const;
        const string & Name() const;
        double & operator[](int n);   // 注意返回的是引用类型, 返回的是"左值"(可写/修改), 此时才可以写成 stu[0] = 100, 此时的 stu[0] 是可读可写的
        double operator[](int n) const;  // 如果把返回值写"非引用"的形式, 那么调用[]运算符得到的对象是"右值", 它是"只读"的, 合法的使用只能是 a = stu[0], 因为 stu[0] 是右值(只读, 不可修改)

        friend istream & operator>>(istream &is, Student &stu); // 用于捕获输入时中间有空格的情况
        friend istream & getline(istream &is, Student &stu);    // 重载捕获一整行的输入情况
        friend ostream & operator<<(ostream &os, const Student &stu);
};

#endif //!__STUDENTC_H__
```

- `studentc.cpp`
```cpp
#include "studentc.h"

double Student::Average() const
{
    if (scores.size() > 0){
        return scores.sum() / scores.size();
    }
    else{
        return 0.0;
    }
}

const string &Student::Name() const
{
    return name;
}

// 这个函数返回的是可操作的左值
double & Student::operator[](int n)     // 注意返回的是引用
{
    return scores[n];
}

// 这个函数返回的是"不可写"的右值
double Student::operator[](int n) const // 按值返回, 不是引用
{
    return scores[n];
}

istream & operator>>(istream &is, Student &stu)
{
    is >> stu.name;
    return is;
}

istream & getline(istream &is, Student &stu)        // 重载了getline函数
{
    getline(is, stu.name);          // 这里调用的是原生的 getline 函数, 对应的函数声明是 getline(istream &, string &)
    return is;
}

ostream & operator<<(ostream &os, const Student &stu)
{
    os << "Scores for " << stu.name << ": " << endl;

    int limit = stu.scores.size();  // 获取科目的数量
    if (limit > 0)
    {
        int i = 0;
        for (i = 0; i < limit; i++){
            os << stu.scores[i] << " ";

            // 每显示5门成绩就换行
            if (i % 5 == 4){        // 因为索引从0开始, 所以当余数为4时, 说明当前刚好显示了5门成绩
                os << endl;
            }
        }

        // 如果课程数量不是5的整数倍, 则需要额外换行一次
        if (i % 5 != 0){
            os << endl;
        }
    }
    else{
        os << "Empty array!" << endl;
    }
    return os;
}
```

- `useStudentc.cpp`
```cpp
#include <iostream>
#include "studentc.h"

using namespace std;

const int pupils = 3;
const int quizzes =5;

void set(Student &sa, int n);

int main(void)
{
    Student ada[pupils] = {Student(quizzes), Student(quizzes), Student(quizzes)};
    int i = 0;;

    // 录入信息
    for (i = 0; i < pupils; i++){
        set(ada[i], quizzes);       // 这里的 ada[i] 访问的是 "不同的Student对象"
    }
    cout << " -------- " << endl;

    // 输出
    cout << "Student List: " << endl;
    for (i = 0; i < pupils; i++){
        cout << ada[i].Name() << endl;
    }
    cout << " -------- " << endl;

    cout << "Result List: " << endl;
    for (i = 0; i < pupils; i++){
        cout << ada[i];             // 使用友元函数 operator<<()
        cout << "Average: " << ada[i].Average() << endl;
    }

    return 0;
}

void set(Student &sa, int n)
{
    cout << "Please enter the student's name: " << endl;
    getline(cin, sa);
    cout << "Please enter " << n << " quizzes scores: " << endl;
    for (int i = 0; i < n; i++){
        cin >> sa[i];           // 这里的 sa[i] 访问的是 Student对象里的[]重载运算符, 填充的是对象里面的 scores 数组
    }

    // 每当输入数字之后, 缓冲区都会存在一个多余的回车, 记得干掉.
    while(cin.get() != '\n');
}
```



