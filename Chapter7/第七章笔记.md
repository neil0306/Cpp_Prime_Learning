# 知识大纲
1. 函数基本知识
2. 函数原型
3. 按值传递函数参数
4. 设计处理数组的函数
5. 使用const指针参数
6. 设计处理本文字符串的函数
7. 设计处理结构的函数
8. 设计处理string对象函数
9. 调用自身的函数(递归)
10. 指向函数的指针


# 7.1 函数的基本知识
定义一个函数包含以下3点:
```cpp
1. 函数的定义
2. 函数的原型
3. 调用函数
```
库函数在 `.h` 头文件中已经完成了`函数的定义`和`函数的原型声明`, 我们使用时只需要`#include`这个头文件, 然后直接调用就行.

代码示例:
```cpp
//函数定义模板
typeName functionName(parameterList)        // typeName是返回类型, parameterList是参数列表
{
    statements;
    return value;           // 要与函数的返回类型匹配; 如果函数返回类型是void, 则可以不写return语句
}
```
- 注意:
  - C++中, 函数的返回值类型一定`不能是数组类型`, 但可以是其他任何类型 (`整数`,`浮点数`,`指针` 甚至是`结构`和`对象`!)
    - 不能是数组的原因是: C++中, `数组不能直接赋值给数组`(模板类里面定义了相关的函数进行对应元素的赋值, 是个例外情况, 默认情况下是没有定义处理数组元素赋值的函数的)

  - 关于函数返回类型匹配的简单比喻:
    - 如果函数中实际 return 了一个`西瓜`, 那么, 由于函数在声明的时候 typeName 就应该写成`西瓜`而不能是`土豆`, 否则其他人在调用这个函数的时候就会把函数的返回值存到一个`土豆`类型的变量里, 这显然是会报错的.

  - 函数体中`可以包含多条return语句`, 但是在执行时, 只要执行到其中的任何一条 return, 就会结束函数的调用, 并按照当前执行的 return 语句进行值的返回.

  - 如果把函数的定义直接写在代码文件的开头, 那么其实可以`省略不写函数的原型/声明`
    - 但是不建议这么做, 函数的原型/声明 是写给`编译器`看的, 这是在告诉编译器这个函数的"外观长什么样", 如果没有写函数的原型, 那么在其他文件中如果调用这个函数, 并且函数的定义可能不是位于代码文件的顶部位置, 此时就会报错, 总而言之, 这是一个潜在的引发编译错误的写法, 不建议使用.


为什么需要函数的原型?
![](第七章笔记_images/为什么需要函数的原型.png)

函数原型的语法
![](第七章笔记_images/函数原型的语法.png)


# 7.2 函数参数和按值传递

例子:
```cpp
//函数的声明
double cube (double x);
//函数的调用
double volume = cube (side);

```
- 在调用函数时, 编译器其实是把 side 赋值给了x, 在cube中我们处理的其实是 `side 的拷贝`, 而不是side本身, 这就是`按值传递`的含义.
  - 在这个例子中, x 被称为`形参`, side 被称为`实参`, 也就是说, `形参`是`实参`的一份拷贝.

- 按值传递的图示:
  ![](第七章笔记_images/图示_按值传递.png)

- 函数内部定义的变量叫做局部变量, 在函数调用结束时, 它们就会被销毁.
  - 局部变量的图示:
    ![](第七章笔记_images/图示_局部变量.png)

代码例子 (看 3.cpp, 4.cpp)


## 7.3 函数和数组
注意:
- 数组名相当于数组第一个元素在内存中的地址, 如果对数组名使用 `sizeof()`, 得到的将是整个数组的长度(以字节为单位)
  - 对指针使用 sizeof, 获得的是指针指向的内存块的大小
  - 使用 & 对数组名取地址, 得到的是数组的地址 (仍然是数组第一个元素的地址)

在`函数原型/函数声明`中, 使用数组表示法和普通指针来传递一个数组:
![](第七章笔记_images/函数传数组_数组表示法和普通指针.png)

牢记数组的两个恒等式:
```cpp
arr[i] == * (arr + i);  // * 用来取值
&arr[i] == arr + i;     // arr + i 表示指针偏移
```

传递常规变量时, 传递的是`该变量的副本/拷贝`, 如果传数组时, 传的是指针, 相当于是直接把原来的数组传进去了.
- 为了解决原始数组容易被修改的问题, 可以使用`const`关键字, 使得传入的数组在函数内部不能被修改.
  - 后面会讲解这个知识点


为什么传递数组的时候还顺便把数组里的元素个数也传进去?
- 看6.cpp代码例子
  - 在函数中如果用 sizeof 去计算数组的大小, 得到的是**指针的大小**, 而不是数组的大小. (说明给函数传数组时, 传进去的只是一个指针)
    - 此时我们只知道数组的开头, 并不知道数组的结尾在哪里, 所以无法计算数组的大小.
  - 6_cpp运行结果:
  ![](第七章笔记_images/6_cpp运行结果.png)

传递数组和它的大小时, 注意要分成两个参数去传:
  ![](第七章笔记_images/传递数组和它的大小时_注意要分成两个参数去传.png)


代码例子 -- 用区间的方式访问数组元素:
```cpp
/*
讲解知识点:
    用区间范围来实现数组的访问.
    使用STL中"超尾"的概念: 数组的 end指针 指向数组[最后一个元素]的下一个元素, 即合法的访问区间是一个"左闭右开"的区间 (和python访问list是一样的逻辑)
*/
#include <iostream>

using namespace std;

const int ArSize = 8;

int sum_arr(const int *begin, const int *end); // 正规写法是 int sum_arr (int * arr, int n)

int main(void)
{
    int cookies[ArSize] = {1, 2, 4, 8, 16, 32, 64, 128};

    int sum = sum_arr(cookies, cookies+ ArSize); // 传递一个数组给函数, 同时还传了个数

    cout << "Total cookies eaten: " << sum << endl;

    sum = sum_arr(cookies, cookies+3);
    cout << "First three eater are: " << sum << endl;

    sum = sum_arr(cookies+4, cookies+8);  // 计算后4个人一共吃多少
    cout << "Last four eater ate: " << sum << endl;

    return 0;
}

int sum_arr(const int *begin, const int *end)
{
    int total = 0;
    const int *pt;   // 用来匹配传入参数

    for ( pt = begin; pt < end; pt++)
    {
        total += *pt;       // 通过指针直接获得数组元素值
    }

    return total;
}
```



### 7.3.3 更多数组函数示例 (const 搭配数组指针做保护)

代码例子:
```cpp
/*
    数组指针用const做保护的例子
*/

#include <iostream>
const int Max = 5;

int fill_array(double arr[], int limit);
void show_array(const double arr[], int n);
void revaluate(double r, double arr[], int n);


using namespace std;

int main(void){

    double properties[Max];

    int size = fill_array(properties, Max);  // 录入
    
    show_array(properties, size);       // 回显

    if(size > 0){
        cout << "Enter revaluation factor: ";
        double factor;
        while(!(cin >> factor)){    // 检查cin是不是停止工作
            cin.clear();            // 清除cin的标志位
            while(cin.get() != '\n'){  // 清掉cin的缓冲区
                continue;
            }
            cout << "Bad input; Please enter a number: ";
        }
        revaluate(factor, properties, size); // 重新评估(重新写入数据)
        show_array(properties, size);       // 回显
    }


    return 0;
}


int fill_array(double arr[], int limit){
    double temp;
    int i = 0;
    for(; i < limit; i++){
        cout << "Enter value #" << (i + 1) << ": ";
        cin >> temp;
        if (!cin){  // 检查cin是不是停止工作
            cin.clear();  // 清楚cin的标志位
            while (cin.get() != '\n'){
                continue;
            }
            cout << "Bad input; input process terminated.\n";
            break;
        } else if( temp < 0 ){
            break;
        } else {
            arr[i] = temp;
        }
    }
    return i; // 返回成功录入的个数
}

void show_array(const double arr[], int n ){   // const 保护数组指针指向的内容
    for(int i = 0; i < n; i++){
        cout << "Property #" << (i + 1) << ": $";
        cout << arr[i] << endl;
    }
}
void revaluate(double r, double arr[], int n){

    for(int i = 0; i < n; i++){
        arr[i] *= r;
    }
}
```

const 的常见用法:
```cpp
const int *pt;  // pt指向的内容不能被修改, 但是pt本身可以修改         (*的左侧有 const)
int * const pt;  // pt指向的内容可以被修改, 但是pt本身不能修改        (*的右侧有 const)
const int * const pt;  // pt指向的内容不能被修改, pt本身也不能修改    (*的左右两侧都有 const)
```

代码例子1 -- const修饰的指针可以修改指针本身(修改指针指向的变量)但是不能通过这个指针修改内存块的值:
```cpp
/*
// pt指向的内容不能被修改, 但是pt本身可以修改
const int *pt;  <===> 等价于  int const *pt;   // const 在 * 的左侧
*/

#include <iostream>

using namespace std;

int main(void){

    int n = 10;
    int m = 100;
    // int *pt = &n;
    const int *pt = &n;     // 使用const之后, 下面的 *pt = 20 会报错
    cout << "1) n = " << n << endl;

    // *pt = 20;
    n = 100;  // 直接修改n的值是可以的, 但是不能通过 const 修饰过的指针进行修改
    cout << "2) n = " << n << endl;

    pt = &m;  // const 修饰过的 pt指针 本身可以修改, 但是不能通过这个指针去修改内存块里的东西
    cout << "*pt = " << *pt << endl;  // 此时 *pt = 100, 虽然有 const 修饰, 但是它已经指向别的内存块了
    cout << "m = " << m << endl;

    return 0;
}
```

代码例子2: 
```cpp
/*
int * const pt;  // pt指向的内容可以被修改, 但是pt本身不能修改
*/

#include <iostream>

using namespace std;

int main(void){

    int n = 10;
    int m = 100;
    int *const pt = &n;     // 注意: 此时const位于 * 的右侧, 此时指针变量不许修改

    cout << "1) n = " << n << endl;
    *pt = 20;               // 此时可以修改pt指针的内容
    cout << "2) n = " << n << endl;

    // pt = &m;                // 报错, 因为 pt 被 const 修饰, pt 是只读的, pt不能指向其它内存地址了 

    return 0;
}
```

注意:
- C++中, **禁止**将 `const 的内存地址(变量被const修饰)` 赋值给 `非const指针`!!!!
```cpp
const float g_earth = 9.80;
const float *pe = &g_earth;  // valid

const float g_moon = 1.63;
float * pm = &g_moon;     // invalid
```
 - 在第十五章中, 会介绍一种方法突破这个限制 --> 利用强制类型转换


二级指针中使用 const 的例子:
```cpp
int age = 39;  // age++ is a valid operation
int * pd = &age;  // *pd = 41 is a valid operation
const int * pt = &age;  // *pt = 41 is an invalid operation   ==> const 在*号的左侧, 表示指针不能用于修改内存块的内容
``` 
- 上面的代码例子是 `一级间接关系`, 这时候还算安全; 如果换成`二级间接关系`的话, 非const指针**也是无法赋值**给const指针的, 因为这个操作不安全, 例子如下:
```cpp
const int ** pp2;  // pp2本身是一个地址, 这个地址在内存块中存放的是一个指针(也是一个地址)
int *p1;
const int n = 13;
pp2 = &p1;  // invalid, 因为这个操作不安全, 二级间接关系里不能将非const指针赋值给const指针 
*pp2 = &n;   // valid, 因为这个操作是安全的, 将 const修饰的内存块地址 赋值给 const指针
*p1 = 10;    // valid, 因为这个操作是安全的, p1 指针没有任何修饰, 它指向的内存块可以被修改
```
 - 这个例子里为什么 `pp2 = &p1` 不合法呢? 
   - 首先, const 在*号**左侧**, 表示这个指针**不能**用于修改内存块的内容
   - 然后, 由于`*pp2 = &n;`绝对是合法的, 这是两个const指针互相赋值, 它们都只**限制了内存块的内容不可修改**, 指针变量存放的地址是可以改的.
   - 随后, 又看到`p1指针对应的内存块`没有做任何限制(因为 *p1 = 10 是合法的), 那么这个**p1指针里的地址**对应的**内存块是可以被修改**的
   - 此时, 如果`pp2 = &p1`合法的话, 就会出现逻辑冲突, p1指针对应的内存块是能改还是不能改?? 

小结:
  - 一级指针(一级间接关系) 不能将 `const变量的地址` 赋值给 `非const指针`
  - 二级指针(二级间接关系) **不可以** 进行`const指针`与`非const指针`之间的赋值. 

建议:
- **如果当前使用的指针不用于修改内存块的内容**, 则`一律给指针加上const`, 加了const之后, 它不仅可以处理 const修饰的变量的地址, 也能处理 非const修饰的变量的地址. 同时, 还保护了这个变量, 防止误改.




## 7.4 函数和二维数组

直接看例子:
```cpp
// 例子1:
int sum(int (*ar2)[4], int size);   

/* 
  1. (*ar2) 是一个指针, 它指向了一个 由4个int元素组成的数组, 因此, ar2就变成了一个二维数组的指针.
  2. *ar2 的括号是不能漏掉的!! 因为从**运算优先级**来看, 方括号[]的优先级要比 * 高, 如果不加括号, 那么就变成了一个指向 4个int元素的数组 的指针了.
  3. size 代表行数, 因为二维数组中, 我们是把每一行元素当做一个一维数组来处理的
*/


// 例子2:
int sum(int ar2[][4], int size);  // 与例子1等价, 但可读性更高

/*
  ar2 仍然是一个指针!
*/
```

访问二维数组的元素:
- 先遍历行, 再遍历列.   (因为我们传参的时候一般都是传入数组的行数)

```cpp
int sum(int ar2[][4], int size)
{
  int total = 0;
  for(int r = 0; r < size; r++)   // 先遍历行
    for(int c = 0; c < 4; c++)    // 再遍历列
      total += ar2[r][c];
      // 另一种较难看的取元素值的写法:  *(*(ar2 + r) + c)
}
```
关于用指针取二维数组值的说明:
```cpp
ar2        // 这里是一个二维数组的指针, 数组名同时还是"数组中第一行元素的首地址"
ar2 + r    // 这里也是一个指针, 它指向了二维数组中的 [第r行]
*(ar2 + r) // 这里是一个一维数组的指针, 它指向了二维数组中的 [第r行] 的首地址; 等同于 ar2[r]

*(ar2 + r) + c    // 这里是一个指针, 它指向了二维数组中的 [第r行] 的 [第c列]
*(*(ar2 + r) + c) // 这里是一个int类型的值, 它就是二维数组中的 [第r行] 的 [第c列] 的值; 等同于 ar2[r][c]
```

代码示例 -- 9.cpp:
```cpp
/*
    写一个函数, 返回一个字符串中出现了多少个指定的字符.
*/
#include <iostream>

using namespace std;

unsigned int c_in_str(const char *str, char ch);

int main(void)
{
    char mmm[15] = "minimum";
    // char *wail = "ululate"; //  这样写会报错的, 因为"ululate"此时是 const 类型, 如果允许的话, 就会存在 wail 指针修改了常量的风险
    const char *wail = "ululate";   // 还可以写成强制类型转换 char *wail = (char *) "ululate";  但是不太推荐

    unsigned int ms = c_in_str(mmm, 'm');
    unsigned int us = c_in_str(wail, 'u');   

    cout << ms << " m characters in " << mmm << endl;
    cout << us << " u characters in " << wail << endl;


    return 0;
}

unsigned int c_in_str(const char *str, char ch)  // 因为我们不希望数组在这个函数中被不慎修改, 这里加一个cosnt做保护
{
    unsigned sum = 0;

    while(*str)   // 这样写表示: 一直遍历数组元素, 没有到最后一个元素就继续循环
    {
        if(*str == ch)
            sum++;
        str++;    // 移动到下一个元素, 遍历到最后一个元素时, 它的内容是一个空白字符 '\0'
    }

    return sum;
}
```

