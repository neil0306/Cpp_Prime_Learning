# 知识大纲
1. 函数基本知识
2. 函数原型
3. 按值传递函数参数
4. 设计处理数组的函数
5. 使用const指针参数
6. 设计处理本文字符串的函数
7. 设计处理结构的函数
8. 设计处理string对象函数
9. 调用自身的函数(递归)
10. 指向函数的指针


# 7.1 函数的基本知识
定义一个函数包含以下3点:
```cpp
1. 函数的定义
2. 函数的原型
3. 调用函数
```
库函数在 `.h` 头文件中已经完成了`函数的定义`和`函数的原型声明`, 我们使用时只需要`#include`这个头文件, 然后直接调用就行.

代码示例:
```cpp
//函数定义模板
typeName functionName(parameterList)        // typeName是返回类型, parameterList是参数列表
{
    statements;
    return value;           // 要与函数的返回类型匹配; 如果函数返回类型是void, 则可以不写return语句
}
```
- 注意:
  - C++中, 函数的返回值类型一定`不能是数组类型`, 但可以是其他任何类型 (`整数`,`浮点数`,`指针` 甚至是`结构`和`对象`!)
    - 不能是数组的原因是: C++中, `数组不能直接赋值给数组`(模板类里面定义了相关的函数进行对应元素的赋值, 是个例外情况, 默认情况下是没有定义处理数组元素赋值的函数的)

  - 关于函数返回类型匹配的简单比喻:
    - 如果函数中实际 return 了一个`西瓜`, 那么, 由于函数在声明的时候 typeName 就应该写成`西瓜`而不能是`土豆`, 否则其他人在调用这个函数的时候就会把函数的返回值存到一个`土豆`类型的变量里, 这显然是会报错的.

  - 函数体中`可以包含多条return语句`, 但是在执行时, 只要执行到其中的任何一条 return, 就会结束函数的调用, 并按照当前执行的 return 语句进行值的返回.

  - 如果把函数的定义直接写在代码文件的开头, 那么其实可以`省略不写函数的原型/声明`
    - 但是不建议这么做, 函数的原型/声明 是写给`编译器`看的, 这是在告诉编译器这个函数的"外观长什么样", 如果没有写函数的原型, 那么在其他文件中如果调用这个函数, 并且函数的定义可能不是位于代码文件的顶部位置, 此时就会报错, 总而言之, 这是一个潜在的引发编译错误的写法, 不建议使用.


为什么需要函数的原型?
![](第七章笔记_images/为什么需要函数的原型.png)

函数原型的语法
![](第七章笔记_images/函数原型的语法.png)


# 7.2 函数参数和按值传递

例子:
```cpp
//函数的声明
double cube (double x);
//函数的调用
double volume = cube (side);

```
- 在调用函数时, 编译器其实是把 side 赋值给了x, 在cube中我们处理的其实是 `side 的拷贝`, 而不是side本身, 这就是`按值传递`的含义.
  - 在这个例子中, x 被称为`形参`, side 被称为`实参`, 也就是说, `形参`是`实参`的一份拷贝.

- 按值传递的图示:
  ![](第七章笔记_images/图示_按值传递.png)

- 函数内部定义的变量叫做局部变量, 在函数调用结束时, 它们就会被销毁.
  - 局部变量的图示:
    ![](第七章笔记_images/图示_局部变量.png)

代码例子 (看 3.cpp, 4.cpp)


## 7.3 函数和数组
注意:
- 数组名相当于数组第一个元素在内存中的地址, 如果对数组名使用 `sizeof()`, 得到的将是整个数组的长度(以字节为单位)
  - 对指针使用 sizeof, 获得的是指针指向的内存块的大小
  - 使用 & 对数组名取地址, 得到的是数组的地址 (仍然是数组第一个元素的地址)

在`函数原型/函数声明`中, 使用数组表示法和普通指针来传递一个数组:
![](第七章笔记_images/函数传数组_数组表示法和普通指针.png)

牢记数组的两个恒等式:
```cpp
arr[i] == * (arr + i);  // * 用来取值
&arr[i] == arr + i;     // arr + i 表示指针偏移
```

传递常规变量时, 传递的是`该变量的副本/拷贝`, 如果传数组时, 传的是指针, 相当于是直接把原来的数组传进去了.
- 为了解决原始数组容易被修改的问题, 可以使用`const`关键字, 使得传入的数组在函数内部不能被修改.
  - 后面会讲解这个知识点


为什么传递数组的时候还顺便把数组里的元素个数也传进去?
- 看6.cpp代码例子
  - 在函数中如果用 sizeof 去计算数组的大小, 得到的是**指针的大小**, 而不是数组的大小. (说明给函数传数组时, 传进去的只是一个指针)
    - 此时我们只知道数组的开头, 并不知道数组的结尾在哪里, 所以无法计算数组的大小.
  - 6_cpp运行结果:
  ![](第七章笔记_images/6_cpp运行结果.png)

传递数组和它的大小时, 注意要分成两个参数去传:
  ![](第七章笔记_images/传递数组和它的大小时_注意要分成两个参数去传.png)
