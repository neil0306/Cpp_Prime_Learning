<!DOCTYPE html>
<html>
<head>
<title>第七章笔记.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="file:///Users/laining/Downloads/Cpp_Prime_Learning/markdown_style_css_files/markdown.css" type="text/css">
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E7%9F%A5%E8%AF%86%E5%A4%A7%E7%BA%B2">知识大纲</h1>
<ol>
<li>函数基本知识</li>
<li>函数原型</li>
<li>按值传递函数参数</li>
<li>设计处理数组的函数</li>
<li>使用const指针参数</li>
<li>设计处理本文字符串的函数</li>
<li>设计处理结构的函数</li>
<li>设计处理string对象函数</li>
<li>调用自身的函数(递归)</li>
<li>指向函数的指针</li>
</ol>
<h1 id="71-%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86">7.1 函数的基本知识</h1>
<p>定义一个函数包含以下3点:</p>
<pre class="hljs"><code><div><span class="hljs-number">1.</span> 函数的定义
<span class="hljs-number">2.</span> 函数的原型
<span class="hljs-number">3.</span> 调用函数
</div></code></pre>
<p>库函数在 <code>.h</code> 头文件中已经完成了<code>函数的定义</code>和<code>函数的原型声明</code>, 我们使用时只需要<code>#include</code>这个头文件, 然后直接调用就行.</p>
<p>代码示例:</p>
<pre class="hljs"><code><div><span class="hljs-comment">//函数定义模板</span>
<span class="hljs-function">typeName <span class="hljs-title">functionName</span><span class="hljs-params">(parameterList)</span>        <span class="hljs-comment">// typeName是返回类型, parameterList是参数列表</span>
</span>{
    statements;
    <span class="hljs-keyword">return</span> value;           <span class="hljs-comment">// 要与函数的返回类型匹配; 如果函数返回类型是void, 则可以不写return语句</span>
}
</div></code></pre>
<ul>
<li>注意:
<ul>
<li>
<p>C++中, 函数的返回值类型一定<code>不能是数组类型</code>, 但可以是其他任何类型 (<code>整数</code>,<code>浮点数</code>,<code>指针</code> 甚至是<code>结构</code>和<code>对象</code>!)</p>
<ul>
<li>不能是数组的原因是: C++中, <code>数组不能直接赋值给数组</code>(模板类里面定义了相关的函数进行对应元素的赋值, 是个例外情况, 默认情况下是没有定义处理数组元素赋值的函数的)</li>
</ul>
</li>
<li>
<p>关于函数返回类型匹配的简单比喻:</p>
<ul>
<li>如果函数中实际 return 了一个<code>西瓜</code>, 那么, 由于函数在声明的时候 typeName 就应该写成<code>西瓜</code>而不能是<code>土豆</code>, 否则其他人在调用这个函数的时候就会把函数的返回值存到一个<code>土豆</code>类型的变量里, 这显然是会报错的.</li>
</ul>
</li>
<li>
<p>函数体中<code>可以包含多条return语句</code>, 但是在执行时, 只要执行到其中的任何一条 return, 就会结束函数的调用, 并按照当前执行的 return 语句进行值的返回.</p>
</li>
<li>
<p>如果把函数的定义直接写在代码文件的开头, 那么其实可以<code>省略不写函数的原型/声明</code></p>
<ul>
<li>但是不建议这么做, 函数的原型/声明 是写给<code>编译器</code>看的, 这是在告诉编译器这个函数的&quot;外观长什么样&quot;, 如果没有写函数的原型, 那么在其他文件中如果调用这个函数, 并且函数的定义可能不是位于代码文件的顶部位置, 此时就会报错, 总而言之, 这是一个潜在的引发编译错误的写法, 不建议使用.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>为什么需要函数的原型?<br>
<img src="file:///Users/laining/Downloads/Cpp_Prime_Learning/Chapter7/第七章笔记_images/为什么需要函数的原型.png" alt=""></p>
<p>函数原型的语法<br>
<img src="file:///Users/laining/Downloads/Cpp_Prime_Learning/Chapter7/第七章笔记_images/函数原型的语法.png" alt=""></p>
<h1 id="72-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92">7.2 函数参数和按值传递</h1>
<p>例子:</p>
<pre class="hljs"><code><div><span class="hljs-comment">//函数的声明</span>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cube</span> <span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span></span>;
<span class="hljs-comment">//函数的调用</span>
<span class="hljs-keyword">double</span> volume = cube (side);

</div></code></pre>
<ul>
<li>
<p>在调用函数时, 编译器其实是把 side 赋值给了x, 在cube中我们处理的其实是 <code>side 的拷贝</code>, 而不是side本身, 这就是<code>按值传递</code>的含义.</p>
<ul>
<li>在这个例子中, x 被称为<code>形参</code>, side 被称为<code>实参</code>, 也就是说, <code>形参</code>是<code>实参</code>的一份拷贝.</li>
</ul>
</li>
<li>
<p>按值传递的图示:<br>
<img src="file:///Users/laining/Downloads/Cpp_Prime_Learning/Chapter7/第七章笔记_images/图示_按值传递.png" alt=""></p>
</li>
<li>
<p>函数内部定义的变量叫做局部变量, 在函数调用结束时, 它们就会被销毁.</p>
<ul>
<li>局部变量的图示:<br>
<img src="file:///Users/laining/Downloads/Cpp_Prime_Learning/Chapter7/第七章笔记_images/图示_局部变量.png" alt=""></li>
</ul>
</li>
</ul>
<p>代码例子 (看 3.cpp, 4.cpp)</p>
<h2 id="73-%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E7%BB%84">7.3 函数和数组</h2>
<p>注意:</p>
<ul>
<li>数组名相当于数组第一个元素在内存中的地址, 如果对数组名使用 <code>sizeof()</code>, 得到的将是整个数组的长度(以字节为单位)
<ul>
<li>对指针使用 sizeof, 获得的是指针指向的内存块的大小</li>
<li>使用 &amp; 对数组名取地址, 得到的是数组的地址 (仍然是数组第一个元素的地址)</li>
</ul>
</li>
</ul>
<p>在<code>函数原型/函数声明</code>中, 使用数组表示法和普通指针来传递一个数组:<br>
<img src="file:///Users/laining/Downloads/Cpp_Prime_Learning/Chapter7/第七章笔记_images/函数传数组_数组表示法和普通指针.png" alt=""></p>
<p>牢记数组的两个恒等式:</p>
<pre class="hljs"><code><div>arr[i] == * (arr + i);  <span class="hljs-comment">// * 用来取值</span>
&amp;arr[i] == arr + i;     <span class="hljs-comment">// arr + i 表示指针偏移</span>
</div></code></pre>
<p>传递常规变量时, 传递的是<code>该变量的副本/拷贝</code>, 如果传数组时, 传的是指针, 相当于是直接把原来的数组传进去了.</p>
<ul>
<li>为了解决原始数组容易被修改的问题, 可以使用<code>const</code>关键字, 使得传入的数组在函数内部不能被修改.
<ul>
<li>后面会讲解这个知识点</li>
</ul>
</li>
</ul>
<p>为什么传递数组的时候还顺便把数组里的元素个数也传进去?</p>
<ul>
<li>看6.cpp代码例子
<ul>
<li>在函数中如果用 sizeof 去计算数组的大小, 得到的是<strong>指针的大小</strong>, 而不是数组的大小. (说明给函数传数组时, 传进去的只是一个指针)
<ul>
<li>此时我们只知道数组的开头, 并不知道数组的结尾在哪里, 所以无法计算数组的大小.</li>
</ul>
</li>
<li>6_cpp运行结果:<br>
<img src="file:///Users/laining/Downloads/Cpp_Prime_Learning/Chapter7/第七章笔记_images/6_cpp运行结果.png" alt=""></li>
</ul>
</li>
</ul>
<p>传递数组和它的大小时, 注意要分成两个参数去传:<br>
<img src="file:///Users/laining/Downloads/Cpp_Prime_Learning/Chapter7/第七章笔记_images/传递数组和它的大小时_注意要分成两个参数去传.png" alt=""></p>
<p>代码例子 -- 用区间的方式访问数组元素:</p>
<pre class="hljs"><code><div><span class="hljs-comment">/*
讲解知识点:
    用区间范围来实现数组的访问.
    使用STL中"超尾"的概念: 数组的 end指针 指向数组[最后一个元素]的下一个元素, 即合法的访问区间是一个"左闭右开"的区间 (和python访问list是一样的逻辑)
*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ArSize = <span class="hljs-number">8</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum_arr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *begin, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *end)</span></span>; <span class="hljs-comment">// 正规写法是 int sum_arr (int * arr, int n)</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-keyword">int</span> cookies[ArSize] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">128</span>};

    <span class="hljs-keyword">int</span> sum = sum_arr(cookies, cookies+ ArSize); <span class="hljs-comment">// 传递一个数组给函数, 同时还传了个数</span>

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Total cookies eaten: "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">endl</span>;

    sum = sum_arr(cookies, cookies+<span class="hljs-number">3</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"First three eater are: "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">endl</span>;

    sum = sum_arr(cookies+<span class="hljs-number">4</span>, cookies+<span class="hljs-number">8</span>);  <span class="hljs-comment">// 计算后4个人一共吃多少</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Last four eater ate: "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum_arr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *begin, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *end)</span>
</span>{
    <span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *pt;   <span class="hljs-comment">// 用来匹配传入参数</span>

    <span class="hljs-keyword">for</span> ( pt = begin; pt &lt; end; pt++)
    {
        total += *pt;       <span class="hljs-comment">// 通过指针直接获得数组元素值</span>
    }

    <span class="hljs-keyword">return</span> total;
}
</div></code></pre>
<h3 id="733-%E6%9B%B4%E5%A4%9A%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B-const-%E6%90%AD%E9%85%8D%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%81%9A%E4%BF%9D%E6%8A%A4">7.3.3 更多数组函数示例 (const 搭配数组指针做保护)</h3>
<p>代码例子:</p>
<pre class="hljs"><code><div><span class="hljs-comment">/*
    数组指针用const做保护的例子
*/</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Max = <span class="hljs-number">5</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fill_array</span><span class="hljs-params">(<span class="hljs-keyword">double</span> arr[], <span class="hljs-keyword">int</span> limit)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_array</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> arr[], <span class="hljs-keyword">int</span> n)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">revaluate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r, <span class="hljs-keyword">double</span> arr[], <span class="hljs-keyword">int</span> n)</span></span>;


<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{

    <span class="hljs-keyword">double</span> properties[Max];

    <span class="hljs-keyword">int</span> size = fill_array(properties, Max);  <span class="hljs-comment">// 录入</span>
    
    show_array(properties, size);       <span class="hljs-comment">// 回显</span>

    <span class="hljs-keyword">if</span>(size &gt; <span class="hljs-number">0</span>){
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter revaluation factor: "</span>;
        <span class="hljs-keyword">double</span> factor;
        <span class="hljs-keyword">while</span>(!(<span class="hljs-built_in">cin</span> &gt;&gt; factor)){    <span class="hljs-comment">// 检查cin是不是停止工作</span>
            <span class="hljs-built_in">cin</span>.clear();            <span class="hljs-comment">// 清除cin的标志位</span>
            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>.get() != <span class="hljs-string">'\n'</span>){  <span class="hljs-comment">// 清掉cin的缓冲区</span>
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Bad input; Please enter a number: "</span>;
        }
        revaluate(factor, properties, size); <span class="hljs-comment">// 重新评估(重新写入数据)</span>
        show_array(properties, size);       <span class="hljs-comment">// 回显</span>
    }


    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}


<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fill_array</span><span class="hljs-params">(<span class="hljs-keyword">double</span> arr[], <span class="hljs-keyword">int</span> limit)</span></span>{
    <span class="hljs-keyword">double</span> temp;
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(; i &lt; limit; i++){
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter value #"</span> &lt;&lt; (i + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">": "</span>;
        <span class="hljs-built_in">cin</span> &gt;&gt; temp;
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">cin</span>){  <span class="hljs-comment">// 检查cin是不是停止工作</span>
            <span class="hljs-built_in">cin</span>.clear();  <span class="hljs-comment">// 清楚cin的标志位</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span>.get() != <span class="hljs-string">'\n'</span>){
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Bad input; input process terminated.\n"</span>;
            <span class="hljs-keyword">break</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( temp &lt; <span class="hljs-number">0</span> ){
            <span class="hljs-keyword">break</span>;
        } <span class="hljs-keyword">else</span> {
            arr[i] = temp;
        }
    }
    <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 返回成功录入的个数</span>
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_array</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> arr[], <span class="hljs-keyword">int</span> n )</span></span>{   <span class="hljs-comment">// const 保护数组指针指向的内容</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Property #"</span> &lt;&lt; (i + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">": $"</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">revaluate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r, <span class="hljs-keyword">double</span> arr[], <span class="hljs-keyword">int</span> n)</span></span>{

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){
        arr[i] *= r;
    }
}
</div></code></pre>
<p>const 的常见用法:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *pt;  <span class="hljs-comment">// pt指向的内容不能被修改, 但是pt本身可以修改         (*的左侧有 const)</span>
<span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> pt;  <span class="hljs-comment">// pt指向的内容可以被修改, 但是pt本身不能修改        (*的右侧有 const)</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> pt;  <span class="hljs-comment">// pt指向的内容不能被修改, pt本身也不能修改    (*的左右两侧都有 const)</span>
</div></code></pre>
<p>代码例子1 -- const修饰的指针可以修改指针本身(修改指针指向的变量)但是不能通过这个指针修改内存块的值:</p>
<pre class="hljs"><code><div><span class="hljs-comment">/*
// pt指向的内容不能被修改, 但是pt本身可以修改
const int *pt;  &lt;===&gt; 等价于  int const *pt;   // const 在 * 的左侧
*/</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{

    <span class="hljs-keyword">int</span> n = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> m = <span class="hljs-number">100</span>;
    <span class="hljs-comment">// int *pt = &amp;n;</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *pt = &amp;n;     <span class="hljs-comment">// 使用const之后, 下面的 *pt = 20 会报错</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"1) n = "</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// *pt = 20;</span>
    n = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 直接修改n的值是可以的, 但是不能通过 const 修饰过的指针进行修改</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2) n = "</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>;

    pt = &amp;m;  <span class="hljs-comment">// const 修饰过的 pt指针 本身可以修改, 但是不能通过这个指针去修改内存块里的东西</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"*pt = "</span> &lt;&lt; *pt &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 此时 *pt = 100, 虽然有 const 修饰, 但是它已经指向别的内存块了</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"m = "</span> &lt;&lt; m &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>代码例子2:</p>
<pre class="hljs"><code><div><span class="hljs-comment">/*
int * const pt;  // pt指向的内容可以被修改, 但是pt本身不能修改
*/</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{

    <span class="hljs-keyword">int</span> n = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> m = <span class="hljs-number">100</span>;
    <span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> pt = &amp;n;     <span class="hljs-comment">// 注意: 此时const位于 * 的右侧, 此时指针变量不许修改</span>

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"1) n = "</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>;
    *pt = <span class="hljs-number">20</span>;               <span class="hljs-comment">// 此时可以修改pt指针的内容</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2) n = "</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// pt = &amp;m;                // 报错, 因为 pt 被 const 修饰, pt 是只读的, pt不能指向其它内存地址了 </span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>注意:</p>
<ul>
<li>C++中, <strong>禁止</strong>将 <code>const 的内存地址(变量被const修饰)</code> 赋值给 <code>非const指针</code>!!!!</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> g_earth = <span class="hljs-number">9.80</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> *pe = &amp;g_earth;  <span class="hljs-comment">// valid</span>

<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> g_moon = <span class="hljs-number">1.63</span>;
<span class="hljs-keyword">float</span> * pm = &amp;g_moon;     <span class="hljs-comment">// invalid</span>
</div></code></pre>
<ul>
<li>在第十五章中, 会介绍一种方法突破这个限制 --&gt; 利用强制类型转换</li>
</ul>
<p>二级指针中使用 const 的例子:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> age = <span class="hljs-number">39</span>;  <span class="hljs-comment">// age++ is a valid operation</span>
<span class="hljs-keyword">int</span> * pd = &amp;age;  <span class="hljs-comment">// *pd = 41 is a valid operation</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * pt = &amp;age;  <span class="hljs-comment">// *pt = 41 is an invalid operation   ==&gt; const 在*号的左侧, 表示指针不能用于修改内存块的内容</span>
</div></code></pre>
<ul>
<li>上面的代码例子是 <code>一级间接关系</code>, 这时候还算安全; 如果换成<code>二级间接关系</code>的话, 非const指针<strong>也是无法赋值</strong>给const指针的, 因为这个操作不安全, 例子如下:</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ** pp2;  <span class="hljs-comment">// pp2本身是一个地址, 这个地址在内存块中存放的是一个指针(也是一个地址)</span>
<span class="hljs-keyword">int</span> *p1;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">13</span>;
pp2 = &amp;p1;  <span class="hljs-comment">// invalid, 因为这个操作不安全, 二级间接关系里不能将非const指针赋值给const指针 </span>
*pp2 = &amp;n;   <span class="hljs-comment">// valid, 因为这个操作是安全的, 将 const修饰的内存块地址 赋值给 const指针</span>
*p1 = <span class="hljs-number">10</span>;    <span class="hljs-comment">// valid, 因为这个操作是安全的, p1 指针没有任何修饰, 它指向的内存块可以被修改</span>
</div></code></pre>
<ul>
<li>这个例子里为什么 <code>pp2 = &amp;p1</code> 不合法呢?
<ul>
<li>首先, const 在*号<strong>左侧</strong>, 表示这个指针<strong>不能</strong>用于修改内存块的内容</li>
<li>然后, 由于<code>*pp2 = &amp;n;</code>绝对是合法的, 这是两个const指针互相赋值, 它们都只<strong>限制了内存块的内容不可修改</strong>, 指针变量存放的地址是可以改的.</li>
<li>随后, 又看到<code>p1指针对应的内存块</code>没有做任何限制(因为 *p1 = 10 是合法的), 那么这个<strong>p1指针里的地址</strong>对应的<strong>内存块是可以被修改</strong>的</li>
<li>此时, 如果<code>pp2 = &amp;p1</code>合法的话, 就会出现逻辑冲突, p1指针对应的内存块是能改还是不能改??</li>
</ul>
</li>
</ul>
<p>小结:</p>
<ul>
<li>一级指针(一级间接关系) 不能将 <code>const变量的地址</code> 赋值给 <code>非const指针</code></li>
<li>二级指针(二级间接关系) <strong>不可以</strong> 进行<code>const指针</code>与<code>非const指针</code>之间的赋值.</li>
</ul>
<p>建议:</p>
<ul>
<li><strong>如果当前使用的指针不用于修改内存块的内容</strong>, 则<code>一律给指针加上const</code>, 加了const之后, 它不仅可以处理 const修饰的变量的地址, 也能处理 非const修饰的变量的地址. 同时, 还保护了这个变量, 防止误改.</li>
</ul>
<h2 id="74-%E5%87%BD%E6%95%B0%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">7.4 函数和二维数组</h2>
<p>直接看例子:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 例子1:</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*ar2)[<span class="hljs-number">4</span>], <span class="hljs-keyword">int</span> size)</span></span>;   

<span class="hljs-comment">/* 
  1. (*ar2) 是一个指针, 它指向了一个 由4个int元素组成的数组, 因此, ar2就变成了一个二维数组的指针.
  2. *ar2 的括号是不能漏掉的!! 因为从**运算优先级**来看, 方括号[]的优先级要比 * 高, 如果不加括号, 那么就变成了一个指向 4个int元素的数组 的指针了.
  3. size 代表行数, 因为二维数组中, 我们是把每一行元素当做一个一维数组来处理的
*/</span>


<span class="hljs-comment">// 例子2:</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar2[][<span class="hljs-number">4</span>], <span class="hljs-keyword">int</span> size)</span></span>;  <span class="hljs-comment">// 与例子1等价, 但可读性更高</span>

<span class="hljs-comment">/*
  ar2 仍然是一个指针!
*/</span>
</div></code></pre>
<p>访问二维数组的元素:</p>
<ul>
<li>先遍历行, 再遍历列.   (因为我们传参的时候一般都是传入数组的行数)</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ar2[][<span class="hljs-number">4</span>], <span class="hljs-keyword">int</span> size)</span>
</span>{
  <span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; size; r++)   <span class="hljs-comment">// 先遍历行</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">4</span>; c++)    <span class="hljs-comment">// 再遍历列</span>
      total += ar2[r][c];
      <span class="hljs-comment">// 另一种较难看的取元素值的写法:  *(*(ar2 + r) + c)</span>
}
</div></code></pre>
<p>关于用指针取二维数组值的说明:</p>
<pre class="hljs"><code><div>ar2        <span class="hljs-comment">// 这里是一个二维数组的指针, 数组名同时还是"数组中第一行元素的首地址"</span>
ar2 + r    <span class="hljs-comment">// 这里也是一个指针, 它指向了二维数组中的 [第r行]</span>
*(ar2 + r) <span class="hljs-comment">// 这里是一个一维数组的指针, 它指向了二维数组中的 [第r行] 的首地址; 等同于 ar2[r]</span>

*(ar2 + r) + c    <span class="hljs-comment">// 这里是一个指针, 它指向了二维数组中的 [第r行] 的 [第c列]</span>
*(*(ar2 + r) + c) <span class="hljs-comment">// 这里是一个int类型的值, 它就是二维数组中的 [第r行] 的 [第c列] 的值; 等同于 ar2[r][c]</span>
</div></code></pre>
<p>代码示例 -- 9.cpp:</p>
<pre class="hljs"><code><div><span class="hljs-comment">/*
    写一个函数, 返回一个字符串中出现了多少个指定的字符.
*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">c_in_str</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> ch)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-keyword">char</span> mmm[<span class="hljs-number">15</span>] = <span class="hljs-string">"minimum"</span>;
    <span class="hljs-comment">// char *wail = "ululate"; //  这样写会报错的, 因为"ululate"此时是 const 类型, 如果允许的话, 就会存在 wail 指针修改了常量的风险</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *wail = <span class="hljs-string">"ululate"</span>;   <span class="hljs-comment">// 还可以写成强制类型转换 char *wail = (char *) "ululate";  但是不太推荐</span>

    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ms = c_in_str(mmm, <span class="hljs-string">'m'</span>);
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> us = c_in_str(wail, <span class="hljs-string">'u'</span>);   

    <span class="hljs-built_in">cout</span> &lt;&lt; ms &lt;&lt; <span class="hljs-string">" m characters in "</span> &lt;&lt; mmm &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; us &lt;&lt; <span class="hljs-string">" u characters in "</span> &lt;&lt; wail &lt;&lt; <span class="hljs-built_in">endl</span>;


    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">c_in_str</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> ch)</span>  <span class="hljs-comment">// 因为我们不希望数组在这个函数中被不慎修改, 这里加一个cosnt做保护</span>
</span>{
    <span class="hljs-keyword">unsigned</span> sum = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span>(*str)   <span class="hljs-comment">// 这样写表示: 一直遍历数组元素, 没有到最后一个元素就继续循环</span>
    {
        <span class="hljs-keyword">if</span>(*str == ch)
            sum++;
        str++;    <span class="hljs-comment">// 移动到下一个元素, 遍历到最后一个元素时, 它的内容是一个空白字符 '\0'</span>
    }

    <span class="hljs-keyword">return</span> sum;
}
</div></code></pre>
<h1 id="76-%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93">7.6 函数和结构(体)</h1>
<ul>
<li>
<p>结构体支持对拷, 所以可以直接把一个结构体赋值给另一个结构体(注意数组不可以对拷), 因此, 结构体传入数组时, <code>传入的是结构体的拷贝</code>.</p>
<ul>
<li>如果结构体比较大, 那么在拷贝时就需要消耗不少性能.</li>
</ul>
</li>
<li>
<p>函数也可以直接返回结构体.</p>
</li>
<li>
<p>结构体名字不代表它的地址(数组的名字同时表示数组第一个元素的地址), 要获取结构体的地址, 需要使用 &quot;取址运算符 &amp;&quot;</p>
</li>
</ul>
<p>代码例子 -- 传递和返回结构体:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MIN_PER_HOUR = <span class="hljs-number">60</span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">travel_time</span>
{</span>
    <span class="hljs-keyword">int</span> hours;
    <span class="hljs-keyword">int</span> mins;
};                  <span class="hljs-comment">// 别忘了分号!</span>

<span class="hljs-function">travel_time <span class="hljs-title">sum</span><span class="hljs-params">(travel_time, travel_time)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_time</span><span class="hljs-params">(travel_time t)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    travel_time day1 = {<span class="hljs-number">5</span>, <span class="hljs-number">45</span>};
    travel_time day2 = {<span class="hljs-number">4</span>, <span class="hljs-number">55</span>};

    travel_time trip = sum(day1, day2);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Two days total: "</span>;
    show_time(trip);

    travel_time day3 = {<span class="hljs-number">4</span>, <span class="hljs-number">32</span>};

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Three days total: "</span>;
    show_time(sum(trip, day3));

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function">travel_time <span class="hljs-title">sum</span><span class="hljs-params">(travel_time t1, travel_time t2)</span>
</span>{
    travel_time total;

    total.mins = (t1.mins + t2.mins) % MIN_PER_HOUR;
    total.hours = t1.hours + t2.hours + (t1.mins + t2.mins) / <span class="hljs-number">60</span>;   <span class="hljs-comment">// 进位</span>
    <span class="hljs-keyword">return</span> total;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_time</span><span class="hljs-params">(travel_time t)</span>
</span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; t.hours &lt;&lt; <span class="hljs-string">" Hours, "</span> &lt;&lt; t.mins &lt;&lt; <span class="hljs-string">" Minutes."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<p>代码示例2</p>
<pre class="hljs"><code><div><span class="hljs-comment">/*
    输入 xy 坐标, 输出极坐标
*/</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">polar</span>   // 极坐标
{</span>
    <span class="hljs-keyword">double</span> distance;
    <span class="hljs-keyword">double</span> angle;
};


<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rect</span>     // 笛卡尔坐标
{</span>
    <span class="hljs-keyword">double</span> x;
    <span class="hljs-keyword">double</span> y;
};


<span class="hljs-function">polar <span class="hljs-title">rect_to_polar</span><span class="hljs-params">(rect xypos)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_polar</span><span class="hljs-params">(polar dapos)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    rect rplace;
    polar pplace;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Please the x and y values: "</span>;

    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; rplace.x  &gt;&gt; rplace.y)  <span class="hljs-comment">// 连续输入</span>
    {
        pplace = rect_to_polar(rplace);
        show_polar(pplace);

        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Next two nums (q to quit): "</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function">polar <span class="hljs-title">rect_to_polar</span><span class="hljs-params">(rect xypos)</span>  <span class="hljs-comment">// x,y position</span>
</span>{
    polar answer;

    answer.distance = <span class="hljs-built_in">sqrt</span>(xypos.x * xypos.x  + xypos.y * xypos.y);
    answer.angle = <span class="hljs-built_in">atan2</span>(xypos.y, xypos.x);    <span class="hljs-comment">// atan2调库计算角度(弧度制), 本质上是一个反正切函数</span>

    <span class="hljs-keyword">return</span> answer;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_polar</span><span class="hljs-params">(polar dapos)</span>   <span class="hljs-comment">// distance angle position</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> Rad_to_deg = <span class="hljs-number">57.29577951</span>;   <span class="hljs-comment">// 单位转换</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Distance = "</span> &lt;&lt; dapos.distance &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Angle = "</span> &lt;&lt; dapos.angle * Rad_to_deg &lt;&lt; <span class="hljs-string">" degrees."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

}
</div></code></pre>
<p>代码例子 -- 传结构体换成传结构体指针 (效率更高)</p>
<pre class="hljs"><code><div><span class="hljs-comment">/*
    输入 xy 坐标, 输出极坐标
*/</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">polar</span>   // 极坐标
{</span>
    <span class="hljs-keyword">double</span> distance;
    <span class="hljs-keyword">double</span> angle;
};


<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rect</span>     // 笛卡尔坐标
{</span>
    <span class="hljs-keyword">double</span> x;
    <span class="hljs-keyword">double</span> y;
};


<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rect_to_polar</span><span class="hljs-params">(<span class="hljs-keyword">const</span> rect *pxy, polar *pda)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_polar</span><span class="hljs-params">(<span class="hljs-keyword">const</span> polar* dapos)</span> </span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    rect rplace;
    polar pplace;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Please the x and y values: "</span>;

    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; rplace.x  &gt;&gt; rplace.y)  <span class="hljs-comment">// 连续输入</span>
    {
        rect_to_polar(&amp;rplace, &amp;pplace);
        show_polar(&amp;pplace);

        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Next two nums (q to quit): "</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rect_to_polar</span><span class="hljs-params">(<span class="hljs-keyword">const</span> rect *pxy, polar *pda)</span>  <span class="hljs-comment">// 不希望 pxy 被修改, 加const保护</span>
</span>{

    pda -&gt; distance = <span class="hljs-built_in">sqrt</span>(pxy-&gt;x * pxy-&gt;x  + pxy-&gt;x * pxy-&gt;y);
    pda-&gt;angle = <span class="hljs-built_in">atan2</span>(pxy-&gt;y, pxy-&gt;x);    <span class="hljs-comment">// atan2调库计算角度(弧度制), 本质上是一个反正切函数</span>

}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_polar</span><span class="hljs-params">(<span class="hljs-keyword">const</span> polar* dapos)</span>   <span class="hljs-comment">// distance angle position, 加 const 保护</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> Rad_to_deg = <span class="hljs-number">57.29577951</span>;   <span class="hljs-comment">// 单位转换</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Distance = "</span> &lt;&lt; dapos-&gt;distance &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Angle = "</span> &lt;&lt; dapos-&gt;angle * Rad_to_deg &lt;&lt; <span class="hljs-string">" degrees."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<h1 id="77-%E5%87%BD%E6%95%B0%E5%92%8C-string-%E6%95%B0%E7%BB%84">7.7 函数和 string 数组</h1>
<p>代码例子1 -- 传入 string 数组</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">5</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> *sa, <span class="hljs-keyword">int</span> n)</span></span>;  <span class="hljs-comment">// 用 const 保护数组</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-built_in">string</span> <span class="hljs-built_in">list</span>[SIZE];  <span class="hljs-comment">// 用 list 来存放数组</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter "</span> &lt;&lt; SIZE &lt;&lt; <span class="hljs-string">" favorite foods:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++ ){
        <span class="hljs-built_in">cout</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">": "</span>;
        getline(<span class="hljs-built_in">cin</span>, <span class="hljs-built_in">list</span>[i]);      <span class="hljs-comment">// 用 getline 函数捕获整行</span>
    }

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Your list:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    display(<span class="hljs-built_in">list</span>, SIZE);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> *sa, <span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        <span class="hljs-built_in">cout</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; sa[i] &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 遍历并打印整个string对象</span>
}
</div></code></pre>
<hr>
<h1 id="78-%E5%87%BD%E6%95%B0%E4%B8%8E-array-%E5%AF%B9%E8%B1%A1">7.8 函数与 array 对象</h1>
<p>代码例子 -- 用 array 存储一年四季的开支</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SEASONS = <span class="hljs-number">4</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">(<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">double</span>, SEASONS&gt; *pa)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">double</span>, SEASONS&gt; da)</span></span>;

<span class="hljs-keyword">const</span> <span class="hljs-built_in">array</span>&lt;<span class="hljs-built_in">string</span>, SEASONS&gt; Snames = {<span class="hljs-string">"Spring"</span>, <span class="hljs-string">"Summer"</span>, <span class="hljs-string">"Fall"</span>, <span class="hljs-string">"Winter"</span>};  <span class="hljs-comment">// 初始化四个季节的名字</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">double</span>, SEASONS&gt; expenses;  <span class="hljs-comment">// expenses 用来存放四个季节的开销</span>
    fill(&amp;expenses);                  <span class="hljs-comment">// 防止拷贝, 传指针</span>
    show(expenses);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">(<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">double</span>, SEASONS&gt; *pa)</span>           <span class="hljs-comment">// 要修改数组, 所以不加 const 做保护</span>
</span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SEASONS; i++){
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter "</span> &lt;&lt; Snames[i] &lt;&lt; <span class="hljs-string">" expenses: "</span>;
        <span class="hljs-built_in">cin</span> &gt;&gt; (*pa)[i];                        <span class="hljs-comment">// (*pa) 先将指针转换为 array 对象, 只有 array 对象可以像数组一样操作, 但是array指针是不可以直接像指针一样的操作的, 因为array指针"并不表示第数组的第一个元素的地址"!</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">double</span>, SEASONS&gt; da)</span>
</span>{
    <span class="hljs-keyword">double</span> total = <span class="hljs-number">0.0</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"EXPENSES: "</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SEASONS; i++){
        <span class="hljs-built_in">cout</span> &lt;&lt; Snames[i] &lt;&lt; <span class="hljs-string">"\t: $"</span> &lt;&lt; da[i] &lt;&lt; <span class="hljs-built_in">endl</span>;
        total += da[i];
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Total: "</span> &lt;&lt; total &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<p>注意:</p>
<ul>
<li>array &quot;对象&quot; 可以像数组一样操作, 但是, array &quot;指针&quot; 并<strong>不能</strong>像数组一样使用!!!!</li>
</ul>
<h1 id="79-%E9%80%92%E5%BD%92">7.9 递归</h1>
<p>通常递归调用的终止都是用 if 语句来写的.<br>
递归的常见写法:<br>
<img src="file:///Users/laining/Downloads/Cpp_Prime_Learning/Chapter7/第七章笔记_images/递归的通常写法.png" alt=""></p>
<p>代码例子:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    countdown(<span class="hljs-number">4</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-comment">// statement 1</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Counting down... | "</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">" (n at address: "</span> &lt;&lt; &amp;n &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// 执行递归的条件</span>
    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>){  
        countdown(n<span class="hljs-number">-1</span>);
    } 

    <span class="hljs-comment">// statement 2</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">": kadoom"</span> &lt;&lt; <span class="hljs-string">"| (n at address: "</span> &lt;&lt; &amp;n &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

}


<span class="hljs-comment">/*
输出:
    Counting down... | 4 (n at address: 0x16f30addc)
    Counting down... | 3 (n at address: 0x16f30adac)
    Counting down... | 2 (n at address: 0x16f30ad7c)
    Counting down... | 1 (n at address: 0x16f30ad4c)
    Counting down... | 0 (n at address: 0x16f30ad1c)
    0: kadoom| (n at address: 0x16f30ad1c)
    1: kadoom| (n at address: 0x16f30ad4c)
    2: kadoom| (n at address: 0x16f30ad7c)
    3: kadoom| (n at address: 0x16f30adac)
    4: kadoom| (n at address: 0x16f30addc)
*/</span>
</div></code></pre>
<h2 id="792-%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E7%9A%84%E9%80%92%E5%BD%92">7.9.2 包含多个递归调用的递归</h2>
<p>在需要将一项工作不断分成较小的, 类似的工作时, 可以考虑使用递归.</p>
<ul>
<li>二分法 或者叫 分而治之(divide-and-conquer strategy) 的思想就是包含了多个递归调用.</li>
</ul>
<p>代码例子:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Len = <span class="hljs-number">66</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Divs = <span class="hljs-number">6</span>;     <span class="hljs-comment">// 最多循环6次</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subdivide</span><span class="hljs-params">(<span class="hljs-keyword">char</span> arr[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> levels)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-keyword">char</span> ruler[Len];                  <span class="hljs-comment">// 存放竖线</span>

    <span class="hljs-comment">// 清空数组</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; Len; i++){
        ruler [i] = <span class="hljs-string">' '</span>;
    }

    <span class="hljs-comment">// 给数组的前后两个位置填写一个 竖线 |</span>
    <span class="hljs-keyword">int</span> min = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> max = Len - <span class="hljs-number">2</span>;
    ruler[min] = ruler[max] = <span class="hljs-string">'|'</span>;
    ruler[Len - <span class="hljs-number">1</span>] = <span class="hljs-string">'\0'</span>;            <span class="hljs-comment">// 用于结束打印</span>
    
    <span class="hljs-built_in">cout</span> &lt;&lt; ruler &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-comment">// 先输出一行</span>

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= Divs; i++){
        subdivide(ruler, min, max, i);
        <span class="hljs-built_in">cout</span> &lt;&lt; ruler &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subdivide</span><span class="hljs-params">(<span class="hljs-keyword">char</span> arr[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> levels)</span>
</span>{
    <span class="hljs-keyword">if</span>(levels == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">int</span> mid = (low + high) &gt;&gt; <span class="hljs-number">1</span>;
    arr[mid] = <span class="hljs-string">'|'</span>;

    <span class="hljs-comment">// 左半部分</span>
    subdivide(arr, low, mid, levels <span class="hljs-number">-1</span>);

    <span class="hljs-comment">// 右半部分</span>
    subdivide(arr, mid, high, levels <span class="hljs-number">-1</span>);
}

<span class="hljs-comment">/*
输出:

|                                                               |
|                               |                               |
|               |               |               |               |
|       |       |       |       |       |       |       |       |
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

*/</span>

</div></code></pre>
<ul>
<li>
<p>该函数一共调用了6个 level, 每一个 level 会使得函数调用次数翻倍(每次都分为左和右两个部分), 所以一共调用了 2^6 = 64 次.</p>
</li>
<li>
<p>这个代码例子说明: 如果递归层次很多, 则会导致函数调用次数很多, 从而导致程序运行缓慢, 甚至崩溃.</p>
<ul>
<li>只有递归层次较少时, 递归才是一个好的选择.</li>
</ul>
</li>
</ul>
<h1 id="710-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88">7.10 函数指针</h1>
<p>使用场景: 将<code>一个函数</code>作为<code>另一个函数的参数</code>传入.</p>
<h2 id="7101-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">7.10.1 函数指针的基础知识</h2>
<ul>
<li>
<p>函数名就是一个地址, 直接<code>把函数名作为参数</code>传递给另一个函数即可.</p>
<ul>
<li>注意区分传递的是函数的地址, 还是函数的返回值.<pre class="hljs"><code><div><span class="hljs-comment">// 假定已经有一个函数叫做 think();</span>
process(think);         <span class="hljs-comment">// 传递函数 think 的地址 (函数指针)</span>
process(think());       <span class="hljs-comment">// 传递函数 think 的返回值</span>
</div></code></pre>
</li>
</ul>
</li>
<li>
<p>声明函数指针</p>
<ul>
<li>
<p>函数指针的声明:<br>
<img src="file:///Users/laining/Downloads/Cpp_Prime_Learning/Chapter7/第七章笔记_images/函数指针的声明.png" alt=""></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">pam</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;    <span class="hljs-comment">// 函数原型/函数声明</span>

<span class="hljs-keyword">double</span> (*pf)(<span class="hljs-keyword">int</span>);  <span class="hljs-comment">// 声明一个函数指针 pf, 它指向一个以 int 为参数, 返回值为 double 的函数.</span>

 <span class="hljs-function"><span class="hljs-keyword">double</span> * <span class="hljs-title">pf</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;   <span class="hljs-comment">// 声明一个函数 pf, 它返回一个 double 指针. (此时 double * 是一个整体)</span>
</div></code></pre>
</li>
<li>
<p>小例子: 声明一个estimate函数, 假定这个函数是用来估算一个算法的执行时间 和 统计代码行数.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 传递进来的算法函数必须是 "指接受一个 int 类型的参数, 返回值为 double 类型" 的.</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">estimate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lines, <span class="hljs-keyword">double</span> (*pf)(<span class="hljs-keyword">int</span>))</span></span>;
</div></code></pre>
</li>
</ul>
</li>
<li>
<p>使用函数指针</p>
<ul>
<li>由于函数指针扮演的角色与函数名相同, 此时直接将函数指针当做函数名字即可.<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">pam</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;
<span class="hljs-keyword">double</span> (*pf)(<span class="hljs-keyword">int</span>);
pf = pam;               <span class="hljs-comment">// 将函数 pam 的地址赋值给函数指针 pf</span>
<span class="hljs-keyword">double</span> x = pam(<span class="hljs-number">4</span>);      <span class="hljs-comment">// 直接调用函数 pam</span>
<span class="hljs-keyword">double</span> y = (*pf)(<span class="hljs-number">5</span>);    <span class="hljs-comment">// 通过函数指针调用函数 pam</span>
</div></code></pre>
<ul>
<li><code>double y = (*pf)(5);</code>写法可以直接提醒程序员, 当前正在使用函数指针.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码例子:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Rick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lines)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Jack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lines)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">estimate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lines, <span class="hljs-keyword">double</span> (*pf)(<span class="hljs-keyword">int</span>))</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-keyword">int</span> code;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"How many lines of codes do you need? "</span>;
    <span class="hljs-built_in">cin</span> &gt;&gt; code;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Here is Rick's estimate: "</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    estimate(code, Rick);   <span class="hljs-comment">// Rick 是一个函数名</span>

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Here is Jack's estimate: "</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    estimate(code, Jack);   <span class="hljs-comment">// Jack 是一个函数名</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Rick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lines)</span>
</span>{
    <span class="hljs-keyword">return</span> lines * <span class="hljs-number">0.05</span>;
}

<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Jack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lines)</span>
</span>{
    <span class="hljs-keyword">return</span> lines * <span class="hljs-number">0.03</span> + <span class="hljs-number">0.0004</span> * lines * lines;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">estimate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lines, <span class="hljs-keyword">double</span> (*pf)(<span class="hljs-keyword">int</span>))</span>
</span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; lines &lt;&lt; <span class="hljs-string">" lines code will task "</span> &lt;&lt; (*pf)(lines) &lt;&lt; <span class="hljs-string">" hours to complete."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<h2 id="7102-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">7.10.2 函数指针高级用法 (函数指针数组)</h2>
<p>具体看下面的代码例子注释:</p>
<pre class="hljs"><code><div>
</div></code></pre>
<ul>
<li>注意区分<code>(*pa)[2](av, 3);</code> 和 <code>*pa[2](av, 3);</code>的区别:<pre class="hljs"><code><div>    <span class="hljs-comment">// (*pa)[2](av,3) 和 *pa[2](av,3) 是 [不等价] 的!!!!!!</span>
    
    (*pa)[<span class="hljs-number">2</span>](av, <span class="hljs-number">3</span>);  
    <span class="hljs-comment">/* 
        这句代码表示: 返回数组 av 第3个元素的 "地址".
    解析:
        1. 由于括号的优先级, 有 (*pa)表示 数组的首地址, 然后(*pa)[2] 表示数组的第3个元素的地址, 也就是指向 f3 的 函数指针.
        2. 然后 (*pa)[2](av, 3) 表示调用 f3 函数, 传入参数 av 和 3.
        3. 函数 f3 返回的是 av数组的第三个元素的地址, 所以最终得到的是 一个地址.
    */</span>

    *pa[<span class="hljs-number">2</span>](av, <span class="hljs-number">3</span>);
    <span class="hljs-comment">/*
        这句代码表示: 返回数组 av 第3个元素的 "值".
    解析:
        1. 由于*的优先级比 括号 和 中括号 都低, 所以先处理 pa[2](av, 3); 
        2. 此时又会先处理中括号, 所以处理的是 pa[2], 表示先索引到pa数组的第二个元素, 得到 f3 函数的函数指针.
        3. 然后 pa[2](av, 3) 表示调用 f3 函数, 传入参数 av 和 3, 得到一个 const double * 类型的 指针, 也就是av数组第三个元素的地址; 到这里就获得了(*pa)[2](av, 3)的执行结果了.
        4. 得到av数组的第三个元素地址之后, 这个地址与 * 运算符结合, 取出了地址里的内容, 最终得到了  数组 av 第3个元素的 "值".
    */</span>
    
</div></code></pre>
</li>
<li>注意<code>数组名的含义</code>以及<code>对数组名使用&amp;操作符的含义</code>:
<ul>
<li>pa 表示数组 pa 的第一个元素的地址, 等同于 <code>&amp;pa[0]</code>.</li>
<li>&amp;pa 表示<code>取整个数组在内存中的地址</code></li>
<li>如果直接打印这两个地址, 我们看到的结果是一模一样的</li>
<li><code>pa+1</code> 表示数组 pa 的第二个元素的地址, 等同于 <code>&amp;pa[1]</code>.</li>
<li><code>&amp;pa+1</code>表示跨国整个pa数组的内存, 直接跳到了 pa 数组最后一个元素的后面, 给出这个元素的下一个内存块的地址(这个内存块与pa数组一样大).</li>
</ul>
</li>
</ul>
<h2 id="7103-typedef-%E7%AE%80%E5%8C%96%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%A3%B0%E6%98%8E">7.10.3 typedef 简化函数指针的声明</h2>
<p>作用是 &quot;给类型设置一个别名&quot;.</p>
<ul>
<li>使用诀窍: 定义变量怎么写, typedef 定义的别名怎么使用.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">double</span> real;   <span class="hljs-comment">// real 是一个变量, 并且是double类型</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> real;   <span class="hljs-comment">// real 不是一个变量, real 是 double 的别名</span>

<span class="hljs-comment">// 举例:</span>
real r1;   <span class="hljs-comment">// r1 是一个变量, 并且是double类型, 因为 real 已经是 double 的别名</span>
</div></code></pre>
<ul>
<li>例子: 使用 typedef 简化函数指针</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *(*p_fun)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *, <span class="hljs-keyword">int</span>);   
<span class="hljs-comment">// p_fun 是一个函数指针类型, 它指向的函数接受两个参数, 一个是 const double *, 一个是 int, 返回值是 const double * 类型.</span>

p_fun p1 = f1;  <span class="hljs-comment">// p1 是一个函数指针, 指向 f1 函数.</span>
p_fun pa[<span class="hljs-number">3</span>] = {f1, f2, f3};   <span class="hljs-comment">// pa 是一个函数指针数组, 数组里面的元素都是 p_fun 类型的函数指针.</span>

p_fun (*pd)[<span class="hljs-number">3</span>] = &amp;pa;   <span class="hljs-comment">// pd 是一个与 pa 相同类型的 函数指针数组.</span>
</div></code></pre>

</body>
</html>
