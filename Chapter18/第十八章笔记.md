# C++ 新增的功能

## 新增类型
C++11 中新增:
- `long long` 和 `unsigned long long` 类型，分别用于表示长整型和无符号长整型。
- 新增`char16_t`和`char32_t`类型，分别用于表示16位和32位的字符。
- 添加"原始"字符串.

## 统一的初始化(使用大括号)
C++11开始, 新增了`大括号{}`括起来的初始化列表. 它可以适用于所有类型.
- 在 `new` 运算符中如果需要初始化, 很多情况下都会选择用`{}`
- 类的构造函数中常常使用.
    ```cpp
    class abc
    {
        private:
            int a, b, c;
        public:
            abc(int a, int b, int c) : a(a), b(b), c(c) {};
    };

    // 使用时:
    abc s1(1, 2, 3);        // 传统的初始化方式
    abc s2{1, 2, 3};        // 使用 {} 初始化
    abc s3 = {1, 2, 3};     // 使用 {} 初始化
    ```

### 变量值的"缩窄"问题
使用大括号初始化时, 如果初始化列表中的值超出了变量的表示范围, 编译器会报错.
- 可以提示程序员, 防止出现意外的变量值的"缩窄"
    ```cpp
    // 注: char 类型的范围是 -128 ~ 127
    char c1 = 23456789;     // 编译器不会报错, 但是这个数值肯定是存不下的, 此时将触发 "未知的行为"

    char c1 = {23456789};   // 编译器直接报错, 不允许这么写
    ```


### initializer_list
中文书 page 725 有详细讲解.

对于STL中的容器, 它的用法很简单:
```cpp
vector<int> a1(10);   // 创建一个大小为10的vector, 元素值都是0
vector<int> a2{10};   // 创建一个大小为1的vector, 元素值是10
vector<int> a3{10, 20, 30}; // 创建一个大小为3的vector, 元素值分别是10, 20, 30
```

普通函数中的使用:
- 可以将`initializer_list`作为函数的参数, 用于接收初始化列表.
    ```cpp
    #include <initializer_list>
    double sum(std::initializer_list<double> il)
    {
        double total = 0;
        for (auto p = il.begin(); p != il.end(); p++)
            total += *p;
        return total;
    }

    int main(void)
    {
        double total = sum({2.5, 3.6, 4.7}); 
        return 0;
    }
    ```

## 声明
### auto
编译器自动推断变量的类型, 可以简化我们的代码.
- 但注意: 这样写其实不少公司不推荐, 因为可读性太差了.
    ```cpp
    auto n = 100;       // n 是 int 类型
    auto x = 1.5;       // x 是 double 类型
    auto y = 1.5L;      // y 是 long double 类型
    auto z = 1.5F;      // z 是 float 类型
    auto c = 'a';       // c 是 char 类型
    auto s = "hello";   // s 是 const char * 类型
    ```

- 优点是, 有些类型比较长, 如函数指针, 用`auto`可以简化代码.
    ```cpp
    double func (double, int);      // 需要显式初始化

    // 传统写法
    void (*pf)(int, int) = func;

    // 使用 auto
    auto pf = func;
    ```

### decltype
中文书 page 295 (第8章).
它的作用是`将表达式的类型作为变量的类型`.
```cpp
double x = 1.5;
int n;
decltype (x*n) q;  // q 由 (x*n) 得到的类型来确定

// decltype 的一个特殊场景: 如果表达式使用了两个括号括起来, 并且表达式的结果是一个左值, 那么 decltype 将返回一个 "引用" 类型.
decltype ((x)) y;    // 由于 x 是一个 "左值", 此时 y 的类型是 double &

```

常用的场景 -- **定义的模板(类/函数)中存在多个类型**
```cpp
template <class T, class U>
void ef(T t, U u)
{
    decltype (t + u) sum;
    decltype (t * u) product;
    // ...
}
```

### 返回类型后置
中文书 page 296 (第8章).
新语法: 在函数名和参数列表之后, 使用`->`指定返回类型.
```cpp
template <class T, class U>
auto ef(T t, U u) -> decltype (t + u)           // 返回类型后置, 前面先用 auto 占位, 后面再用  "-> decltype(表达式)" 确定返回类型
{
    return t + u;
}
```


### 模板别名 (using = )
中文书 page 593 (第14章)
我们常用的起别名的方式一般是`typedef`, 现在还有另一种用法, 就是使用`using = `关键字.
```cpp
typedef std::vector<std::string>::iterator itType;  // typdef 写法
using itType = std::vector<std::string>::iterator;
```

它们的区别是:
- `typedef` 一定要用在 **确定类型的别名** 身上
- `usin =` 的方式可以用在 **模板** 上, 用于指定模板的类型参数.
    ```cpp
    template <typename T>
    using arr12 = std::array<T, 12>;    // arr12 是一个模板别名, 用于生成一个大小为12的数组

    // 使用的时候
    arr12<double> a1;       // 等价于 std::array<double, 12> a1;
    arr12<std::string> a2;  // 等价于 std::array<std::string, 12> a2;
    ```

### 空指针 nullptr
C++ 之前一般使用`0表示空指针`, 到现在其实也还能这么用. C++11之后一般用 nullptr 使得代码更容易读.


### 智能指针
具体查看第16章.
注意 C++11 已经抛弃了 auto_ptr.


### 异常规范的修改
特地写某些地方会抛出异常, 这种做法其实用得不多, 用的多的反而是`指出什么地方不会引发异常`, 也就是使用`noexcept`关键字.
```cpp
void test123() noexcept;    // 表示 test123 不会抛出异常
```

## 作用域内枚举
在定义枚举量时, 使用 class 来防止枚举量冲突.
```cpp
/*
    enum color {red, yellow, green};   // 传统的枚举量定义方式
    enum stoplight {red, yellow, green};   // 会报错, 因为 red, yellow, green 已经被定义过了
*/

enum class color {red, yellow, green};   // 使用 class 来定义枚举量, 防止冲突
enum class stoplight {red, yellow, green};   // 不会报错, 因为枚举量的作用域被限制在了 class 内部
``` 


## 对类进行修改

### 显式转换运算符
详细内容在第11章笔记里的`转换函数`部分(中文书 page 519 页).
- 但是需要强调一下, 转换函数其实是`将类的对象转换为其他数据类型`. 而这里提到的隐式转换是`将其他数据类型转换为类的对象`.

为了**防止隐式转换**, 可以使用`explicit`关键字来修饰**构造函数**, 此时就需要显式地调用类构造函数才能完成转换.
```cpp
class abc
{
    private:
        int a;
    public:
        explicit abc(int a) : a(a) {};   // 使用 explicit 关键字修饰构造函数, 防止隐式转换
}

// 使用时:
abc s1(1);      // 正确, 显式调用构造函数
abc s2 = 1;     // 错误, 由于 explicit 关键字, 不能隐式调用构造函数
```

### 类内成员的初始化
从C++11开始, 类的成员变量可以在声明的时候直接初始化.


## 模板和STL方面的修改
### 基于范围的for循环
中文书 page 684.
```cpp
double price[5] = {1, 2, 3, 4, 5};
for (double x : price){         // 这就是基于范围的for循环用法
    cout << x << endl;
}
```


### 新增的容器
- forward_list,
- unordered_map, 
- unordered_multimap, 
- unordered_set, 
- unordered_multiset.

详见中文书的第16章.


### 新增的STL方法
这些方法都返回迭代器, 并将元素视为const:
- cbein()
- cend()
- rbegin()
- rend()

### valarray
中文书 page 720 页.
可回顾第十六章笔记.

## 摒弃 export
C++11之后不再推荐使用 export, 但是功能还没删. (C++98中很常用)


## 尖括号
为了防止与`>>`混淆, 通常要求写为`> >`(中间有个空格). 在C++11中, 不再作这个要求, 原因就是难看...
- 但是发现 mac 使用的 g++ 编译器默认仍然有这个要求, 可能是没有使用参数`-std=c++11`的锅.


## 右值引用
第八章笔记有讲解.


# 移动语义与右值引用
移动语义出现的背景:
先看下面的场景:
```cpp
using namespace std;
vector<string> vstr;            // 假设这个vstr后面会存储 2w个字符串, 每个字符串2k个字符, 此时它将占用 2w*2k*4B = 160MB 的内存
...
vector<string> vstr_cpy(vstr);  // 触发拷贝构造函数, 此时会新增160MB的内存, 用于存储拷贝出来的字符串
/*
    此时, 这种拷贝不仅内存开销大, 而且耗时.
        但有时候这个操作仍然是妥当的.
*/
```
再看另一个场景:
```cpp
// 假设现在有一个函数定义如下:
vector<string> allcaps(const vector<string> & vstr);   // 将 vstr 中的所有字符串转换为大写, 并返回一个新的 vector<string>
{
    vector<string> result;
    for (auto p = vstr.begin(); p != vstr.end(); p++)
        result.push_back(str_toupper(*p));
    return result;
}

// 使用这个函数的代码如下:
vector<string> vstr;
vector<string> vstr1(vetr);                 // 触发拷贝构造
vector<string> vstr2 = allcaps(vstr);       
/*
    1. 先将vstr的东西走一遍for, 存入result; 
    2. result的内容经过拷贝构造, 赋值到一个 *临时变量* 中;
    3. *临时变量* 经过 拷贝构造 赋值到 vstr2 中;
    4. 销毁临时变量.
*/
```
- 从这个过程我们可以看到, 如果 vstr 里的内容很多时, allcaps 函数内部创建并销毁了一次临时变量, 经历了一次额外的 "创建变量->销毁变量" 的过程, 增大了不必要的计算开销.
- 现在我们希望简化这个过程, 希望能**跳过第三步**, 也就是不开辟新的空间来存储 vstr2, 而是**换个名字, 并直接使用那个临时变量的空间**.
  - 要实现这个设想, 我们需要让编译器知道`什么时候应该触发拷贝, 什么时候不需要拷贝`  --> 借助移动语义 --> 定义移动构造函数.

## 移动构造与拷贝构造的区别
```cpp
class ABC
{
    private:
        int a, b, c;
        char * ch;
    public:
        ABC() : a(0), b(0), c(0), ch("") {};  // 默认构造
        ABC(int a, int b, int c, char *cc) : a(a), b(b), c(c), ch(cc){}; // 自定义构造
        ABC(const ABC &abc) : a(abc.a), b(abc.b), c(abc.c)        // 拷贝构造
        {
            ch = new char[strlen(abc.ch) + 1];
            strcpy(ch, abc.ch);
        };
        ABC(ABC && abc) : a(abc.a), b(abc.b), c(abc.c)    // 移动构造
        {
            ch = abc.ch;    // 直接将 abc.ch 的地址赋值给 ch, 而不是拷贝一份
            abc.ch = nullptr;   // 将 abc.ch 置空, 防止 abc 被销毁时, ch 被销毁
        };
};
```
- 从例子中可以看到:
  - 拷贝构造的参数一般带有 const, 而移动构造没有.
  - 拷贝构造函数会在`不同的内存地址上复制一份数据`, 此时计算机中将`有两份数据`, 一份是原来的, 一份是拷贝出来的.
  - 移动构造函数中, 一般会将原来的指针置空, 防止原来的对象被销毁时, 指针指向的内存被销毁.
    - 此时计算机中`只有一份数据`, 但是指针指向的内存地址发生了变化.


## 触发移动构造的两个条件
1. 编写移动构造函数, 让编译器知道应该做什么.
2. 要让编译器知道什么时候应该使用移移动构造(移动语义)

```cpp
ABC one;            // 创建对象, 使用默认参数
ABC three;          // 创建对象, 使用默认参数
ABC two = one;      // one 是左值, 可取地址的, 此时触发 拷贝构造
ABC four(one + three);  // one + three 是右值(表达式的计算结果都是右值), 是不可取地址的, 此时触发 移动构造
```


注: 
在C++11之前, 也就是没有移动语义之前, 它的实现方式是:
```txt
对于代码:
    ABC four(one + three);

1. 先调用 operator+() 函数, 将结果计算出来
2. 调用拷贝构造函数, 将计算结果拷贝到 four 中
```
在C++11之后, 编译器**并不会马上去计算表达式**, 而是**先检查表达式是左值还是右值**, 然后再进行下一步动作.

## 移动赋值
假设有一个类:
```cpp
class Useless
{
    private:
        int n;
        char * pc;
        static int ct;
        void ShowObject() const;
    public:
        Useless();
        explicit Useless(int k);
        Useless(int k, char ch);
        Useless(const Useless & f);
        Useless(Useless && f);      // 移动构造函数
        ~Useless();
        Useless operator+(const Useless & f) const;
        void ShowData() const;
};
```


对应的赋值运算符 和 移动赋值运算符 定义:
```cpp
Useless & Useless::operator=(const Useless & f)
{
    if (this == &f)
        return *this;
    delete [] pc;
    n = f.n;
    pc = new char[n];           // 开辟空间
    strcpy(pc, f.pc);           // 拷贝
    return *this;
}

Useless & Useless::operator=(Useless && f)
{
    if (this == &f)
        return *this;
    delete [] pc;           
    n = f.n;
    pc = f.pc;  // 不进行开辟空间 & 拷贝, 直接将 f.pc 的地址赋值给 pc
    f.pc = nullptr;
    return *this;
}
```

- 写法与移动构造差不多, 都是直接将指针的地址赋值给新的对象, 然后将原来的指针置空.


## 强制移动
强制移动指的是 **强制**让程序使用 **移动赋值运算符** 或 **移动构造函数**.

借助库函数`std::move()`强制将左值转换为右值, 从而触发移动构造函数或者移动赋值, 也就是"强制移动".
```cpp
four = one;             // 调用普通的赋值运算符, 一般含有开辟内存 + 拷贝 的操作
four = std::move(one);  // 此时将使用移动赋值运算符, 不会进行开辟内存+拷贝
```

触发强制移动的条件:
1. 代码中定义了相应的移动赋值运算符 或 移动构造函数
2. 使用了 std::move() 函数获得右值.


注意:
- 我们学习右值引用并不是为了能够编写使用右值引用的代码, 而是能利用右值引用来调用STL库里提供的各种右值引用函数. (自己写的没有经过评审或迭代, 总是容易出现小问题, 远不如使用迭代多次的STL库函数)



# 类的特殊成员函数
在C++11中, 特殊的类成员函数一共有6个, **如果我们没有自行定义, 一般情况下编译器也会提供一个**:
1. 默认构造函数
2. 拷贝构造函数
3. 拷贝赋值运算符
4. 移动构造函数
5. 移动赋值运算符
6. 析构函数

特殊情况:
```txt
1. 如果我们编写了 `析构函数`, `复制构造函数` 或 `复制赋值运算符`, 那么编译器将 **不会** 自动提供移动构造函数和移动赋值运算符.

2. 如果我们编写了 `移动构造函数` 或 `移动赋值运算符`, 则编译器将 **不会** 自动提供复制构造函数和复制赋值运算符.

3. 如果编写了 `移动构造函数`, 编译器将 **不会** 自动创建`默认的构造函数`, `复制构造函数`和`复制赋值运算符`.
```

## 设置默认的方法 和 禁用方法

前面讨论过, 如果编写了移动构造函数, 编译器将不会自动创建默认的构造函数, 复制构造函数和复制赋值运算符.
- 此时, 如果我们仍然需要这些函数, 我们可以使用`default`关键字来显式地声明**所需函数的默认版本**(如果不想自行定义这些函数, 有default的话它会让编译器自动创建).
    ```cpp
    class someclass
    {
        public:
            someclass(someclass &&);   // 移动构造函数, 此时, 编译器将不会自动创建默认的构造函数, 复制构造函数和复制赋值运算符.
            someclass() = default;     // 声明构造函数的默认版本
            someclass(const someclass &) = default;   // 显式声明复制构造函数的默认版本
            someclass & operator=(const someclass &) = default;     // 复制赋值运算符的默认版本
    };
    ```
- 注意: default 关键字**只能用于前面提到的6个特殊成员函数**, 不能用于其他函数.


---

如果要让编译器禁用某些成员函数(方法), 比如要禁止复制对象, 就需要禁用复制构造函数, 此时可以使用`delete`关键字.
```cpp
class someclass
{
    public:
        someclass(const someclass &) = delete;   // 禁用复制构造函数
};
```
- 与 default 不同, `delete`可用于任意成员函数, 但是一般不用于默认构造函数和析构函数.
- delete一般用于禁止某些特定数据类型的转换, 比如禁止将`double`类型的数据转换为`int`类型的数据.
    ```cpp
    class someclass
    {
        public:
            ...
            void redo(int) = delete;     
            void redo(double);
    };

    // 使用时:
    someclass s1;
    s1.redo(1);     // 调用 void redo(double);
    /*
        在跑 redo(1) 这行代码时, 1 是 int 类型, 此时会去匹配 redo(int), 但是此时发现这个函数被 delete 了, 于是编译器直接报错, 表示不允许这么使用.

        如果只有 redo(double) 函数, 此时 redo(1) 会:
            1. 先将 1 转换为 1.0
            2. 将 1.0 传入 redo(double) 函数中
    */
    ```
    - 这个例子可以告诉我们, 如果我们发现代码出问题了, 并且已经定位到某个类中的某个特定方法, 此时如果想要知道哪里调用了这个方法, 可以使用 `= delete` 禁用它, 此时, 只要编译, 调用了这个方法的位置就会报错, 从而定位到调用函数的位置.

## 委托构造函数
C++11允许一个构造函数调用另一个构造函数, 这种构造函数被称为`委托构造函数`.
```cpp
class Notes
{
    private:
        int k;
        double x;
        std::string st;
    public:
        Notes(int, double, const std::string &);

        // 以下构造函数都是 **委托构造函数**
        Notes();                // 默认构造, 但是包含了 Notes(int, double, const std::string &) 中的所有代码
        Notes(int);             // 自定义构造, , 但是包含了 Notes(int, double, const std::string &) 中的所有代码
        Notes(int, double);     // 自定义构造, , 但是包含了 Notes(int, double, const std::string &) 中的所有代码
};

Notes::Notes(int kk, double xx, std::string stt): k(kk), x(xx), st(stt) { /*某些简单的操作*/}

Notes::Notes() : Notes(0, 0.01, "Oh") { /*某些不同于上一个函数操作*/}

Notes::Notes(int kk) : Notes(kk, 0.01, "Ah") { /*某些不同于前面函数操作*/}

Notes::Notes(int kk, double xx) : Notes(kk, xx, "Uh") { /*某些不同于前面函数操作*/}

/*
    在调用时, 相当于那三个委托构造函数都运行了一次 Notes(int kk, double xx, std::string stt) 的代码
*/
```


## 继承构造
直接看例子:
```cpp
class BS            // 基类
{
    private:
        int q;
        double w;
    public:
        BS() : q(0), w(0) {}
        BS(int k) : q(k), w(100) {}
        BS(double x) : q(-1), w(x){}
        BS(int k, double x) : q(k), w(x) {}
        BS(int k, double x) : q(k), w(x) {}
        void Show() const {std::cout << q << ", " << w << '\n';}
};

class DR : public BS
{
    private:
        short j;
    public:
        using BS::BS;       // 继承基类的构造函数

        DR() : j(-100) {}
        DR(double x) : BS(2*x), j(int(x)){}
        DR(int(i)) : j(-2), BS(i, 0.5*i) {}
        void Show() const {std::cout << j << ", "; BS.Show();}
};

//  ---- 使用 ----

int main()
{
    DR o1;          // 使用 DR 的默认构造函数
    DR o2(18.81);   // 虽然 BS 也有一个接受 double 类型的构造函数, 但是此时调用的是 DR 的构造函数, 毕竟是 DR 类的对象, 以 DR 类优先
    DR o3(10, 1.8); // DR 中没有能匹配上的构造函数, 此时调用 BS 的构造函数
}
```
知识点:
```txt
1. 继承构造函数需要使用 `using 基类名::基类名;` 的语句.
2. 在创建派生类对象时, 会优先配派生类的构造函数
3. 当派生类中没有对应参数列表的构造函数时, 才会去调用基类的构造函数.
```

## override 和 final
代码例子:
- 基类, 派生类 和 main函数 中的 `case 1,2,3,4` 要互相搭配着看.
```cpp
#include <iostream>

using namespace std;

class Action
{
    private:
        int a;
    public:
        Action(int i = 0) : a(i){}
        int val() const {return a;}

        // ----  case 1, 2, 3  -----
        // virtual void f(char ch) const {cout << val() << ch << "\n";}

        // ----  case 4: 基类使用了final -----
        virtual void f(char ch) const final {cout << val() << ch << "\n";}

};

class Bingo: public Action
{
    public:
        Bingo(int i = 0) : Action(i) {}

        // ------ case 1 ------
        // virtual void f(char *ch) const {cout << val() << ch << "!\n";}     
        /*
            在第十三章, 中文书 page 506页 有提到, 这种方式叫 "重新定义":
                virtual void f(char ch) const
                virtual void f(char *ch) const
                这辆个函数虽然参数列表(特征标)不相同, 但是由于是虚函数, 此时 **并不会生成两个版本的 f 函数**!!  (对于虚函数来说, 此时特征标不一样, 不是实现不同功能那种 多态)
                    此时发生的现象是: 
                        派生类 Bingo 中定义的 "virtual void f(char *ch) const" 将直接把基类的同名函数 f 给隐藏掉, 
                        此时我们将无法通过派生类对象调用基类的 f 函数.
        */

        // ------ case 2 ------
        // virtual void f(char ch) const {cout << val() << ch << "!\n";}       // 打印的时候会多出一个 !

        // ------ case 3, 4: 派生类使用 override ------
        virtual void f(char ch) const override {cout << val() << ch << "!\n";}       // 此时override 与 基类的final冲突, 编译会报错

};

int main(void)
{
    Bingo b(10);

    // ------ case 1 ------
    // b.f('@');       // 没有加 final 或 override 时, 这行语句编译会报错, 因为 '@'无法与 const char * 类型匹配.
    // b.Action::f('@');    // 没有加 final 或 override 时, 通过指明作用域, 可以正常调用到基类的 f 方法

    // ------ case 2: 如果基类有同名函数, 则派生类的函数是基类函数的重载; 如果注释掉基类的同名函数, 则派生类的函数是一个独立的普通函数. ------
    // b.f('@');       // 此时 打印的信息多一个 !, 表示调用的是派生类的f函数.  注意此时这两个虚函数的特征标是一模一样的! (这时候实现的是多态/重载)
                       //    这时候, 如果注释掉基类的 f 方法, 编译和运行都不会报错!! 

    // ------ case 3: 加 override, 显式表明f是基类的重载, 此时基类的同名函数不允许被删除, 如果删除, 则编译会报错"你既然表明是重载, 你就得有个原来的版本" ------
    // b.f('@');       // 此时 打印的信息多一个 !, 表示调用的是派生类的f函数.  注意此时这两个虚函数的特征标是一模一样的! (加了override之后, 显式地表明这个函数是基类函数的重载)
                    //      这时候, 如果注释掉基类的 f 方法, 编译会报错!! 

    // ------ case 4: 基类加 final, 表示不允许重载 (不允许派生类 override), 但是派生类的同名函数使用了 override ==> 此时编译报错
    b.f('@');  

    return 0;    
}
```

核心知识点:
```txt
1. final 一般用在`基类`, 用来表示某个函数 **不允许被重载**.
2. override 一般用在`派生类`, 用来表示某个函数 **是基类同名同参数的函数的重载**.

如果对于 "同名&同参数列表的某个成员函数", 基类中用了final 且 派生类中用了override, 会编译报错, 这两个关键字互相冲突. (例子中的case 4)
```


# Lambda表达式
lambda表达式本质上就是定义一个`匿名函数`, 这种匿名函数**作为参数**可以传递给`兼容 "函数指针" 和 "函数符" `的函数.
- lambda表达式`没有函数名`, 也`没有返回值`, 它的返回值是根据`decltype`推断出来的.
- 语法:
    ```cpp
    // 写法1: 不捕获任意作用域内的变量
    [](参数列表) {函数体}       // 相当于用 [] 替代了函数名的位置

    // 写法2: 只捕获某些变量
    [需要捕获的变量列表](参数列表){函数体}

    // 写法3: 临时给lambda表达式一个名字
    auto 临时名字 = [](参数列表){函数体}         // 此时这个临时名字就是一个函数指针, 可以像普通函数一样使用
    ```
    - 方括号`[z]`表示使用`按值传递`的方式访问变量z的值, 如果lambda函数内部发生修改, 此时只会修改z的副本, z变量并不会发生修改
    - 方括号`[&z]`表示使用`按引用传递`的方式访问变量z的值, 如果lambda函数内部发生修改, 此时z的值也会发生修改.
- 优点:
  - 简洁


代码例子 -- 对比使用函数, 使用函数符, 使用lambda表达式写法的区别:
```cpp
/*
    用三种不同的方式完成: 
        统计随机数中能被 3 和 13 整除的值的个数.
*/
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <algorithm>

using namespace std;
#define SIZE1 39
#define SIZE2 3900
#define SIZE3 390000

bool f3(int x) {return x % 3 == 0;};
bool f13(int x) {return x % 13 == 0;};

int main(void)
{
    vector<int> numbers(SIZE1);

    // ------- method 1: 使用函数指针来实现 -------
    srand(time(0));
    generate(numbers.begin(), numbers.end(), rand);              // 第三个参数是 "函数名/函数指针" (函数名就是一个指针/地址).   这个函数在中文书 page 894
    cout << "Sample size = " << SIZE1 << endl;
    int count3 = count_if (numbers.begin(), numbers.end(), f3);  // 统计指定范围内满足自定义函数的值有多少个, 要求这个函数返回值是 bool 类型.   中文书 page 888.
    cout << "Count of numbers divisable by 3: " << count3 << endl;
    int count13 = count_if (numbers.begin(), numbers.end(), f13);
    cout << "Count of numbers divisable by 13: " << count13 << endl;

    // ------- method 2: 用函数符(仿函数)的方式 -------
    class f_mod
    {
        private:
            int div;        // 保存要设置的除数
        public:
            f_mod(int d = 1) : div(d){}
            bool operator()(int x){ return x % div == 0; }         // 函数符: 一定要重载 ()运算符 
    };
    numbers.resize(SIZE2);
    generate(numbers.begin(), numbers.end(), rand);                // 重新填充

    // 注意这个功能是C++11新增的, 有些编译器编译的时候可能需要使用 -std=c++11
    count3 = count_if(numbers.begin(), numbers.end(), f_mod(3));   // 这里 f_mod(3) 是调用了构造函数创建了匿名对象
    cout << "Count of numbers divisable by 3: " << count3 << endl;
    count13 = count_if(numbers.begin(), numbers.end(), f_mod(13));   // 这里 f_mod(13) 是调用了构造函数创建了匿名对象
    cout << "Count of numbers divisable by 13: " << count13 << endl;

    // ------- method 3: 使用Lambda表达式 -------
    numbers.resize(SIZE3);
    generate(numbers.begin(), numbers.end(), rand);  
    count3 = count_if(numbers.begin(), numbers.end(), [](int x){return x % 3 == 0;});   
    cout << "Count of numbers divisable by 3: " << count3 << endl;
    count13 = count_if(numbers.begin(), numbers.end(), [](int x){return x % 13 == 0;});   // 这里 f_mod(13) 是调用了构造函数创建了匿名对象
    cout << "Count of numbers divisable by 13: " << count13 << endl;

    return 0;
}
```

代码例子2 -- lambda表达式指定访问某个变量
```cpp
/*
    用三种不同的方式完成: 
        统计随机数中能被 3 和 13 整除的值的个数.
*/
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <algorithm>

using namespace std;
#define SIZE 390000

bool f3(int x) {return x % 3 == 0;};
bool f13(int x) {return x % 13 == 0;};

int main(void)
{
    vector<int> numbers(SIZE);
    int count3 = 0;
    int count13 = 0;

    // ------- lambda表达式的方括号什么都不写 -------
    numbers.resize(SIZE);
    generate(numbers.begin(), numbers.end(), rand);  
    count3 = count_if(numbers.begin(), numbers.end(), [](int x){return x % 3 == 0;});   
    cout << "Count of numbers divisable by 3: " << count3 << endl;
    count13 = count_if(numbers.begin(), numbers.end(), [](int x){return x % 13 == 0;});   // 这里 f_mod(13) 是调用了构造函数创建了匿名对象
    cout << "Count of numbers divisable by 13: " << count13 << endl;

    // ------- lambda表达式的方括号写变量名, 按值传递 -------
    count13 = 0;
    for_each(numbers.begin(), numbers.end(), [&count13](int x){count13 += x % 13 == 0;});   
    /*
        lambda表达式里对 count13进行了修改;
        += 是一个赋值操作, 表达式从右往左运行, 其中 x % 13 == 0 属于右侧的表达式
        由于已经在 lambda 表达式中完成了计数, 所以此时只需要遍历即可, 换成 for_each
    */
    cout << "Count of numbers divisable by 13: " << count13 << endl;

    count3 = count13 = 0;
    for_each(numbers.begin(), numbers.end(), [&count3, &count13](int x){count3 += x % 3 == 0;count13 += x % 13 == 0;});   
    cout << "Count of numbers divisable by 3: " << count3 << endl;
    cout << "Count of numbers divisable by 13: " << count13 << endl;

    return 0;
}
```


