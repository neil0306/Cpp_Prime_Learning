# C++ 新增的功能

## 新增类型
C++11 中新增:
- `long long` 和 `unsigned long long` 类型，分别用于表示长整型和无符号长整型。
- 新增`char16_t`和`char32_t`类型，分别用于表示16位和32位的字符。
- 添加"原始"字符串.

## 统一的初始化(使用大括号)
C++11开始, 新增了`大括号{}`括起来的初始化列表. 它可以适用于所有类型.
- 在 `new` 运算符中如果需要初始化, 很多情况下都会选择用`{}`
- 类的构造函数中常常使用.
    ```cpp
    class abc
    {
        private:
            int a, b, c;
        public:
            abc(int a, int b, int c) : a(a), b(b), c(c) {};
    };

    // 使用时:
    abc s1(1, 2, 3);        // 传统的初始化方式
    abc s2{1, 2, 3};        // 使用 {} 初始化
    abc s3 = {1, 2, 3};     // 使用 {} 初始化
    ```

### 变量值的"缩窄"问题
使用大括号初始化时, 如果初始化列表中的值超出了变量的表示范围, 编译器会报错.
- 可以提示程序员, 防止出现意外的变量值的"缩窄"
    ```cpp
    // 注: char 类型的范围是 -128 ~ 127
    char c1 = 23456789;     // 编译器不会报错, 但是这个数值肯定是存不下的, 此时将触发 "未知的行为"

    char c1 = {23456789};   // 编译器直接报错, 不允许这么写
    ```


### initializer_list
中文书 page 725 有详细讲解.

对于STL中的容器, 它的用法很简单:
```cpp
vector<int> a1(10);   // 创建一个大小为10的vector, 元素值都是0
vector<int> a2{10};   // 创建一个大小为1的vector, 元素值是10
vector<int> a3{10, 20, 30}; // 创建一个大小为3的vector, 元素值分别是10, 20, 30
```

普通函数中的使用:
- 可以将`initializer_list`作为函数的参数, 用于接收初始化列表.
    ```cpp
    #include <initializer_list>
    double sum(std::initializer_list<double> il)
    {
        double total = 0;
        for (auto p = il.begin(); p != il.end(); p++)
            total += *p;
        return total;
    }

    int main(void)
    {
        double total = sum({2.5, 3.6, 4.7}); 
        return 0;
    }
    ```

## 声明
### auto
编译器自动推断变量的类型, 可以简化我们的代码.
- 但注意: 这样写其实不少公司不推荐, 因为可读性太差了.
    ```cpp
    auto n = 100;       // n 是 int 类型
    auto x = 1.5;       // x 是 double 类型
    auto y = 1.5L;      // y 是 long double 类型
    auto z = 1.5F;      // z 是 float 类型
    auto c = 'a';       // c 是 char 类型
    auto s = "hello";   // s 是 const char * 类型
    ```

- 优点是, 有些类型比较长, 如函数指针, 用`auto`可以简化代码.
    ```cpp
    double func (double, int);      // 需要显式初始化

    // 传统写法
    void (*pf)(int, int) = func;

    // 使用 auto
    auto pf = func;
    ```

### decltype
中文书 page 295 (第8章).
它的作用是`将表达式的类型作为变量的类型`.
```cpp
double x = 1.5;
int n;
decltype (x*n) q;  // q 由 (x*n) 得到的类型来确定

// decltype 的一个特殊场景: 如果表达式使用了两个括号括起来, 并且表达式的结果是一个左值, 那么 decltype 将返回一个 "引用" 类型.
decltype ((x)) y;    // 由于 x 是一个 "左值", 此时 y 的类型是 double &

```

常用的场景 -- **定义的模板(类/函数)中存在多个类型**
```cpp
template <class T, class U>
void ef(T t, U u)
{
    decltype (t + u) sum;
    decltype (t * u) product;
    // ...
}
```

### 返回类型后置
中文书 page 296 (第8章).
新语法: 在函数名和参数列表之后, 使用`->`指定返回类型.
```cpp
template <class T, class U>
auto ef(T t, U u) -> decltype (t + u)           // 返回类型后置, 前面先用 auto 占位, 后面再用  "-> decltype(表达式)" 确定返回类型
{
    return t + u;
}
```


### 模板别名 (using = )
中文书 page 593 (第14章)
我们常用的起别名的方式一般是`typedef`, 现在还有另一种用法, 就是使用`using = `关键字.
```cpp
typedef std::vector<std::string>::iterator itType;  // typdef 写法
using itType = std::vector<std::string>::iterator;
```

它们的区别是:
- `typedef` 一定要用在 **确定类型的别名** 身上
- `usin =` 的方式可以用在 **模板** 上, 用于指定模板的类型参数.
    ```cpp
    template <typename T>
    using arr12 = std::array<T, 12>;    // arr12 是一个模板别名, 用于生成一个大小为12的数组

    // 使用的时候
    arr12<double> a1;       // 等价于 std::array<double, 12> a1;
    arr12<std::string> a2;  // 等价于 std::array<std::string, 12> a2;
    ```

### 空指针 nullptr
C++ 之前一般使用`0表示空指针`, 到现在其实也还能这么用. C++11之后一般用 nullptr 使得代码更容易读.


### 智能指针
具体查看第16章.
注意 C++11 已经抛弃了 auto_ptr.


### 异常规范的修改
特地写某些地方会抛出异常, 这种做法其实用得不多, 用的多的反而是`指出什么地方不会引发异常`, 也就是使用`noexcept`关键字.
```cpp
void test123() noexcept;    // 表示 test123 不会抛出异常
```

## 作用域内枚举
在定义枚举量时, 使用 class 来防止枚举量冲突.
```cpp
/*
    enum color {red, yellow, green};   // 传统的枚举量定义方式
    enum stoplight {red, yellow, green};   // 会报错, 因为 red, yellow, green 已经被定义过了
*/

enum class color {red, yellow, green};   // 使用 class 来定义枚举量, 防止冲突
enum class stoplight {red, yellow, green};   // 不会报错, 因为枚举量的作用域被限制在了 class 内部
``` 


## 对类进行修改

### 显式转换运算符
详细内容在第11章笔记里的`转换函数`部分(中文书 page 519 页).
- 但是需要强调一下, 转换函数其实是`将类的对象转换为其他数据类型`. 而这里提到的隐式转换是`将其他数据类型转换为类的对象`.

为了**防止隐式转换**, 可以使用`explicit`关键字来修饰**构造函数**, 此时就需要显式地调用类构造函数才能完成转换.
```cpp
class abc
{
    private:
        int a;
    public:
        explicit abc(int a) : a(a) {};   // 使用 explicit 关键字修饰构造函数, 防止隐式转换
}

// 使用时:
abc s1(1);      // 正确, 显式调用构造函数
abc s2 = 1;     // 错误, 由于 explicit 关键字, 不能隐式调用构造函数
```

### 类内成员的初始化
从C++11开始, 类的成员变量可以在声明的时候直接初始化.


## 模板和STL方面的修改
### 基于范围的for循环
中文书 page 684.
```cpp
double price[5] = {1, 2, 3, 4, 5};
for (double x : price){         // 这就是基于范围的for循环用法
    cout << x << endl;
}
```


### 新增的容器
- forward_list,
- unordered_map, 
- unordered_multimap, 
- unordered_set, 
- unordered_multiset.

详见中文书的第16章.


### 新增的STL方法
这些方法都返回迭代器, 并将元素视为const:
- cbein()
- cend()
- rbegin()
- rend()

### valarray
中文书 page 720 页.
可回顾第十六章笔记.

## 摒弃 export
C++11之后不再推荐使用 export, 但是功能还没删. (C++98中很常用)


## 尖括号
为了防止与`>>`混淆, 通常要求写为`> >`(中间有个空格). 在C++11中, 不再作这个要求, 原因就是难看...
- 但是发现 mac 使用的 g++ 编译器默认仍然有这个要求, 可能是没有使用参数`-std=c++11`的锅.


## 右值引用
第八章笔记有讲解.



