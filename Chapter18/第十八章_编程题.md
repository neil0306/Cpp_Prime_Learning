# 题目
![](第十八章_编程题_images/第十八章_编程题_1-4.png)

# 1.
涉及知识点是`输入参数类型不匹配时可以用强制类型转换`, 中文书 Page 288 页:
```cpp
// 书中的例子
template <typename T>
T Add(T a, T b)
{
    return a + b;
}

int m = 6;
double x = 10.2;
Add<double>(x, m);  // 将模板函数 Add 强行用double类型实例化, 并将参数m强制转换为double类型, 与函数 Add<double>(double x, double y) 匹配
```

题解:
```cpp
#include <iostream>
#include <initializer_list>

using namespace std;

template <class T>
T average_list(initializer_list<T> i)
{
    T sum = 0;
    int count = 0;
    for (auto p = i.begin(); p < i.end(); p++){
        count++;
        sum += *p;
    }
    return sum / count;
}

int main(void)
{
    // double 类型
    auto q = average_list({15.4, 10.7, 9.0});
    cout << q << endl;

    // int 类型
    cout << average_list({20, 30, 19, 17, 45, 38}) << endl;

    // 强制类型转换
    auto ad = average_list<double>({'A', 70, 65.33});
    cout << ad << endl;

    return 0;
}
```

# 2.
拷贝赋值运算符涉及知识点 (中文书 447 页):
```txt
赋值运算符的书写套路:
1. 判断是否为自身
2. 删除当前对象里的变量
3. new一段新空间给当前对象
4. 从传入对象中拷贝数据
```


题解:
```cpp
#include <iostream>
#include <string> 

using namespace std;

class Cpmv
{
	public:
		struct Info
		{
			string qcode;
			string zcode;
		};
	private:
		Info *pi;
	public:
		Cpmv();
		Cpmv(string g, string z);
		Cpmv(const Cpmv &cp);
		Cpmv(Cpmv &&mv);
		~Cpmv();
		Cpmv &operator=(const Cpmv &cp);
		Cpmv &operator=(Cpmv &&mv);
		Cpmv operator+(const Cpmv &obj) const;
		void Display() const;
};

Cpmv::Cpmv()
{
    pi = nullptr;
    cout << "default construction. " << endl;
}

Cpmv::Cpmv(string q, string z)
{
    pi = new Info();
    pi->qcode = q;
    pi->zcode = z;
    cout << "Construction with arguments." << endl;
}

Cpmv::Cpmv(const Cpmv &cp)
{
    pi = new Info();
    pi->qcode = cp.pi->qcode;
    pi->zcode = cp.pi->zcode;
    cout << "Copy Construction." << endl;
}

Cpmv::Cpmv(Cpmv &&mv)
{
    pi = mv.pi;         // 所有权转移
    mv.pi = nullptr;
    cout << "Move construction." << endl;
}

Cpmv::~Cpmv()
{
    delete pi;
    cout << "Deconstructino." << endl;
}

Cpmv & Cpmv::operator=(const Cpmv &cp)
{
    // 赋值运算符的书写套路:
    // 1. 判断是否为自身
    // 2. 删除当前对象里的变量
    // 3. new 一段新空间给当前对象
    // 4. 从传入对象中拷贝数据

    if(this == &cp){
        return *this;
    }

    delete pi;

    pi = new Info();
    pi->qcode = cp.pi->qcode;
    pi->zcode = cp.pi->zcode;

    cout << "Assignment construction function." << endl;

    return *this;
}

Cpmv & Cpmv::operator=(Cpmv &&mv)
{
    // 赋值运算符的书写套路:
    // 1. 判断是否为自身
    // 2. 删除当前对象里的变量
    // 3. new 一段新空间给当前对象
    // 4. 从传入对象中拷贝数据

    if(this == &mv){
        return *this;
    }
    delete pi;
    pi = mv.pi;
    mv.pi = nullptr;

    cout << "Move assignment construction function." << endl;
    return *this;
}

Cpmv Cpmv::operator+(const Cpmv &obj) const
{
    cout << "operator+" << endl;
    return Cpmv((pi->qcode + obj.pi->qcode), (pi->zcode + obj.pi->zcode));
}

void Cpmv::Display() const
{
    cout << "Display info" << endl;
    if(pi == nullptr){
        cout << "Pi is null!" << endl;
    }
    cout << "Address: " << pi << endl;
    cout << "qcode: " << pi->qcode << endl;
    cout << "zcode: " << pi->zcode << endl;
}

int main(void)
{
    Cpmv cp1("C", "C++");
	Cpmv cp2("computer", "language");

	Cpmv cp3(cp2);
	cp2 = cp1;
	Cpmv cp4(cp1 + cp2);

    return 0;
}
```


