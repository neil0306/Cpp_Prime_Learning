# 题目
![](第十八章_编程题_images/第十八章_编程题_1-4.png)

# 1.
涉及知识点是`输入参数类型不匹配时可以用强制类型转换`, 中文书 Page 288 页:
```cpp
// 书中的例子
template <typename T>
T Add(T a, T b)
{
    return a + b;
}

int m = 6;
double x = 10.2;
Add<double>(x, m);  // 将模板函数 Add 强行用double类型实例化, 并将参数m强制转换为double类型, 与函数 Add<double>(double x, double y) 匹配
```

题解:
```cpp
#include <iostream>
#include <initializer_list>

using namespace std;

template <class T>
T average_list(initializer_list<T> i)
{
    T sum = 0;
    int count = 0;
    for (auto p = i.begin(); p < i.end(); p++){
        count++;
        sum += *p;
    }
    return sum / count;
}

int main(void)
{
    // double 类型
    auto q = average_list({15.4, 10.7, 9.0});
    cout << q << endl;

    // int 类型
    cout << average_list({20, 30, 19, 17, 45, 38}) << endl;

    // 强制类型转换
    auto ad = average_list<double>({'A', 70, 65.33});
    cout << ad << endl;

    return 0;
}
```

# 2.
拷贝赋值运算符涉及知识点 (中文书 447 页):
```txt
赋值运算符的书写套路:
1. 判断是否为自身
2. 删除当前对象里的变量
3. new一段新空间给当前对象
4. 从传入对象中拷贝数据
```


题解:
```cpp
#include <iostream>
#include <string> 

using namespace std;

class Cpmv
{
	public:
		struct Info
		{
			string qcode;
			string zcode;
		};
	private:
		Info *pi;
	public:
		Cpmv();
		Cpmv(string g, string z);
		Cpmv(const Cpmv &cp);
		Cpmv(Cpmv &&mv);
		~Cpmv();
		Cpmv &operator=(const Cpmv &cp);
		Cpmv &operator=(Cpmv &&mv);
		Cpmv operator+(const Cpmv &obj) const;
		void Display() const;
};

Cpmv::Cpmv()
{
    pi = nullptr;
    cout << "default construction. " << endl;
}

Cpmv::Cpmv(string q, string z)
{
    pi = new Info();
    pi->qcode = q;
    pi->zcode = z;
    cout << "Construction with arguments." << endl;
}

Cpmv::Cpmv(const Cpmv &cp)
{
    pi = new Info();
    pi->qcode = cp.pi->qcode;
    pi->zcode = cp.pi->zcode;
    cout << "Copy Construction." << endl;
}

Cpmv::Cpmv(Cpmv &&mv)
{
    pi = mv.pi;         // 所有权转移
    mv.pi = nullptr;
    cout << "Move construction." << endl;
}

Cpmv::~Cpmv()
{
    delete pi;
    cout << "Deconstructino." << endl;
}

Cpmv & Cpmv::operator=(const Cpmv &cp)
{
    // 赋值运算符的书写套路:
    // 1. 判断是否为自身
    // 2. 删除当前对象里的变量
    // 3. new 一段新空间给当前对象
    // 4. 从传入对象中拷贝数据

    if(this == &cp){
        return *this;
    }

    delete pi;

    pi = new Info();
    pi->qcode = cp.pi->qcode;
    pi->zcode = cp.pi->zcode;

    cout << "Assignment construction function." << endl;

    return *this;
}

Cpmv & Cpmv::operator=(Cpmv &&mv)
{
    // 赋值运算符的书写套路:
    // 1. 判断是否为自身
    // 2. 删除当前对象里的变量
    // 3. new 一段新空间给当前对象
    // 4. 从传入对象中拷贝数据

    if(this == &mv){
        return *this;
    }
    delete pi;
    pi = mv.pi;
    mv.pi = nullptr;

    cout << "Move assignment construction function." << endl;
    return *this;
}

Cpmv Cpmv::operator+(const Cpmv &obj) const
{
    cout << "operator+" << endl;
    return Cpmv((pi->qcode + obj.pi->qcode), (pi->zcode + obj.pi->zcode));
}

void Cpmv::Display() const
{
    cout << "Display info" << endl;
    if(pi == nullptr){
        cout << "Pi is null!" << endl;
    }
    cout << "Address: " << pi << endl;
    cout << "qcode: " << pi->qcode << endl;
    cout << "zcode: " << pi->zcode << endl;
}

int main(void)
{
    Cpmv cp1("C", "C++");
	Cpmv cp2("computer", "language");

	Cpmv cp3(cp2);
	cp2 = cp1;
	Cpmv cp4(cp1 + cp2);

    return 0;
}
```


# 3.
代码套路:
```cpp
/*
    1. 根据实际情况(返回类型等), 写一个不带参数的重载函数, 作为可变参数模板的递归终止条件
    2. 按照可变模板的语法, 定义函数模板
        为了方便解包, 一般模板参数写成两个, 一个是 value, 另一个则是表示剩余参数的 Args...
        为了使代码高效, 推荐使用 "按引用传递", 但是记得前面要加上 const, 防止传入的时候是右值引用
*/

// 不带参数的重载函数
某种返回类型 func_name() {}

// 可变参数模板
template<class T, class Args...>
某种返回类型 func_name(const T & value, const Args &... args)
{
    // 使用第一个参数的代码
    .......
    // 递归调用, 继续解包其它参数, args解包完之后, 由不带参数的重载函数结束递归
    func_name(args...);   // 别写漏了 ... 这三个点
    return xxx;
}
```

题解:
```cpp
#include <iostream>

using namespace std;

// 考虑一个参数都没有的时候(递归的终止条件)
long double sum_value(){ return 0.0; }

template <class T, class ... Args>
long double sum_value(const T & value, const Args & ...args)
{
    long double total;
    total = (long double)value + sum_value(args...);         // 解包, 注意value的类型不确定, 所以需要加一个强制类型转换
    return total;
}

int main(void)
{
    cout << sum_value(1, 2, 3, 4, 5) << endl;
    cout << sum_value('a', 'b', 2.2, 3.3, 5, 6, 7) << endl;
    return 0;
}
```
