
# 题目
![](第十二章_编程题_images/第十二章_编程题_1.png)
![](第十二章_编程题_images/第十二章_编程题_2_1.png)
![](第十二章_编程题_images/第十二章_编程题_2_2.png)
![](第十二章_编程题_images/第十二章_编程题_2_3.png)
![](第十二章_编程题_images/第十二章_编程题_3-6.png)


# 1.
头文件 `cow.h`
```cpp
#ifndef __COW_H__
#define __COW_H__

#include <iostream>

using namespace std;

class Cow
{
    private:
        char name[20];
        char * hobby;
        double weight;
    public:
        Cow();
        Cow(const char * nm, const char * ho, double wt);
        Cow(const Cow &c);
        ~Cow();
        Cow & operator=(const Cow &c);
        void ShowCow() const;
};

#endif //!__COW_H__
```

- `cow.cpp`
```cpp
#include "cow.h"
#include <cstring>      // 使用 strncpy, 指定拷贝长度

Cow::Cow()
{
    name[0] = '\0';
    hobby = nullptr;
    weight = 0.0;
}

Cow::Cow(const char *nm, const char * ho, double wt)
{
    // name 用的是浅拷贝, 只拷贝了内容, 没有新增空间
    strncpy(name, nm, 20);
    if(strlen(nm) >= 20){
        name[19] = '\0';        // 如果nm里面的字符串长度 >= 20, 则name的最后一个字符改为空字符
    }

    // hobby 使用深拷贝, 不仅拷贝内容, 还要新开辟空间
    hobby = new char [strlen(ho) + 1];  // 动态开辟空间
    strcpy(hobby, ho);

    weight = wt;
}

Cow::Cow(const Cow &c)
{
    strcpy(name, c.name);
    hobby = new char[strlen(c.hobby)+1];
    strcpy(hobby, c.hobby);
    weight = c.weight;
}

Cow::~Cow()
{
    delete [] hobby;
}

Cow & Cow::operator=(const Cow &c)
{
    // step1: 防止自己拷贝给自己
    if(this == &c){
        return *this;
    }

    // step2: 如果需要赋值, 则首先释放掉涉及动态开辟内存的数据成员, 然后重新开辟空间&拷贝数据
    delete [] hobby;
    hobby = new char[strlen(c.hobby)+1];
    strcpy(hobby, c.hobby);

    // step3: 处理其他常规数据成员
    strcpy(name, c.name);
    weight = c.weight;

    // step4: 返回当前对象的内容, 注意不是返回this指针
    return *this;
}

void Cow::ShowCow() const
{
    cout << "Name: " << name << endl;
    cout << "Hobby: " << hobby << endl; 
    cout << "Weight: " << weight << endl; 
}
```

- `main.cpp`
```cpp
#include "cow.h"
#include <iostream>
using namespace std;

int main(void)
{
    Cow cow1;           // 默认构造
    Cow cow2("cow2", "badminton", 123); // 自定义构造
    Cow cow3(cow2);     // 复制构造
    cow1 = cow2;        // 重载的赋值运算符

    cow1.ShowCow();
    cow2.ShowCow();
    cow3.ShowCow();

    return 0;
}
```

- 输出:
![](第十二章_编程题_images/编程题第一题输出.png)


# 2.
- 头文件 `string2.h`
```cpp
#ifndef __STRING2_H__
#define __STRING2_H__

#include <iostream>
using namespace std;

class String
{
    private:
        char *str;              // 存放的不是字符串, 而是字符串所在的地址!
        int len;

        static int num_strings; // 静态变量, 它不专属于任意一个对象, 而是所有对象共享的
                                /* 它只会被初始化一次(需要额外写一个初始化), 所有定义的对象都共享这个成员变量, 这种变量常用于统计这个类一共有多少个对象 */
        static const int CINLIMIT = 80;     // 限制输入字符的最大值

    public:
        String(const char *s);
        String();
        String(const String &st);       // 复制构造函数
        ~String();           // 一般在动态分配内存的场景下, 会把delete语句写在这里

        int length() const
        {
            return len;
        }

        // 重载赋值运算符, 由于赋值运算符本身要求左侧是类的对象, 所以可以不定义成友元函数
        String & operator=(const String &st);
        String & operator=(const char *st);       // 直接传入一个字符串

        char & operator[](int i);                       // 重载索引运算
        const char & operator[](int i) const;

        friend bool operator<(const String &str1, const String &str2);
        friend bool operator>(const String &str1, const String &str2);
        friend bool operator==(const String &str1, const String &str2);

        friend ostream & operator<<(ostream &os, const String &st);
        friend istream & operator>>(istream &is, String &st);

        static int HowMany();       // 静态函数, 不属于任何一个对象, 它用来返回对象的个数

    // 编程题2新增的成员函数(5个):
    public:
        friend String operator+(const char *s, const String &st);     // 用char *s 表示一个字符串
        String operator+(const String &st);
        void stringlow();
        void stringup();
        int has(char c) const;
};

#endif //!__STRING2_H__
```

- `string2.cpp`
```cpp
#include "string2.h"
#include <cstring>      // 调用统计字符串长度的函数strlen
#include <cctype>       // 调用大小写转换函数

/* 首先处理一下静态变量 num_string:
    1. 这个变量的初始化 **不可以** 放在"构造函数"或"类的声明的任意位置", 因为这个变量不专属于任意一个对象, 它是共享的
    2. 静态变量是独立于对象存储的, 它于类的对象在内存中的存放区域不一样.
    3. 这种变量的初始化一般不要放在头文件中, 因为头文件可能会被个位置include, 导致初始化语句有多条, 一般只放在 定义类方法的cpp 文件中
    4. 初始化该变量时, 不需要再写 static, 需要使用作用域运算符::来指定它所属的类
*/
int String::num_strings = 0;     

int String::HowMany()           // 静态函数
{
    return num_strings;
}

String::String(const char *s)
{
    len = strlen(s);
    str = new char[len + 1];        // new 了一块内存用于存放传入的字符串, 不然跑完这个函数之后, s里的东西就会被系统删掉
    strcpy(str, s);                 // 把s的内存拷贝到开辟的内存空间中
    num_strings++;
}

String::String()
{
    len = 0;
    str = new char[1];
    str[0] = '\0';
    num_strings++;
}

String::String(const String &st)
{
    len = st.len;
    str = new char[len + 1];        // new 了一块内存用于存放传入的字符串
    strcpy(str, st.str);            // 把st的内容拷贝一份
    num_strings++;
}

String::~String()
{
    num_strings--;
    delete[] str;       // 别漏了 [], 因为是字符数组!
} 

String & String::operator=(const String &st)
{
    if (&st == this){       // 如果是 自己 赋值给 自己, 则不需要执行任何操作
        return *this;
    }
    delete [] str; // 因为要把临时的对象赋值给原有对象, 而且原来的对象是new出来, 故需要先删除原对象, 防止内存泄露
    len = st.len;
    str = new char[len + 1];    // 重新开辟地址, 用来存储st对象里的内容
    strcpy(str, st.str);
    return *this;       // 返回当前对象本身
}

String & String::operator=(const char *st)
{
    delete [] str; // 因为要把临时的对象赋值给原有对象, 而且原来的对象是new出来, 故需要先删除原对象, 防止内存泄露
    len = strlen(st);
    str = new char[len + 1];    // 重新开辟地址, 用来存储st对象里的内容
    strcpy(str, st);
    return *this;       // 返回当前对象本身
}

char & String::operator[](int i)        // 这里没有const
{
    return str[i];
}

const char & String::operator[](int i) const    // 这里加了const, 表示不能修改任何东西
{
    return str[i];
}

bool operator<(const String &str1, const String &str2)
{
    return (strcmp(str1.str, str2.str) < 0);
}

bool operator>(const String &str1, const String &str2)
{
    return str1 < str2;     // 使用了上面定义的运算符重载
}

bool operator==(const String &str1, const String &str2)
{
    return (strcmp(str1.str, str2.str) == 0);
}

ostream &operator<<(ostream &os, const String &st)
{
    os << st.str;
    return os;
}

istream & operator>>(istream &is, String &st)
{
    char temp[String::CINLIMIT];
    is.get(temp, String::CINLIMIT); // 先捕获字符, 再拷贝到对象里
    if(is){
        st = temp;      // 调用前面重载的赋值运算符 (到这里只会捕获 String::CINLIMIT 个字符, 超出部分仍留在缓冲区)
    }
    while (is && is.get()!='\n')   // 如果输入的内容太长, 则需要清空缓存 
        continue;
    return is;
}


// 编程题2新增的5个函数
String operator+(const char *s, const String &st)
{
    String temp;

    temp.len = strlen(s) + st.len;
    temp.str = new char[temp.len + 1];
    strcpy(temp.str, s);            // s位于操作符左侧, 所以先拷贝s的内容
    strcat(temp.str, st.str);       // 用 strcat 进行追加写

    return temp;
}

String String::operator+(const String &st)
{
    String temp;

    temp.len = len + st.len;
    temp.str = new char[temp.len + 1];
    strcpy(temp.str, str);          // 此时当前对象在操作符左侧, 所以先拷贝str
    strcat(temp.str, st.str);       // 用 strcat 追加写

    return temp;
}

void String::stringlow()
{
    for (int i = 0; i < len; i++){
        str[i] = tolower(str[i]);
    }
}

void String::stringup()
{
    for (int i = 0; i < len; i++){
        str[i] = toupper(str[i]);
    }
}

int String::has(char c) const
{
    int count = 0;
    for (int i = 0; i < len; i++){
        if(str[i] == c)
        {
            count++;
        }
    }

    return count;
}
```

- `main.cpp`
```cpp
#include <iostream>
#include "string2.h"
using namespace std;

int main(void)
{
    String s1(" and I am a C++ student.");
    String s2 = "Please enter your name: ";
    String s3;

    cout << s2;
    cin >> s3;

    s2 = "My name is " + s3;
    cout << s2 << ".\n";

    s2 = s2 + s1;
    s2.stringup();
    cout << "The string \n" << s2 << "\ncontains " << s2.has('A')
        << " 'A' characters in it.\n";
    
    s1 = "red";

    String rgb[3] = {String(s1), String("green"), String("blue")};
    cout << "Enter the name of a primary color for mixing light: ";
    String ans;
    bool success  = false;
    while (cin >> ans){
        ans.stringlow();
        for (int i = 0; i < 3; i++){
            if (ans == rgb[i]){
                cout << "That's right!\n";
                success = true;
                break;
            }
        }

        if (success)
            break;
        else{
            cout << "Try again!\n";
        }
    }

    cout << "Bye!" << endl;
    return 0;
}
```

输出:
![](第十二章_编程题_images/编程题第二题输出.png)

