# 类和动态内存分配

## 代码例子 -- StringBad 类
- 头文件 `stringbad.h`
```cpp
#ifndef __STRINGBAD_H__
#define __STRINGBAD_H__

#include <iostream>
using namespace std;

class StringBad
{
    private:
        char *str;              // 存放的不是字符串, 而是字符串所在的地址!
        int len;

        static int num_strings; // 静态变量, 它不专属于任意一个对象, 而是所有对象共享的
                                /* 它只会被初始化一次(需要额外写一个初始化), 所有定义的对象都共享这个成员变量, 这种变量常用于统计这个类一共有多少个对象 */

    public:
        StringBad(const char *s);
        StringBad();
        ~StringBad();           // 一般在动态分配内存的场景下, 会把delete语句写在这里

        friend ostream & operator<<(ostream &os, const StringBad &st);
};

#endif //!__STRINGBAD_H__
```
- 源文件 `stringbad.cpp`
```cpp
#include "stringbad.h"
#include <cstring>      // 调用统计字符串长度的函数strlen

/* 首先处理一下静态变量 num_string:
    1. 这个变量的初始化 **不可以** 放在"构造函数"或"类的声明的任意位置", 因为这个变量不专属于任意一个对象, 它是共享的
    2. 静态变量是独立于对象存储的, 它于类的对象在内存中的存放区域不一样.
    3. 这种变量的初始化一般不要放在头文件中, 因为头文件可能会被个位置include, 导致初始化语句有多条, 一般只放在 定义类方法的cpp 文件中
    4. 初始化该变量时, 不需要再写 static, 需要使用作用域运算符::来指定它所属的类
*/
int StringBad::num_strings = 0;     

StringBad::StringBad(const char *s)
{
    len = strlen(s);
    str = new char[len + 1];        // new 了一块内存用于存放传入的字符串, 不然跑完这个函数之后, s里的东西就会被系统删掉
    strcpy(str, s);                 // 把s的内存拷贝到开辟的内存空间中
    num_strings++;
    cout << num_strings << ": \"" << str << ".\"" << endl;
}

StringBad::StringBad()
{
    len = 4;
    str = new char[4];
    strcpy(str, "C++");
    num_strings++;
    cout << num_strings << ": \"" << str << ".\"" << endl;
}

StringBad::~StringBad()
{
    cout << "\"" << str << "\" Object Deleted." << endl;
    num_strings--;
    cout << num_strings << " objects left" << endl;
    delete[] str;       // 别漏了 [], 因为是字符数组!
} 

ostream & operator<<(ostream &os, const StringBad &st)
{
    os << st.str;
    return os;
}
```

- 主函数 `vegnews.cpp`
```cpp
#include <iostream>
#include "stringbad.h"

void callme1(StringBad &rsb);       // 按引用传递
void callme2(StringBad rsb);        // 按值传递


int main(void)
{
    StringBad headline1("Hello World!");
    StringBad headline2("Good morning.");
    StringBad sport("I love you Rick");

    cout << "Headline1: " << headline1 << endl; 
    cout << "Headline2: " << headline2 << endl; 
    cout << "Sport: " << sport << endl; 

    callme1(headline1);     // 一切正常
    callme2(headline1);   // 调用按值传递的函数报错了
    return 0;
}

void callme1(StringBad &rsb)    // 按引用传递
{
    cout << "String passed by reference: " << rsb << endl;
}
void callme2(StringBad rsb)     // 按值传递
{
    cout << "String passed by value: " << rsb << endl;
}
```

程序输出如下:
![](十二章笔记_images/StringBad代码例子_调用按值传递出错.png)
- 报错原因分析
    ```txt
    1. 首先, 我们在主函数中定义了三个对象, 触发了三次构造函数, 此时会使用 new 动态开辟内存空间.
    2. 然后, 在调用callme2函数时, 会触发一次由编译器自动生成的 `拷贝构造函数` , 用于把headline1对象拷贝到rsb对象中, 此时 没有使用 new !!!!

        此时一共触发了4次构造函数, 拷贝构造函数也是构造函数.

    3. main函数结束时, 开始进行析构, 会调用4次次析构函数, 释放三次new出来的内存空间, 但是由于rsb对象没有使用 new, 所以执行到析构函数的 delete 语句时程序出错.
    ```
    - 关于`拷贝构造函数`:
      - 在我们调用 `callme2` 函数时, 进行的是按值传递, 此时 headline1 相当于执行了` StringBad rsb = headline1; ` 这样的语句, 它等价于`StringBad rsb = StringBad(headline1)`, 而这行代码对应的函数原型是 `StringBad(const StringBad &rsb);`, 也就是拷贝构造函数.
        - 如果我们没有自定义拷贝构造函数, 编译器会自动提供一个默认的.
