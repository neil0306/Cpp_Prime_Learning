# 类和动态内存分配

## 代码例子 -- StringBad 类
- 头文件 `stringbad.h`
```cpp
#ifndef __STRINGBAD_H__
#define __STRINGBAD_H__

#include <iostream>
using namespace std;

class StringBad
{
    private:
        char *str;              // 存放的不是字符串, 而是字符串所在的地址!
        int len;

        static int num_strings; // 静态变量, 它不专属于任意一个对象, 而是所有对象共享的
                                /* 它只会被初始化一次(需要额外写一个初始化), 所有定义的对象都共享这个成员变量, 这种变量常用于统计这个类一共有多少个对象 */

    public:
        StringBad(const char *s);
        StringBad();
        ~StringBad();           // 一般在动态分配内存的场景下, 会把delete语句写在这里

        friend ostream & operator<<(ostream &os, const StringBad &st);
};

#endif //!__STRINGBAD_H__
```
- 源文件 `stringbad.cpp`
```cpp
#include "stringbad.h"
#include <cstring>      // 调用统计字符串长度的函数strlen

/* 首先处理一下静态变量 num_string:
    1. 这个变量的初始化 **不可以** 放在"构造函数"或"类的声明的任意位置", 因为这个变量不专属于任意一个对象, 它是共享的
    2. 静态变量是独立于对象存储的, 它于类的对象在内存中的存放区域不一样.
    3. 这种变量的初始化一般不要放在头文件中, 因为头文件可能会被个位置include, 导致初始化语句有多条, 一般只放在 定义类方法的cpp 文件中
    4. 初始化该变量时, 不需要再写 static, 需要使用作用域运算符::来指定它所属的类
*/
int StringBad::num_strings = 0;     

StringBad::StringBad(const char *s)
{
    len = strlen(s);
    str = new char[len + 1];        // new 了一块内存用于存放传入的字符串, 不然跑完这个函数之后, s里的东西就会被系统删掉
    strcpy(str, s);                 // 把s的内存拷贝到开辟的内存空间中
    num_strings++;
    cout << num_strings << ": \"" << str << ".\"" << endl;
}

StringBad::StringBad()
{
    len = 4;
    str = new char[4];
    strcpy(str, "C++");
    num_strings++;
    cout << num_strings << ": \"" << str << ".\"" << endl;
}

StringBad::~StringBad()
{
    cout << "\"" << str << "\" Object Deleted." << endl;
    num_strings--;
    cout << num_strings << " objects left" << endl;
    delete[] str;       // 别漏了 [], 因为是字符数组!
} 

ostream & operator<<(ostream &os, const StringBad &st)
{
    os << st.str;
    return os;
}
```

- 主函数 `vegnews.cpp`
```cpp
#include <iostream>
#include "stringbad.h"

void callme1(StringBad &rsb);       // 按引用传递
void callme2(StringBad rsb);        // 按值传递


int main(void)
{
    StringBad headline1("Hello World!");
    StringBad headline2("Good morning.");
    StringBad sport("I love you Rick");

    cout << "Headline1: " << headline1 << endl; 
    cout << "Headline2: " << headline2 << endl; 
    cout << "Sport: " << sport << endl; 

    callme1(headline1);     // 一切正常
    callme2(headline2);   // 调用按值传递的函数报错了
    return 0;
}

void callme1(StringBad &rsb)    // 按引用传递
{
    cout << "String passed by reference: " << rsb << endl;
}
void callme2(StringBad rsb)     // 按值传递
{
    cout << "String passed by value: " << rsb << endl;
}
```

程序输出如下:
![](十二章笔记_images/StringBad代码例子_调用按值传递出错.png)
- 报错原因分析
    ```txt
    1. 首先, 我们在主函数中定义了三个对象, 触发了三次构造函数, 此时会使用 new 动态开辟内存空间.
    2. 然后, 在调用callme2函数时, 会触发一次由编译器自动生成的 `拷贝构造函数` , 用于把headline1对象拷贝到rsb对象中, 此时 没有使用 new !!!!

        此时一共触发了4次构造函数, 拷贝构造函数也是构造函数.

    3. main函数结束时, 开始进行析构, 会调用4次次析构函数, 释放三次new出来的内存空间, 但是由于rsb对象没有使用 new, 所以执行到析构函数的 delete 语句时程序出错.
    ```
    - 关于`拷贝构造函数`:
      - 在我们调用 `callme2` 函数时, 进行的是按值传递, 此时 headline1 相当于执行了` StringBad rsb = headline1; ` 这样的语句, 它等价于`StringBad rsb = StringBad(headline1)`, 而这行代码对应的函数原型是 `StringBad(const StringBad &rsb);`, 也就是拷贝构造函数.
        - 如果我们没有自定义拷贝构造函数, 编译器会自动提供一个默认的.


### C++ 在类中自动提供的成员函数
如果我们在定义类的时候没有自定义下面的成员函数, 则编译器会默认提供一个.
1. 默认构造函数
2. 默认析构函数
3. 复制构造函数
4. 赋值运算符
5. 地址运算符


对于拷贝构造函数/复制构造函数:
- 在程序生成副本时就会调用, 如:
  - 函数按值传递
  - 函数 return (返回类的对象时)

因此, 对于前面的例子, 我们只需要自定义一个拷贝构造函数就可以解决这个bug
```cpp
    // 在头文件的类声明中增加拷贝构造函数的声明
    StringBad(const StringBad &st);       // 复制构造函数

    // 在定义中增加拷贝构造函数的定义
    StringBad::StringBad(const StringBad &st)
    {
        len = st.len;
        str = new char[len + 1];        // new 了一块内存用于存放传入的字符串
        strcpy(str, st.str);            // 把st的内容拷贝一份
        num_strings++;
        cout << num_strings << ": \"" << str << ".\"" << endl;
    }
```
此时, 程序运行正常, 输出如下(有4次构造, 4次析构):
![](十二章笔记_images/StringBad代码例子_调用按值传递调用自定义拷贝构造函数.png)

还有一个需要注意的是, 在不同的编译环境下, 触发析构错误的原因可能有两种:
- 一种是前面提到的`复制构造函数/拷贝构造函数`的问题
- 另一种则是由于`赋值运算符(=)`造成的
    ```txt
    前面提到, 在调用 callme2 函数时, 按值传递在传参的过程中会触发一次拷贝构造函数, 相当于执行语句:
        StringBad rsb = headline1;

        在不同的编译环境中, 这可能存在两种情况, 第一种是:
            StringBad rsb;      // 1. 先定义一个对象
            rsb = headline1;    // 2. 然后再赋值, 此时触发默认的  赋值运算符函数
        
        第二种则是前面提到的
            StringBad rsb = StringBad( headline1 );     // 直接触发拷贝构造函数
    ```
- 因此, 安全的做法是;
  - 既要`自定义拷贝构造函数`, 也要`自定义赋值运算符函数`.

  - 代码例子 -- 补充自定义的赋值运算符函数
    ```cpp
    // 重载赋值运算符, 由于赋值运算符本身要求左侧是类的对象, 所以可以不定义成友元函数
    StringBad & operator=(const StringBad &st);


    StringBad & StringBad::operator=(const StringBad &st)
    {
        if (&st == this){       // 如果是 自己 赋值给 自己, 则不需要执行任何操作
            return *this;
        }
        delete [] str; // 因为要把临时的对象赋值给原有对象, 而且原来的对象是new出来, 故需要先删除原对象, 防止内存泄露
        len = st.len;
        str = new char[len + 1];    // 重新开辟地址, 用来存储st对象里的内容
        strcpy(str, st.str);
        return *this;       // 返回当前对象本身
    }
    ```




