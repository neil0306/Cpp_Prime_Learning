# 对象和类
C++是面向对象(`OOP`)的语言, 它最重要特性有:
1. 抽象
2. 封装和数据隐藏
3. 多态
4. 继承
5. 代码的可重用性

## 类
类是一种`将抽象转换为用户定义类型的C++工具`, 它将`数据表示`和`操纵数据的方法`组合成一个整洁的包.

### 类的声明
1. 类的声明 (**放在头文件**): 需要包含数据成员, 成员函数(也就是`方法, method`)描述的公有接口(public interface)
2. 类方法的实现(**放在cpp文件**): 成员函数的具体实现代码.

- 对于类的名字, 有些习惯是把类名称的**首字母大写**.

类的声明例子`stock00.h`
```cpp
/*
    类的声明
*/
#ifndef __STOCH_00_H__
#define __STOCH_00_H__

#include <string>

class Stock
{
    private:  // 私有部分, 只有public里面的成员才能访问这部分内容(一般private的成员都是通过 public 间接访问的)
        std::string company;    // 公司名
        long shares;            // 股票数量
        double share_val;       // 股票单价
        double total_val;       // 股票总价值

        void setTotal(double &total_val) 
        {
            total_val = shares * share_val;
        }

    public:   // 公有部分, 任何代码都可以直接访问
        void acquire(const std::string &co, long n, double price);
        void buy(long num, double price);
        double sell(long num, double price);
        void update(double price);
        void show();


};  // 别忘记分号, 这和结构体的语法是相同的

#endif // __STOCH_00_H__
```
- private里面的setTotal函数在实例中是没办法直接访问的, 程序要在使用这个类的时候**只能直接使用public里面的部分**.
  - 要访问/改变 private 里面的成员, 只能通过 public 提供的函数接口 或者 使用`友元函数`(涉及到类的继承, 后面才讲到).
  - 一般来说, `类的数据部分通常都放在private里面`, 组成`类的接口部分一般放在public部分`.
  - 类的成员中, 如果不指明 public, 默认情况下都是`private`, 但是一般建议显示地写出来, 增加可读性.


注意:
- 在`类声明`中`定义的函数`, 会`自动转换为内联函数`! 比例上面例子中的`setTotal()`函数, 比较短, 符合内联函数的要求.
  - **只要把函数的具体定义给写到类的声明中, 这个函数就会被转换成内联函数**.
  - 如果希望"不写在类声明里的函数"也成为内联函数, 则可以通过`inline`关键字的方式将这个函数转成内联函数 (跟普通的内联函数定义方法是一样的).

### 类和结构体的异同
类其实是结构体的扩展, 他们的区别是:
- `结构体的默认访问类型是 public`, 而`类默认是 private`.
- C++中通常**使用类来实现类描述**, 而把**结构体限制为只表示存粹的数据对象**(普通老式数据, Plain Old Data, POD)
  - 简单来说就是: 只有数据 --> 用结构体; 有数据也有(方法)函数 --> 用类



### 类的成员函数实现
类的成员函数实现跟普通函数的实现对比, 主要有以下两个不同:
1. 定义成员函数时, 需要使用作用域解析运算符(`::`)来标识函数所属的类
2. 类方法`可以访问类的private组件`, 比如定义在 private 里面的变量等等.

类的成员函数实现例子`stock00.cpp`:
```cpp
/*
    类的成员函数实现
*/
#include <iostream>
#include "stock00.h"

void Stock::acquire(const std::string &co, long n, double price)
{
    company = co;       // 直接就访问到了private里的变量
    if(n < 0){
        std::cout << "Number of shares can't be negative! " << company << " shares set to be 0!" << std::endl;
        shares = 0;
    }
    else{
        shares = n;
    }

    share_val = price;
    setTotal();     // 直接调用了 private 里的函数
}

void Stock::buy(long num, double price)
{
    if(num < 0){
        std::cout << "Number of shares can't be negative! Transaction aborted!" << std::endl;
    }
    else{
        shares += num;      // 买入股票, 持有数量增加 num
        share_val = price;
        setTotal();
    }
}

void Stock::sell(long num, double price)
{
    if(num < 0){
        std::cout << "Number of shares can't be negative! Transaction aborted!" << std::endl;
    }
    else if(num > shares){
        std::cout << "You can't sell more than you have! Transaction is aborted!" << std::endl;
    }
    else{
        shares -= num;
        share_val = price;
        setTotal();
    }
}

void Stock::update(double price)
{
    share_val = price;
    setTotal();
}

void Stock::show()
{
    using namespace std;
    cout << "Company: " << company << endl;
    cout << "Shares: " << shares << endl;
    cout << "Share price" << share_val << endl;
    cout << "Total worth: " << total_val << endl;
}
```

### 类的使用
前面定义的 "Stock"类 的使用`usestock.cpp`:
```cpp
#include <iostream>
#include "stock00.h"
using namespace std;

int main(void)
{
    Stock fluffy_the_cat;  // 实例化了一个stock的对象
    fluffy_the_cat.acquire("NanoSmart", 20, 12.5);      // 买入一支股票
    fluffy_the_cat.show();                              // 显示结果

    cout << "-------" << endl;
    fluffy_the_cat.buy(15, 18.125);
    fluffy_the_cat.show();

    cout << "-------" << endl;
    fluffy_the_cat.sell(400, 20);
    fluffy_the_cat.show();

    cout << "-------" << endl;
    fluffy_the_cat.buy(300000, 40.125);
    fluffy_the_cat.show();

    cout << "-------" << endl;
    fluffy_the_cat.sell(300000, 0.125);
    fluffy_the_cat.show();

    return 0;
}
```

### 小结
1. 类的声明, 常见的情况是分为`private`和`public`两个部分(protect后面再讨论)
   - 对于`private`: 
     - 把数据放在这部分, 可以确保数据的完整性, 这个操作实现了`数据隐藏`.
     - private 里面的所有内容都可以通过`public定义的内容`**直接访问**.
   - 对于`public`:
     - 类进行实例化出一个对象后, 该对象能够直接访问的部分只有public, 如果希望这个对象能直接操作private里面的数据, 则需要使用public里面**事先定义好的函数间接地访问**.
2. 在**类的声明**里, 如果对**某个函数直接写了具体实现**, 则这个函数会被`自动转换为内联函数`
   - 如果希望**类的具体实现部**分的某个函数也成为内联函数, 则需要使用关联词`inline`.

3. 类的定义部分:
   - 函数名字的前面都需要使用作用域解析运算符(`::`)来表明这个函数属于哪个类.


## 类的构造函数和析构函数
### 构造函数
联想结构体, 我们可以发现结构体的初始化一般可以写成:
```cpp
struct abc
{
    int a;
    int b;
    int c;
};

abc test1 = {1, 2, 3};      // 结构体的初始化
```
但是对于类来说, 我们通常希望对数据部分进行保护(将数据定义在private里面), 此时我们就不能在初始化对象的时候像结构体那样初始化这些数据, 于是我们需要一种方式来初始化那些private里面的数据变量 --> 使用**类的构造函数**.
- 构造函数的任务就是`用来完成类的数据初始化`.

#### 定义构造函数
类的构造函数有以下特点:
1. 函数名字就是类的名字
2. 函数没有返回值, 也`不写 void`.


构造函数需要注意:
1. 类的构造函数的`参数列表不要出现与数据成员同名的变量`, 这会产生混乱.
   1. 方法1: 在变量名字前面加前缀`m_`, 如`m_company`.
   2. 方法2: 在变量名字后面加后缀`_`, 如`company_`.
2. 使用构造函数分为`显式使用`和`隐式使用` (看例子)
3. 默认构造函数: 如果在创建对象时没有显式地提供初始值, 则会调用默认构造函数.
   1. 默认构造函数什么都不干, 不会初始化任何成员变量.
   2. 当且仅当没有自定义构造函数时, 编译器才会提供默认构造函数.
      - 也就是说, 如果我们定义了一个构造函数, 此时如果想要再使用默认构造函数, 就需要自己写一个什么都不干的构造函数作为默认构造函数...
        - 也可以提供一个带默认值的构造函数, 但是`默认构造函数只能有一个`.
        ```cpp
        class Stock
        {
            public: 
                Stock(const std::string &co = "Error", long n = 0, double price = 0.0)
                {
                    company = co;
                    if(n < 0){
                        std::cout << "Number of shares can't be negative! " << company << " shares set to be 0!" << std::endl;
                        shares = 0;
                    }
                    else{
                        shares = n;
                    }
                    share_val = price;
                    setTotal();
                }
            private:
                std::string company;
                long share;
                double share_val;
                double total_val;
                void setTotal() {total_val = shares * share_val;}
        }
        ```

(完整)代码例子:
头文件`stock10.h`:
```cpp
/*
    类的声明
*/
#ifndef __STOCH_10_H__
#define __STOCH_10_H__

#include <string>

class Stock
{
    private:  // 私有部分, 只有public里面的成员才能访问这部分内容(一般private的成员都是通过 public 间接访问的)
        std::string company;    // 公司名
        long shares;            // 股票数量
        double share_val;       // 股票单价
        double total_val;       // 股票总价值

        // 计算总资产
        void setTotal() 
        {
            total_val = shares * share_val;
        }

    public:   // 公有部分, 任何代码都可以直接访问
        //Stock(const std::string &co, long n, double price);  // 原来的 acquire 函数改写为自定义的构造函数
        Stock(const std::string &co = "Error", long n = 0, double price = 0.0); // 测试第一种默认构造函数
        // Stock(); // 测试第二种默认构造函数

        void buy(long num, double price);
        void sell(long num, double price);
        void update(double price);
        void show();


};  // 别忘记分号, 这和结构体的语法是相同的

#endif // __STOCH_10_H__
```

cpp文件`stock10.cpp`:
```cpp
/*
    类的成员函数实现
*/
#include <iostream>
#include "stock10.h"

Stock::Stock(const std::string &co, long n, double price)
{
    company = co;       // 直接就访问到了private里的变量
    if(n < 0){
        std::cout << "Number of shares can't be negative! " << company << " shares set to be 0!" << std::endl;
        shares = 0;
    }
    else{
        shares = n;
    }

    share_val = price;
    setTotal();     // 直接调用了 private 里的函数
}

// 测试第二种默认构造函数
// Stock::Stock()
// {
//     company = "no name";
//     shares = 0;
//     share_val = 0.0;
//     total_val = 0.0;
// }

void Stock::buy(long num, double price)
{
    if(num < 0){
        std::cout << "Number of shares can't be negative! Transaction aborted!" << std::endl;
    }
    else{
        shares += num;      // 买入股票, 持有数量增加 num
        share_val = price;
        setTotal();
    }
}

void Stock::sell(long num, double price)
{
    if(num < 0){
        std::cout << "Number of shares can't be negative! Transaction aborted!" << std::endl;
    }
    else if(num > shares){
        std::cout << "You can't sell more than you have! Transaction is aborted!" << std::endl;
    }
    else{
        shares -= num;
        share_val = price;
        setTotal();
    }
}

void Stock::update(double price)
{
    share_val = price;
    setTotal();
}

void Stock::show()
{
    using namespace std;
    cout << "Company: " << company << endl;
    cout << "Shares: " << shares << endl;
    cout << "Share price: " << share_val << endl;
    cout << "Total worth: " << total_val << endl;
}
```

主函数文件`usestock2.cpp`:
```cpp
#include <iostream>
#include "stock10.h"
using namespace std;

int main(void)
{
    // method 1: 隐式调用构造函数
    Stock stock1("NanoSmart", 12, 20.0);
    stock1.show();

    cout << "------" << endl;

    // method 2: 显式地使用构造函数
    Stock stock2 = Stock("Boffo Object", 250, 1.25);
    stock2.show();

    // 测试默认构造函数(两种默认构造函数都用这个方式测)
    cout << "\nTesting default construction...." << endl;
    Stock stock3;
    stock3.show();

    return 0;
}
```

注意区分容易混淆的代码:
```cpp
Stock first("Concreate Conglometer");  // 调用自定义的构造函数
Stock second();     // 这是在声明一个函数, 函数名叫 second, 它没有传入的参数, 函数的返回值是一个 Stock 类型.
Stock third;        // 调用Stock的默认构造函数
```
