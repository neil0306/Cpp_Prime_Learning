# 第五章 循环和关系表达式
## 5.1.1 for循环的组成:
1. 设置初始值
2. 执行测试,看看循环是否硬蛋继续进行
3. 执行循环操作
4. 更新用于(第2步)测试的值

for循环的书写格式:
```cpp
for (initialization; test-expression; update-expression)
{
    body;
}

/* 执行顺序:
    1. 执行initialization 部分
    2. 执行 test-expression
    3. 执行 body 部分
    4. 执行 update-expression 

    重复 2-4, 直到不满足 test-expression, 自动结束循环
*/
```
- 花括号`{}`内包含的语句称为循环体, 
  - 花括号内的语句不管是否进行了缩进, 它都是循环体中的一部分 (C++不按照缩进来识别, python是按照缩进来识别循环体的)
  - 如果循环体中`只有一条语句`, 则可以省略花括号.
  - for后面的几个表达式都要使用分号`;`来隔开

简单的for循环例子:
```cpp

#include <iostream>

int main(void)
{
    using namespace std;

    int i;
    for( i = 0; i<5; i++)
    {
        cout << "C++ knows loop" << endl;
    }

    cout << "C++ knows when to stop." << endl;
    return 0;
}
```

在C++中, `test-expression 可以是任意表达式`, 但是C++会把表达式的计算结果自动转为 `bool类型`

例如:
```cpp
#include <iostream>

int main(void)
{
    using namespace std;

    cout << "Enter the starting countdown value: ";
    int limit ;
    cin >> limit;

    int i;
    for(i=limit; i; i--)
        cout << "i = " << i << endl;

    cout << "Done, now that i = " << i << endl;  // 最后打印一下 i, i此时肯定是0, 因为0对应的 bool类型是 false

    return 0;
}
```
for循环执行顺序图解:
![](images/for循环执行顺序图解.png)




## 5.1.2 表达式和语句

在C++中, `任何值`或`任何有效的值和运算符的组合`都是表达式.
- 对于`赋值表达式`, 整个表达式的值等于 `赋值运算符右侧的值`
  - 如: `i=10;`, 这个表达式的`值就是20`.

代码例子:
```cpp
#include <iostream>

int main(void)
{
    using namespace std;

    int x;
    cout << "The expression x =100 has the value ";
    
    // cout << x = 100 << endl;  // 报错, 编译的时候, 编译器会因为运算符优先级问题而无法识别 "x左右两侧的运算符" 的含义
    //                             // 由于 "<<" 的优先级比"=" 高, 
    //                             // 因此编译器优先执行 "cout << x", 把x直接输出.
    //                             // 然后编译器开始解读 " = 100 << endl;", 解析不了, 就报错了
    
    cout << (x = 100) << endl;   // value 打印出来是100

    cout << "now x = " << x << endl;

    cout << (x < 3) << endl;   // value 打印出来是0, 表示 false
    
    cout << (x > 3) << endl;   // value 打印出来是1, 表示 true

    cout.setf(ios_base::boolalpha);     // 把 true false原样显示, 而不是打印数字
    cout << (x < 3) << endl;   // value 打印出来是 false
    cout << (x > 3) << endl;   // value 打印出来是 true

    return 0;
}
```


所有的`表达式`只要后面接上分号`;`, 它就是一条`语句`, 但不一定有编程意义, 例如:
- "`i`" 是一个`表达式`
- "`i;`" 是一条`语句`, 但是它没有编程意义  


### for循环的另一种写法 (把变量 i 的声明直接写在 for 循环表达式里)
此时, 变量 i `只在for循环体中有效`, 执行完for循环之后, 后面的语句是没办法访问这个变量i的.
```cpp
#include <iostream>

int main(void)
{
    using namespace std;

    // int i;     // 如果在这里声明 i, 则执行完for语句之后, i 仍然可用
    for( int i = 0; i<5; i++)
    {
        cout << "C++ knows loop" << endl;
    }

    // cout << "i = " << i << endl;   // 编译不通过, 此时的 i 已经不可见了, 执行完for之后i就被回收

    cout << "C++ knows when to stop." << endl;
    
    return 0;
}
```

### for循环使用示例
计算并打印 0~15 的阶乘:
```cpp
#include <iostream>

const int ArrSize = 16;

int main(void){
    long long factorials[ArrSize];

    factorials[0] = factorials[1] = 1LL;  // long long 类型

    for (int i=2; i<ArrSize; i++){
        factorials[i] = i * factorials[i-1];
    }

    for (int i =0; i < ArrSize; i ++)
        std::cout << i << "! = " << factorials[i] << std::endl;
    return 0;
}
```

指定for循环的步长:
```cpp
#include <iostream>

int main(void){
    using std::cout;
    using std::endl;
    using std::cin;

    cout << "Enter an integer: ";
    int by;
    cin >> by;

    cout << "Counting by " << by << "\n";

    for (int i = 0; i < 100; i = i + by){
        cout << i << endl;
    }
}
```

使用for循环访问字符串 (反向输出字符串):
- string 类里面有一个 size() 方法, 可以返回字符串的长度.
```cpp
#include <iostream>
#include <string>

int main(void){
    using namespace std;

    cout << "Enter an word: ";

    string word;
    cin >> word;

    for(int i = word.size() -1; i>=0 ;i--){
        cout << word[i] ;
    }
    cout << endl;

    return 0;
}
```

## For循环语句块中的变量作用域:
- for循环中, 如果没有使用花括号 `{}` 的话, 它只会把 `for循环表达式` 后面的第一条语句当做 `for循环体` 的内容.
- 使用`{}` 之后, 花括号里的所有语句都被视为一个整体, 因此, 在 `for(int i = 0; i <= 5; i++)` 中, i++ 要等到花括号里的所有语句执行完毕之后, 才会执行.
- 循环体`{}`中定义的变量, 只在循环体中有效, *循环体外的语句无法访问这些变量*.
- 如果循环体里声明了一个与循环体外同名的变量, 则`从声明位置到循环体结束`这个范围里, 新声明的变量将隐藏循环体外面定义的变量, 等循环体运行结束之后, 循环体外的变量才会重新起作用.

代码例子:
```cpp

#include <iostream>

int main(void)
{
    using std::cout;
    using std::endl;

    int x = 20;

    for (int i = 0; i < 3; i++)
    {
        cout << "In For-loop(before init x): x = " << x << endl;    // 此时打印的是 for 外面的 x, 20
        
        int x = 100;                                                // 声明了一个 for 外面的同名变量

        cout << "In For-loop: x = " << x << endl;                   // 打印 100
        
        int y = 200;        // 在循环体里定义一个变量, 循环体外侧无法访问
    }
    cout << "After For-loop end, x = " << x << endl;                // 此时打印的是 for 外面的 x, 20

    // cout << "y = " << y << endl;                                    // 此时 y 不存在, 编译就报错了
    return 0;
}
```

不仅是 for 循环的循环体, 只要是花括号的语句块都有这个特性, 例如:
![](images/语句块内外定义的变量&作用域.png)


骚操作 -- 在 for 的初始化表达式中使用cin
```cpp
#include <iostream>

int main(void){
    using namespace std;
    int x;
    for (cin >> x; x > 0; cin >> x)   // 不断进行输入和打印, 直到输入的数小于0为止
        cout << "x = " << x << endl;

    return 0;
}
```

在for循环的判断语句中, 错误使用 `==` 和 `=` 造成的错误例子:
```cpp
#include <iostream>

int main(void){
    using namespace std;

    int arr[10] = {20, 20, 20, 20, 20, 19, 20, 18, 20, 20};

    cout << "Doing it right: " << endl;
    int i;
    for (i = 0; arr[i] == 20; i++)
        cout << "arr[" << i << "] = " << arr[i] << endl;
    
    // 死循环
    cout << "Doing it dangerously wrong: " << endl;
    for (i = 0; arr[i] = 20; i++)           // 判断语句写成了赋值语句, 这条赋值表达式的返回值是 =号 的左值, 也就是20, 所以这条语句永远为真, 
                                            // 又由于 C/C++ 不去判断数组越界问题, 所以就死循环了
                                            // 程序运行到最后会停止, 愿意是使用的这块内存空间刚好跑到了不允许访问的区域, 然后就报错, 停止运行
        cout << "arr[" << i << "] = " << arr[i] << endl;
    
    return 0;
}
```

for 循环常用在`确定循环次数`的场景.



## 5.2 while 循环 
while 循环常用于不确定循环次数的场景.
while循环格式:
```txt
while (test-condition)
    body
```
代码例子:
```cpp
#include <iostream>

const int ArrSize = 20;

using namespace std;

int main(void)
{
    char name[ArrSize];

    cout << "Your first name, please: ";
    cin >> name;

    int i = 0;
    cout << "Here is your name, verticalized and ASCIIized: \n";
    while (name[i] != '\0')     // 字符串结束符是 '\0', 这是默认加入的字符
    // while (name[i])            // 上面的 while 还可以写成 while (name[i]), 因为空字符 \0 在判断语句中的返回值是0
    {
        cout << name[i] << ": " << int(name[i]) << endl;    // int(name[i]) 将字符转换为对应的 ASCII 码
        i++;
    }
    return 0;
}
```

注意由`;`号引起的死循环:
```cpp
int i = 0;
while (name[i] != '\0');    // 加了一个分号! while 的循环体语句直接认为是默认值true, 于是死循环, 下面花括号的语句将永远不会被执行
{
    cout << name[i] << endl;
    i++;
}
```



## for 与 while 的对比
![](images/for与while的转换.png)
- for 循环中的空表达式默认返回值是 `true`, 分号`;`不能省略!
- while 循环的 test-expression 中不能写控制变量i的初始化语句!

## 5.2.2 使用while循环编写延时
下面是一个简单的例子, 但是它的延时效果与CPU的执行速度有关.
```cpp
long wait = 0;
while(wait < 1000000000L)
    wait++;
```

更好的办法是: 使用C/C++中自带的始终 `clock()` 来完成
- clock() 返回的`单位不一定是秒`!! 它返回的是`当前系统执行的时间节拍数`, 只是一个计数而已, 表示的是当前计算机每秒能计多少个数, 所以叫`"时钟节拍"`.
- C语言中需要包含头文件 `<time.h>`, C++ 中需要包含`<ctime>`
  - 这个头文件中有一个常量 `CLOCKS_PER_SEC`, 表示每秒钟有多少个时钟节拍, `用系统时间除以这个常量, 就能得到秒数`.
- 使用`clock()`时, 它的返回类型是`clock_t`(也叫"类型别名", 主要为了方便代码移植), 在不同机器上运行的时候, 编译器会自动把这个类型转换成合适的类型, 例如`long`或`unsigned int`.

代码例子:
```cpp
#include <iostream>
#include <ctime>

int main(void){
    using namespace std;

    cout << "Enter the delay time, in seconds: ";

    float secs;
    cin >> secs;

    clock_t delay = secs * CLOCKS_PER_SEC;  // 记录一秒要计数多少次. 注意这里使用的是 clock_t (本质上还是整型)

    clock_t start = clock();                // 这个语句记录了 "当前时间" 对应的统计次数, start 作为起始时间标记
    
    while (clock() - start < delay);        // 因为是延时循环, 所以这里搞了一个空循环语句, 后面加了分号
    
    cout << "done.\n";

    return 0;
}
```


## 类型别名 (type alias)
上面的例子中, clock_t 就是整型的类型别名, 常见的使用场景是`方便代码移植`, 同时还起到了一定的`注释作用`, 比如这里的 clock_t 就在暗示我们这个变量是一个时间.
- 通用的类型别名定义方式:
  - `typedef type new_name;`
    - 如: `typedef char C;`, 如果在程序中使用了 `C`, 那么编译器会自动把它转换成 `char`
    - 写法和定义变量是很像, 只需要在前面加一个 `typedef` 就可以了

在C语言中, 类型别名是通过下面的方式实现的, 这种方式在 C++ 中也可以使用:
- `#define new_name type`
  - 如: `#define C char`, 把 C 定义为 char 的别名.
  - 这种方式的缺点是:
    - 在定义多个变量的时候很容易出现"逻辑错误", 比如下面的代码:
    ```cpp
    #define FLOAT_POINTER float*

    FLOAT_POINTER pa, pb;  
    /*
    在系统预处理阶段, FLOAT_POINTER 会被替换成 float*, 于是上面的代码就变成了:
        float* pa, pb;
    
    这里本意是希望定义两个指针, 但是 float* 会首先和 pa 结合, 变成 float *pa, 而 pb 则被单独解析为 float pb, 这是在定义一个 float 类型的变量, 不是指针!
    */
    

    // 正确的写法是:
    typedef float* FLOAT_POINTER;
    FLOAT_POINTER pa, pb;           // 这样就能正确定义两个指针了
    ```


## 5.3 do while 循环

do while 循环的格式:
```txt
do                  
    body                    // 上来先执行循环体
while (test-expression);    // 再判断条件, 千万别忘了分号!!!!!
```
- while后面千万别忘记了分号`;`!!!!

使用场景:
- 用户输入验证
  - 比如输入密码

代码例子:
```cpp
#include <iostream>

int main(void)
{
    using namespace std;

    int n;
    // cout << "Enter numbers in range 1-10 to find my favorite number: " << endl;

    // 不用do, cin 写了两次
    // cin >> n;

    // while (n != 7)
    // {
    //     cout << "Enter numbers in range 1-10 to find my favorite number: " << endl;
    //     cin >> n;
    // }


    // 使用 do-while, cin 只写了一次
    do {
        cout << "Enter numbers in range 1-10 to find my favorite number: " << endl;
        cin >> n;
        cout << "You entered " << n << endl;        // 假如输入的是非数字, 那么 n 的值就是 0
    } while (n != 7);       // 别忘了最后的分号!!

    return 0;
}
```
- 这个循环有个致命bug:
    - 输入的数据不是int时, 会陷入死循环, 因为 cin 会把输入的数据转换成 int, `如果输入的不是 int, 那么 cin 会把输入的数据转换成 0`, 于是 n != 7 就永远成立了, 陷入死循环.



