# 第八章 函数探幽 
这是C++ 特有的东西, C之后新增的内容.

## 8.1 C++ 内联函数
- 内联函数是 C++ 为提高程序运行速度所做的一项改进, 它与普通函数的区别主要在C++编译器如何将他们组合到程序中.
  - 普通函数在经过编译器编译之后, 执行方式通常是`通过跳转`到函数代码所在的内存空间, 等执行完函数之后, 再跳回到原来执行的主程序位置.
  - 内联函数则是在编译的时候, 将`函数调用处用函数体替换`, 也就是说, `内联函数的执行不需要跳转到函数体`, 而是直接执行函数体, 这样就提高了程序的运行速度. 
    - 内联函数的代价是占用更多内存.
    - 内敛函数与常规函数的调用流程图:
    ![](第八章笔记_images/内敛函数与常规函数的调用流程图.png)

内联函数使用建议:
- 函数较短, 代码量不大时, 可以考虑使用内联函数
- 函数执行时间相比于函数调用时间较`短`时, 可以考虑使用内联函数. (主要思想是`以空间换时间`, 看看是不是收益比较大)

--- 
内敛函数的使用方法(二选一):
- 在`函数声明`前面加上关键字`inline`
- 在`函数定义`前面加上关键字`inline`

内敛函数的使用注意: 
1. 通常做法是`省略函数声明`, 直接把`函数整个定义`(函数头和函数体)都给写完, 然后在函数定义前面加上关键字`inline`.
2. 哪怕我们加上了 inline 关键字, `编译器也不一定会将其作为内联函数`, 比如编译器认为函数过长(过大), 或者这个函数调用了自己(一个递归函数, `递归函数不能作为内联函数`), 此时编译器就不会启用内联函数这种特性.

使用示例1: 
```cpp
#include <iostream>

using namespace std;

// 定义内联函数 (写法像一个宏, 但是比宏的功能更强)
inline double square(double x){return x*x;}

int main(void)
{
    double a,b;
    double c = 13.0;

    a = square(5.0);
    b = square(4.5+7.5);
    cout << "a = " << a << ", b = " << b << endl;
    cout << "c = " << c << endl;
    cout << "c square = " << square(c++) << endl;
    cout << "Now c = " << c << endl;

    return 0;
}
```

---

内联与宏:
- `函数宏`的写法: `#define SQUARE(X) X*X`
  - 有时候函数宏会出问题, 因为`函数宏不能按值传递`, `函数宏只进行文本替换, 很容易产生逻辑问题`!
  - 尽可能`使用内联函数, 而不是函数宏`.
  ![](第八章笔记_images/内联与宏.png)



## 8.2 引用变量
### 8.2.1 创建引用变量
- 变量的引用指的是原来变量的`别名`, 引用变量的声明方式为: 
  ```cpp 
  类型 &引用名 = 原来的变量名;
  int rat; 
  int &rodent = rat; // rodent 是 rat 的引用
  ```
- 如果在函数中使用变量的引用, 则真正使用的是`原来的变量`, 而不是变量的`副本`.

引用的代码例子:
```cpp
#include <iostream>
using namespace std;

int main(void)
{
    int rat = 10;
    int & rodent = rat;
    
    cout << "rat = " << rat << endl;
    cout << "rodent = " << rodent << endl;

    // 改变rodent
    rodent ++;
    cout << "rat = " << rat << endl;
    cout << "rodent = " << rodent << endl;

    // 观察地址
    cout << "rat's address: " << &rat << endl;
    cout << "rodent's address: " << &rodent << endl;

    return 0;
}
```
--- 
引用和指针的异同:
- 引用和指针**都可以直接操作原来的变量的值**, 而不是副本.
- `引用变量必须在初始化的时候就赋值`, 而指针可以先定义, 再赋值.
  ```cpp
  // 这里的写法是非法的!!
  int rat;
  int & rodent; // 不正确的写法, 会报错
  rodent = rat; // 不正确的写法, 会报错
  ```
- `引用变量一旦声明, 就不能改变`, 而**指针变量可以改变指向的变量**.
  - 也就是说, 引用`从始至终都效忠于同一个变量, 永不改变`.
  ```cpp
  #include <iostream>
  using namespace std;

  int main(void)
  {
      int rat = 101;
      int & rodent = rat;
      
      cout << "rat = " << rat << endl;
      cout << "rodent = " << rodent << endl;

      int bunnies = 50;
      rodent = bunnies;       // 关联成功了吗? no!
      cout << "bunnies = " << bunnies << endl;
      cout << "rodent = " << rodent << endl;      // 发现rodent的值变成了50

      cout << "rat = " << rat << endl;  
      /* 会发现 rat 也变成了50, 这说明上面的 
          rodent = bunnies 
          并不表示 rodent 成为了 bunnies 的别名, 这句代码仅仅是赋值语句
      */

      // 观察地址
      cout << "bunnies' address:\t" << &bunnies << endl;
      cout << "rat's address:\t\t" << &rat << endl;
      cout << "rodent's address:\t" << &rodent << endl;

      return 0;
  }
  ```

引用变量 与 指针: 
```cpp
// 指针可以随意改变指向的对象, 但是引用变量一旦声明, 就不能改变
int rats = 20;
int *pt = &rats; // pt 指向 rats
int &rodent = rat; // rodent 是 rats 的引用
int bunnies = 50;
pt = &bunnies; // pt 指向 bunnies
```


### 8.2.2 在函数中使用引用变量
代码例子1:
```cpp
#include <iostream>

using namespace std;

void swapr(int &a, int &b);
void swapp(int *a, int *b);
void swapv(int a, int b);

int main(void)
{
    int wallet1 = 300;
    int wallet2 = 350;

    cout << "wallet1 = " << wallet1 << endl;
    cout << "wallet2 = " << wallet2 << endl;

    cout << "Using reference to swap contents: " << endl;
    swapr(wallet1, wallet2);
    cout << "wallet1 = " << wallet1 << endl;
    cout << "wallet2 = " << wallet2 << endl;

    cout << "Using pointers to swap contents: " << endl;
    swapp(&wallet1, &wallet2);
    cout << "wallet1 = " << wallet1 << endl;
    cout << "wallet2 = " << wallet2 << endl;

    cout << "Trying to use passing by value:" << endl;
    swapv(wallet1, wallet2);        // 会发现没有发生交换
    cout << "wallet1 = " << wallet1 << endl;
    cout << "wallet2 = " << wallet2 << endl;

    return 0;
}

void swapr(int &a, int &b)
{
    int tmp = a;
    a = b;
    b = tmp;
}

void swapp(int * a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

void swapv(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```


代码例子2:
- 不适合使用引用的情况: 不希望值发生改变.
- 通常在传入结构体的并希望修改结构体的值时, 会使用引用.
```cpp
#include <iostream>

using namespace std;
double cube(double x);
double recube(double &ra);

int main(void)
{
    double x = 3.0;
    cout << "Cube of X: " << cube(x) << endl;

    cout << "Recube of X: " << recube(x) << endl;
    cout << "X = " << x << endl;

    return 0;
}

double cube(double x)
{
    x *= x * x;
    return x;
}

double recube(double &ra)
{
    ra *= ra * ra;
    return ra;
    // 换成  return ra * ra * ra; 此时 ra 就不会发生更改
}
```
- 注意: 
  - 在函数调用时, 如果使用`变量的引用`, 则**一定不能**在引用变量的位置上写`表达式`!!! 此时会编译报错! 解决办法就加const.
    ```cpp
    int a = 5;
    // 假设使用上面定义好的recube, 这种用法就会发生变异报错
    recube(5+x);
    ```
  - 如果引用变量的位置上加了`const`, 则此时可以使用表达式.
    ```cpp
    int a = 5;
    // 假设使用上面定义好的recube, 但是增加一个const
    recube(const int & a);
    rebube (5+a);  // 这种用法就不会报错
    ```
    - 不会报错的原因是:
      - 增加了`const`关键字之后, `C++内部会自动生成一个临时变量`, 用来存储表达式的值, 然后将这个`临时变量的引用`与函数那个引用变量关联起来, 此时, 如果函数内部对引用变量的值进行了更改操作, 此时被改掉的只是临时变量的值, 因此不会报错.


在函数中使用引用时, 应该尽可能使用`const`:
![](第八章笔记_images/函数中使用引用时应尽可能使用const.png)

