# 第八章 函数探幽 
这是C++ 特有的东西, C之后新增的内容.

## 8.1 C++ 内联函数
- 内联函数是 C++ 为提高程序运行速度所做的一项改进, 它与普通函数的区别主要在C++编译器如何将他们组合到程序中.
  - 普通函数在经过编译器编译之后, 执行方式通常是`通过跳转`到函数代码所在的内存空间, 等执行完函数之后, 再跳回到原来执行的主程序位置.
  - 内联函数则是在编译的时候, 将`函数调用处用函数体替换`, 也就是说, `内联函数的执行不需要跳转到函数体`, 而是直接执行函数体, 这样就提高了程序的运行速度. 
    - 内联函数的代价是占用更多内存.
    - 内敛函数与常规函数的调用流程图:
    ![](第八章笔记_images/内敛函数与常规函数的调用流程图.png)

内联函数使用建议:
- 函数较短, 代码量不大时, 可以考虑使用内联函数
- 函数执行时间相比于函数调用时间较`短`时, 可以考虑使用内联函数. (主要思想是`以空间换时间`, 看看是不是收益比较大)

--- 
内敛函数的使用方法(二选一):
- 在`函数声明`前面加上关键字`inline`
- 在`函数定义`前面加上关键字`inline`

内敛函数的使用注意: 
1. 通常做法是`省略函数声明`, 直接把`函数整个定义`(函数头和函数体)都给写完, 然后在函数定义前面加上关键字`inline`.
2. 哪怕我们加上了 inline 关键字, `编译器也不一定会将其作为内联函数`, 比如编译器认为函数过长(过大), 或者这个函数调用了自己(一个递归函数, `递归函数不能作为内联函数`), 此时编译器就不会启用内联函数这种特性.

使用示例1: 
```cpp
#include <iostream>

using namespace std;

// 定义内联函数 (写法像一个宏, 但是比宏的功能更强)
inline double square(double x){return x*x;}

int main(void)
{
    double a,b;
    double c = 13.0;

    a = square(5.0);
    b = square(4.5+7.5);
    cout << "a = " << a << ", b = " << b << endl;
    cout << "c = " << c << endl;
    cout << "c square = " << square(c++) << endl;
    cout << "Now c = " << c << endl;

    return 0;
}
```

---

内联与宏:
- `函数宏`的写法: `#define SQUARE(X) X*X`
  - 有时候函数宏会出问题, 因为`函数宏不能按值传递`, `函数宏只进行文本替换, 很容易产生逻辑问题`!
  - 尽可能`使用内联函数, 而不是函数宏`.
  ![](第八章笔记_images/内联与宏.png)


---
## 8.2 引用变量
### 8.2.1 创建引用变量
- 变量的引用指的是原来变量的`别名`, 引用变量的声明方式为: 
  ```cpp 
  类型 &引用名 = 原来的变量名;
  int rat; 
  int &rodent = rat; // rodent 是 rat 的引用
  ```
- 如果在函数中使用变量的引用, 则真正使用的是`原来的变量`, 而不是变量的`副本`.

引用的代码例子:
```cpp
#include <iostream>
using namespace std;

int main(void)
{
    int rat = 10;
    int & rodent = rat;
    
    cout << "rat = " << rat << endl;
    cout << "rodent = " << rodent << endl;

    // 改变rodent
    rodent ++;
    cout << "rat = " << rat << endl;
    cout << "rodent = " << rodent << endl;

    // 观察地址
    cout << "rat's address: " << &rat << endl;
    cout << "rodent's address: " << &rodent << endl;

    return 0;
}
```
--- 
引用和指针的异同:
- 引用和指针**都可以直接操作原来的变量的值**, 而不是副本.
- `引用变量必须在初始化的时候就赋值`, 而指针可以先定义, 再赋值.
  ```cpp
  // 这里的写法是非法的!!
  int rat;
  int & rodent; // 不正确的写法, 会报错
  rodent = rat; // 不正确的写法, 会报错
  ```
- `引用变量一旦声明, 就不能改变`, 而**指针变量可以改变指向的变量**.
  - 也就是说, 引用`从始至终都效忠于同一个变量, 永不改变`.
  ```cpp
  #include <iostream>
  using namespace std;

  int main(void)
  {
      int rat = 101;
      int & rodent = rat;
      
      cout << "rat = " << rat << endl;
      cout << "rodent = " << rodent << endl;

      int bunnies = 50;
      rodent = bunnies;       // 关联成功了吗? no!
      cout << "bunnies = " << bunnies << endl;
      cout << "rodent = " << rodent << endl;      // 发现rodent的值变成了50

      cout << "rat = " << rat << endl;  
      /* 会发现 rat 也变成了50, 这说明上面的 
          rodent = bunnies 
          并不表示 rodent 成为了 bunnies 的别名, 这句代码仅仅是赋值语句
      */

      // 观察地址
      cout << "bunnies' address:\t" << &bunnies << endl;
      cout << "rat's address:\t\t" << &rat << endl;
      cout << "rodent's address:\t" << &rodent << endl;

      return 0;
  }
  ```

引用变量 与 指针: 
```cpp
// 指针可以随意改变指向的对象, 但是引用变量一旦声明, 就不能改变
int rats = 20;
int *pt = &rats; // pt 指向 rats
int &rodent = rat; // rodent 是 rats 的引用
int bunnies = 50;
pt = &bunnies; // pt 指向 bunnies
```


### 8.2.2 在函数中使用引用变量
代码例子1:
```cpp
#include <iostream>

using namespace std;

void swapr(int &a, int &b);
void swapp(int *a, int *b);
void swapv(int a, int b);

int main(void)
{
    int wallet1 = 300;
    int wallet2 = 350;

    cout << "wallet1 = " << wallet1 << endl;
    cout << "wallet2 = " << wallet2 << endl;

    cout << "Using reference to swap contents: " << endl;
    swapr(wallet1, wallet2);
    cout << "wallet1 = " << wallet1 << endl;
    cout << "wallet2 = " << wallet2 << endl;

    cout << "Using pointers to swap contents: " << endl;
    swapp(&wallet1, &wallet2);
    cout << "wallet1 = " << wallet1 << endl;
    cout << "wallet2 = " << wallet2 << endl;

    cout << "Trying to use passing by value:" << endl;
    swapv(wallet1, wallet2);        // 会发现没有发生交换
    cout << "wallet1 = " << wallet1 << endl;
    cout << "wallet2 = " << wallet2 << endl;

    return 0;
}

void swapr(int &a, int &b)
{
    int tmp = a;
    a = b;
    b = tmp;
}

void swapp(int * a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

void swapv(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```


代码例子2:
- 不适合使用引用的情况: 不希望值发生改变.
- 通常在传入结构体的并希望修改结构体的值时, 会使用引用.
```cpp
#include <iostream>

using namespace std;
double cube(double x);
double recube(double &ra);

int main(void)
{
    double x = 3.0;
    cout << "Cube of X: " << cube(x) << endl;

    cout << "Recube of X: " << recube(x) << endl;
    cout << "X = " << x << endl;

    return 0;
}

double cube(double x)
{
    x *= x * x;
    return x;
}

double recube(double &ra)
{
    ra *= ra * ra;
    return ra;
    // 换成  return ra * ra * ra; 此时 ra 就不会发生更改
}
```
- 注意: 
  - 在函数调用时, 如果使用`变量的引用`, 则**一定不能**在引用变量的位置上写`表达式`!!! 此时会编译报错! 解决办法就加const.
    ```cpp
    int a = 5;
    // 假设使用上面定义好的recube, 这种用法就会发生变异报错
    recube(5+x);
    ```
  - 如果引用变量的位置上加了`const`, 则此时可以使用表达式.
    ```cpp
    int a = 5;
    // 假设使用上面定义好的recube, 但是增加一个const
    recube(const int & a);
    rebube (5+a);  // 这种用法就不会报错
    ```
    - 不会报错的原因是:
      - 增加了`const`关键字之后, `C++内部会自动生成一个临时变量`, 用来存储表达式的值, 然后将这个`临时变量的引用`与函数那个引用变量关联起来, 此时, 如果函数内部对引用变量的值进行了更改操作, 此时被改掉的只是临时变量的值, 因此不会报错.


在函数中使用引用时, 应该尽可能使用`const`:
![](第八章笔记_images/函数中使用引用时应尽可能使用const.png)


---
### 8.2.3 引用与结构体

代码例子 -- 函数返回结构体的引用:
```cpp
#include <iostream>
#include <string>
using namespace std;

struct free_throws
{
    string name;
    int made;
    int attemps;
    float percent;
};

void set_pc (free_throws & ft);
void display(const free_throws & ft);        // 显示的时候不应该修改任何东西, 加 const
// 注意: 这里的 accumulate 返回的是一个引用, 这样才能实现链式赋值
free_throws & accumulate(free_throws & target, free_throws & src);

int main(void)
{
    // percet 默认为0
    free_throws one = {"Rick", 13, 14};
    free_throws two = {"Jack", 10, 16};
    free_throws three = {"Jerry", 7,9 };
    free_throws four = {"Jason", 8, 11};
    free_throws five = {"Michael", 5, 14};
    free_throws team = {"Class 6", 0, 0};

    // 用函数填充percent, 再显示
    set_pc(one);
    display(one);

    // 累加并显示
    accumulate(team, one);
    display(team);

    display(accumulate(team, two));


    // 链式赋值
    accumulate(accumulate(accumulate(team, three), four), five);
    /*
    等价于:
        // accumulate(team, three);
        // accumulate(team, four);
        // accumulate(team, five);
    */
    display(team);

    return 0;
}

void set_pc (free_throws & ft)
{
    if (ft.attemps != 0){
        ft.percent = 100 * static_cast<float>(ft.made) / static_cast<float>(ft.attemps);
    }
    else{
        ft.percent = 0;
    }
}

void display(const free_throws & ft)        // 显示的时候不应该修改任何东西, 加 const
{
    cout << "Name: " << ft.name << endl;
    cout << "Made: " << ft.made << "\t";
    cout << "Attemps: " << ft.attemps << "\t";
    cout << "Percent: " << ft.percent << endl;
}

free_throws & accumulate(free_throws & target, free_throws & src)
{
    target.attemps += src.attemps;
    target.made += src.made;
    set_pc(target);
    return target;
}
```
- 如果 return 一个结构体, 此时编译的操作是:
  - 情况1: return 出去的结构体`不是引用`:
    - 编译器会先临时开辟一个内存空间, 用来存放这个结构体
    - 然后在函数调用的位置把这个临时的结构体空间返回出去 (如果有变量等待接收, 就把这个内存赋值给它)
  - 情况2: return 出去的`结构体是一个引用变量`:
    - 直接`执行结构体的对拷`操作, 效率更高. 比如:
    ```cpp
    // accumulate函数按照上面的例子的定义
    free_throws dup = accumulate(team, one);
    /* 
      由于 accumulate 返回的结构体是 team 的引用, 所以编译器在函数调用结束时, 
        是直接执行 dup 和 team 的对拷操作, 没有开辟临时内存空间!!!
    */
    ```

- 返回引用需要注意, 引用变量一定要确保没有被释放!!
![](第八章笔记_images/函数返回引用需要注意原来的变量没有被释放.png)
- 如果使用`指针`来实现返回引用, 则一定要注意指针是否被释放, `是否容易出现内存泄露`问题!
![](第八章笔记_images/使用指针来实现返回引用的功能.png)

---
### 8.2.5 引用 与 类对象

代码例子:
```cpp
#include <iostream>
#include <string>

using namespace std;
string version1(const string & s1, const string &s2);
const string & version2(string &s1, const string &s2);
const string & version3(string &s1, const string &s2);

int main(void)
{
    string Input;
    string Result;
    string copyStr;

    cout << "Enter a string: ";
    getline(cin, Input);
    copyStr = Input;
    cout << "Your string as entered: " << Input << endl;
    cout << "--------------------" << endl;

    Result = version1(Input, "***");      // 在字符串的前缀和后缀加*
    cout << "Your string enhanced: " << Result << endl;
    cout << "Your original string: " << Input <<  endl;
    cout << "--------------------" << endl;

    Result = version2(Input, "###");        // 注意version2返回的是 "引用" 哦!
    cout << "Your string enhanced: " << Result << endl;
    cout << "Input now becomes: " << Input <<  endl;
    
    cout << "--------------------" << endl;
    Input = copyStr;        // 恢复到初始值
    // 此时 version3 返回的值已经被释放掉了, 在linux中, 程序运行到这里会崩掉
    Result = version3(Input, "@@@");
    cout << "Your string enhanced: " << Result << endl;
    cout << "Input now becomes: " << Input <<  endl;

    return 0;
}

// 1. string类中定义了 char* 到 string类型的转换, 使得我们可以用 char* 直接初始化string对象
// 2. 在函数中, 如果在引用变量前加 const, 那么当引用类型 与 传入的实参类型不匹配时(但可以被正确转换), 
//   编译器会自动创建一个临时变量进行适配
// 3. version1 返回的是"值", 走的是"按值传递"的方式, 变量的值在return时存放到临时内存空间中.
string version1(const string & s1, const string &s2)
{
    return s2 + s1 + s2;
}

// version2 返回的是引用!!!
const string & version2(string &s1, const string &s2)
{
    s1 = s2 + s1 + s2;
    return s1;
}


const string & version3(string &s1, const string &s2)
{
    string tmp;
    tmp = s2 + s1 + s2;
    return tmp;     // 返回引用的时候 tmp 会在函数调用结束时被释放!
}
```
- 注意看上面例子中的注释部分.

---
### 8.2.6 对象, 继承和引用
- 继承中最常用的特性: 
  - 派生类**继承**了基类的方法, 因此`派生类可以直接使用基类的方法`. 
    - 如 ofstream 是由 ostream 派生出来的, 所以 ofstream 可以使用 ostream 的方法, 如格式化方法 `precision()` 和 `setf()`.
  - 基类**引用**可以`指向派生类的对象`.  

代码例子:
```cpp
/*
    当物镜焦距一定时, 计算不同目镜焦距下的放大倍数.
*/
#include <iostream>
#include <fstream>

using namespace std;
const int LIMIT = 5;
void file_it(ostream &OS, double fo, const double fe[], int n);

int main(void)
{
    fstream fout;
    const char *fn = "ep-data.txt";

    fout.open(fn);
    if(!fout.is_open()){        // 打开失败
        cout << "Can't open " << fn << ".Bye" << endl;
        exit(EXIT_FAILURE);     // 直接结束程序
    }

    double objective;       // 物镜的焦距
    cout << "Enter the focal length of telescope objective in mm:" << endl;
    cin >> objective;

    double eps[LIMIT];      // 目镜的焦距(数组)
    for (int i = 0; i < LIMIT; i++){
        cout << "EyePieces #" << i+1 << endl;
        cin >> eps[i];
    }

    file_it(cout, objective, eps, LIMIT);      // 在终端中显示结果
    file_it(fout, objective, eps, LIMIT);      // 在文件中记录结果

    cout << "Done!" << endl;
    return 0;
}

/* 
形参的定义中使用到知识点: 
    1. 基类对象的引用既可以"指向基类对象", 也可以指向"派生类对象"
    2. 数组可以使用数组表示法, 也可以使用指针表示法(本质上两种都是在传递指针)
*/
void file_it(ostream &OS, double fo, const double fe[], int n)
{
    // OS 是基类对象的引用, 通过传入对象的不同可以实现不同的执行效果
    OS << "Focal Length of objective: " << fo << endl;
    OS << "f.1. eyepieces " << "magnification" << endl;
    for (int i = 0; i < LIMIT; i++){
        OS << "\t" << fe[i] << "\t" << static_cast<int>(fo/fe[i] + 0.5) << endl;
    }
}
```
- ostream 是基类, ofstream 是派生类
  - 引用参数 OS 是 ostream 类型的引用, 因此可以传入 ofstream 类型的对象, 因为 ofstream 是 ostream 的派生类.
    - 通过引用对象绑定对象的不同(派生类与基类), 实现了完全不一样的效果.

---
### 8.2.7 何时使用引用参数
![](第八章笔记_images/何时使用引用参数.png)

- 小结:
  - `数组`: 一定且只能使用`指针`!
  - 类的对象: 用`引用`
  - 传递结构体: 指针或引用都可以. 
  - **基本类型**且**想修改**数值: 用指针
  - **不修改原始数据**或**数据量不大**: 按值传递 

---
## 8.3 函数的默认参数

代码例子:
```cpp
#include <iostream>
#include <cstring>  // left函数中还以选择使用这个库函数里的 strlen() 来计算char数组的长度; 但由于发生函数调用, 存在时间成本

using namespace std;

char * left(const char *str, int n = 1);
const int ArSIZE = 80;

int main(void){
    char sample[ArSIZE];
    cout << "Enter a string:";
    cin.get(sample, ArSIZE);

    // char *ps = left(sample, 4);
    char *ps = left(sample, 400000);  // 如果使用版本1, 就会浪费很多空间
    cout << ps << endl;

    ps = left(sample); // 使用默认值
    cout << ps << endl;

    delete ps;      // 在 left 里面 new, 这里delete
    
    return 0;
}

// // 版本1: 速度快, 但存在空间浪费
// char * left(const char *str, int n)
// {
//     if (n < 0)
//         n = 0;      // n < 0 是非法的, 此时直接置零, 相当于什么都不干

//     char *p = new char [n+1];               // 要多一个, 存放结束符 '\0'

//     int i = 0;
//     for(i = 0; i < n && str[i]; i++){       // str[i] 如果为空字符, 此时for循环的条件语句就返回false
//         p[i] = str[i];
//     }
//     while (i <= n){
//         // 先对第i个位置赋值, 然后 i++
//         p[i++] = '\0';      // 如果p没有存满(此时str里的元素不足n个), 此时就把空出来的位置全部填 '\0'
//     }
//     return p;
// }

// 版本2: 不但节省空间, 运行速度也快
char * left(const char *str, int n)
{
    // 自己遍历一次数组, 直接确定数组里的元素个数
    int m = 0;
    while ( m < n && str[m] != '\0'){
        m++;
    }
    char * p = new char[m+1];
    int i = 0;
    for (; i < m; i++){
        p[i] = str[i];
    }
    p[i] = '\0';  // 最后一个元素填入空字符.
    return p;
} 
```
---
## 8.4 左值/优值引用(before 函数重载)
详细知识点看代码注释.
```cpp
/*
    本例子主要与C++的 "左值/右值引用" 相关.
        left, rigt 通常与赋值运算符相关(= , +=), 赋值运算符左侧就成为"左值", 右侧的就叫做"右值".

        巧记: 凡是能进行[取地址]操作的都是左值, 不能取地址的都是右值.
*/

#include <iostream>

using namespace std;

int main(void)
{
    int a = 10;     // a 是左值(可读可写的变量), 10 是右值(只读变量)
    int b = a;      // b 是左值(可读可写的变量), a 是右值(只读变量)

    int *p = &a;    // 能取地址, 此时的a还是左值

    // int *p = &(a+b);    // 编译时会报错(cannot take the address of an rvalue of type 'int'), 
                           // 说明(a+b) 这个整体是一个"右值", 报错信息里的关键词是 "rvalue"

    // 左值引用
    int &c = a;         // c 相当于是a的"别名", 这种引用方式叫做 "左值引用"
    // int &d = 10;        // 会报错 (initial value of reference to non-const must be an lvalue), 这是因为10是右值, 而"左值引用"要求 引用的对象一定是 "左值", 简单来讲就是 = 号右侧一定要能 "取地址"
    // int &d = (a+b);     // 同样报错(initial value of reference to non-const must be an lvalue), 原因就是 (a+b) 不是"左值", 特点就是没办法取地址.

    // 加const之后, 这种引用已经是 "常引用(阉割版引用)" 了. 此时的引用是与"一个临时变量"进行绑定的, 绑定之后, 这个引用变量只能读取数据, 无法修改数据.
    const int &d = 10;      // 加 const 之后就合法了, 因为10在内存中产生了一个 "临时变量", 这时候 d 就会和那个临时变量绑定在一起
    const int &e = (a+b);   // 加 const 之后就合法了, 因为a+b在内存中产生了一个 "临时变量", 这时候 e 就会和那个临时变量绑定在一起

    // C++ 11 中新增的 "右值引用", 编译的时候可能会有相关的版本提示.
    /*
        1. 两个 && 表示是右值引用
        2. 右值引用并不是为了取代左值引用, 它的存在是为了"移动语义", 这在析构函数中非常有用.
    */
    int &&x = 10;           // x 是右值引用
    int &&y = (a+b);        // y 也是右值引用

    return 0;
}
```
---
### 8.4 函数重载
`函数多态` 与 `函数重载` 都是同一回事, 虽然术语的文字理解可以表达为:
- "多态" 指的是: 一个函数有多种形式.
- "函数多态"则是指: 允许存在多个同名函数.

函数重载的关键主要看`函数的参数列表`, 也称为`函数的特征标 (function signature)`.
- 如果两个函数的`参数数目`和`参数类型相同`, 同时`参数的排列顺序`也相同, 则这两个函数的特征标相同. (变量名是无关紧要的)
- 只要函数的特征标不相同, 这两个函数哪怕名字相同, 也会被认为是不同的函数.
  - 因此, 函数重载需要保证`函数的特征标`不一样, 以下三个至少有一个不同:
    - 参数排列顺序
    - 参数类型
    - 参数数目

注意:
- 如果在函数调用时, 我们传递进去的参数与已有的函数定义都不匹配的话, 编译器会自动使用`强制类型转换`, 但是, `如果转换结束之后, 发现有多个可用的重载`, 此时编译器不知道应该使用哪一种的话, 最终`编译器会直接丢出一个错误`.
- 一些不能共存的特征标:
  ```cpp
  // 1. 编译器通常将 类型引用 和 类型本身 视为同一种特征标
  double cube(double x);
  double cube(double &x);       // 编译器认为 "double &x" 等同于 "double x"
  ```

-  函数的类型(函数的返回值)并不能用于决定函数是否能重载:
    ```cpp
    // 这两个函数定义中只有返回类型不一致, 但是函数的特征标(参数列表)是相同的, 因此这两个函数在编译器的角度来看是相同的函数, 会发生"重定义"错误.
    long gronk(int n, float m);
    double gronk(int n, float m);
    ```
---

函数在`调用`时, `编译器不区分const 和 非const`:
```cpp
// 函数原型
void dribble(char * bits);          // overloaded
void dribble (const char *cbits);   // overloaded
void dabble(char * bits);           // not overloaded
void drivel (const char * bits);    // not overloaded


const char p1[20]= "How's the weather?";
char p2[20]= "How's business?";
// 调用函数
dribble(p1);  // dribble(const char *);
dribble(p2);  // dribb1e(char *);
dabb1e(p1);   // no match
dabble(p2);   // dabble(char *);
drivel(p1);   // drivel (const char *);
drivel (p2);  // drivel(const char *);      // 传入非const指针时, 也匹配到 带const的函数原型
```
---
函数重载中使用`右值引用`的例子:
```cpp
// 假设有以下函数声明
void staff(double & rs);  // rs是左值引用
void staff(const double & rcs);  // 重载, 左值引用, 带const
void stove(double &r1);   // 左值引用
void stove(const double & r2);  // 重载, 带 const 的左值引用
void stove(double && r3);  // 重载, 右值引用

// 调用函数的场景
double x = 55.5;
const double y = 32.0;
stove(x);       // 调用 stove(double &r1);
stove(y);       // 调用 stove(const double &r2);
stove(x+y);     // 调用 stove(double &&r3);  假如代码中没有这个右值引用的函数声明, 编译器会默认调用 void stove(const double & r2);
```

- 函数重载的例子
```cpp
#include <iostream>
#include <cstring>  // left函数中还以选择使用这个库函数里的 strlen() 来计算char数组的长度; 但由于发生函数调用, 存在时间成本

using namespace std;

char * left(const char *str, int n = 1);
unsigned long left(unsigned long num, unsigned int ct);

const int ArSIZE = 80;

int main(void){
    const char * trip = "Hawaii!!";
    unsigned long n = 12345678;
    char * temp;
    int i;
    for (i = 0; i < 10; i++){
        cout << left(n, i) << endl;
        temp = left(trip, i);
        cout << temp << endl;
        delete [] temp;
    }
    return 0;
}

char * left(const char *str, int n)
{
    // 自己遍历一次数组, 直接确定数组里的元素个数
    int m = 0;
    while ( m < n && str[m] != '\0'){
        m++;
    }
    char * p = new char[m+1];
    int i = 0;
    for (; i < m; i++){
        p[i] = str[i];
    }
    p[i] = '\0';  // 最后一个元素填入空字符.
    return p;
} 

// 重载 left, 功能是取出数组的前n位
unsigned long left(unsigned long num, unsigned int ct)
{
    unsigned int digits = 1;              // num 的位数
    unsigned long tmp = num;

    if(ct == 0 || num == 0){
        return 0;
    }

    while(tmp /= 10){       // 除值为0时, 相当于false, 跳出循环
        digits++;
    }

    if (digits > ct){
        ct = digits - ct;            // 计算要除多少次10 
        while (ct --){
            num /= 10;
        }
        return num;
    }
    else {
        return num;
    }
}
```
---
什么时候才应该使用`函数重载`?
- 仅当函数基本上执行相同的任务, 但是使用不同形式的数据时, 才应该使用函数重载.

## 8.5 函数模板
函数模板的格式:
```cpp
template <typename AnyType>     // 图省事, AnyType 常常只写字母T
void swap(AnyType &a, AnyType &b)
{
    AnyType temp;
    temp = a;
    a = b;
    b = temp;
}

// 注意: C++98 之前是没有 typename 这个关键字的, 当时使用的是class, 这两者是等价的. 即:
template <class AnyType>
void swap(AnyType &a. AnyType &b)
{
    AnyType temp;
    temp = a;
    a = b;
    b = temp;
}
```

函数模板的使用例子:
```cpp
#include <iostream>

using namespace std;

template <typename T>
void Swap(T &a, T &b);

int main(void)
{
    int i = 10;
    int j = 20;
    cout << "i = " << i << endl;
    cout << "j = " << j << endl;

    Swap(i,j);              // swap 接收 int 类型
    cout << "After Swap, now i,j = " << i << ", "<< j << endl;

    double x = 24.5;
    double y = 81.7;
    cout << "x = " << x << endl;
    cout << "y = " << y << endl;
    Swap(x,y);              // swap 接收 double 类型
    cout << "After Swap, now x,y = " << x << ", "<< y << endl;

    return 0;
}

// 定义一个模板函数, 来完成任意类型的参数接收. (在调用时, 编译器自动生成独立的重载函数)
template <typename T>           // 注意 <typename T> 中没有逗号也没有分号
void Swap(T &a, T &b)
{
    T tmp = a;
    a = b;
    b = tmp;
}
```
- 函数模板通常放在某个头文件中, 使用的时候直接包含某个头文件就完成了多个重载函数的声明和定义.

---
### 8.5.1 重载的模板
- 前面是`函数的重载`, 现在是`模板的重载`
  - 前面的swap函数可以处理任意的数据类型, 但是它没办法处理数组之类的复杂/复合数据类型, 所以这里就需要重载一个函数模板来处理数组了.  
  - 对于数组, 通常需要改变算法的一些执行过程, 这时候也需要使用`函数模板的重载`.

代码例子:
```cpp
#include <iostream>

using namespace std;

const int Lim = 8;

template <typename T>
void Swap(T &a, T &b);

void show(int arr[], int n);

template <typename T>
void Swap(T a[], T b [], int n); 

int main(void)
{
    int i = 10;
    int j = 20;
    cout << "i = " << i << endl;
    cout << "j = " << j << endl;

    Swap(i,j);              // swap 接收 int 类型
    cout << "After Swap, now i,j = " << i << ", "<< j << endl;

    int d1[Lim] = {0, 7, 0, 4, 1, 7, 7, 6};
    int d2[Lim] = {0, 7, 2, 0, 1, 9, 6, 9};
    cout << "Original arrays: " << endl;
    show(d1, Lim);
    show(d2, Lim);
    Swap(d1, d2, Lim);      // 使用了重载的函数模板 
    cout << "Swapped Arrays, Now they are:" << endl;
    show(d1, Lim);
    show(d2, Lim);

    return 0;
}

// 定义一个模板函数, 来完成任意类型的参数接收. (在调用时, 编译器自动生成独立的重载函数)
template <typename T>           // 注意 <typename T> 中没有逗号也没有分号
void Swap(T &a, T &b)
{
    T tmp = a;
    a = b;
    b = tmp;
}

template <typename T>
void Swap(T a[], T b [], int n)     // 重载了函数模板, 同样使用了模板, 但是特征标不一样
{
    T temp;
    for (int i = 0; i < n; i++)
    {
        temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }
}

void show(int arr[], int n)
{
    for (int i = 0; i < n; i++)
    {
        cout << arr[i] << " ";
    }
    cout << endl;
}
```

### 8.5.2 模板的局限性 (显示具体化的使用)
对于结构来说, 因为结构体支持`对拷`, 所以此时直接使用**函数模板**的话, 考虑上面swap函数的例子, 它会把所有的数值交换, 而不是只针对某些数值成员的值进行交换 即有时候这是不符合需求的, 但此时我们也没办法使用`函数模板的重载`来解决这个问题.
- 对于`结构体`的数据类型, 一般需要使用`显示具体化`才能补足`函数模板`的短板.

显示具体化的书写格式:
```cpp
template <> 函数返回类型 函数名<具体类型>(参数列表)
{
    函数体
}
```

代码例子:
```cpp
#include <iostream>

using namespace std;

struct job
{
    char name[40];
    double salary;
    int floor;
};

template <typename T>
void Swap(T &a, T &b);

template <> void Swap<job>(job &j1, job& j2);  // 显示具体化

void show(job &j);

int main(void)
{
    int i = 10;
    int j = 20;
    cout << "i = " << i << endl;
    cout << "j = " << j << endl;

    Swap(i,j);              // swap 接收 int 类型
    cout << "After Swap, now i,j = " << i << ", "<< j << endl;

    double x = 24.5;
    double y = 81.7;
    cout << "x = " << x << endl;
    cout << "y = " << y << endl;
    Swap(x,y);              // swap 接收 double 类型
    cout << "After Swap, now x,y = " << x << ", "<< y << endl;

    job Rick = {"Rick", 1000, 10};
    job Jack = {"Jack", 1100, 11};
    show(Rick);
    show(Jack);
    Swap(Rick, Jack);       // 如果直接用第一个Swap定义, 结构体的所有值都会被交换; 
                            // 如果我们不希望把名字交换, 这时候就没办法用 [重载函数模板] 的方式去实现了.
                            // 可以用 "显示具体化" 来处理
    cout << "After Swap:" << endl;
    show(Rick);
    show(Jack);

    return 0;
}

// 定义一个模板函数, 来完成任意类型的参数接收. (在调用时, 编译器自动生成独立的重载函数)
template <typename T>           // 注意 <typename T> 中没有逗号也没有分号
void Swap(T &a, T &b)
{
    T tmp = a;
    a = b;
    b = tmp;
}

template <> void Swap<job>(job &j1, job& j2)     // 对 job 类型进行"显示具体化", 这里说明的是 "job类型不适用于上面定义的函数模板"
{
    double t1;
    int t2;

    // 交换 工资 的数值
    t1 = j1.salary;
    j1.salary = j2.salary;
    j2.salary = t1;

    // 交换 楼层 的数值
    t2 = j1.floor;
    j1.floor = j2.floor;
    j2.floor = t2;
} 

void show(job &j)
{
    cout << j.name << ": " << j.salary << " on floor " << j.floor << endl;
}
```

函数调与函数调用的`优先级`:
- 对于给定的函数名, 可以有`非模板函数`, `模板函数` 和 `显示具体化模板函数`以及他们的`重载版本`.
- 显示具体化的原型和定义应该以`template<>`打头, 并通过名称来指出类型.
- `具体化`优先于`常规模板`, 而`非模板函数`优先于`具体化`和`常规模板`.
  - 在写代码时, 只要遇到`结构体`类型, 我们应该优先使用`显示具体化模板函数` 而非常规模板.

小实验 -- 验证一下调用优先级:
  - 理论上优先调用非模板函数.
```cpp
#include <iostream>

using namespace std;

struct job
{
    char name[40];
    double salary;
    int floor;
};

template <typename T>
void Swap(T &a, T &b);

template <> void Swap<job>(job &j1, job& j2);  // 显示具体化

void show(job &j);

int main(void)
{
    int i = 10;
    int j = 20;
    cout << "i = " << i << endl;
    cout << "j = " << j << endl;

    Swap(i,j);              // swap 接收 int 类型, 此时应该调用 非模板函数
    cout << "After Swap, now i,j = " << i << ", "<< j << endl;

    double x = 24.5;
    double y = 81.7;
    cout << "x = " << x << endl;
    cout << "y = " << y << endl;
    Swap(x,y);              // swap 接收 double 类型
    cout << "After Swap, now x,y = " << x << ", "<< y << endl;

    job Rick = {"Rick", 1000, 10};
    job Jack = {"Jack", 1100, 11};
    show(Rick);
    show(Jack);
    Swap(Rick, Jack);       // 如果直接用第一个Swap定义, 结构体的所有值都会被交换; 
                            // 如果我们不希望把名字交换, 这时候就没办法用 [重载函数模板] 的方式去实现了.
                            // 可以用 "显示具体化" 来处理
    cout << "After Swap:" << endl;
    show(Rick);
    show(Jack);

    return 0;
}

// 非模板函数
void Swap(int a, int b)
{
    cout << "Hello World. a = " << a << " b = " << b << endl;
    cout << "\n\n" << endl;

}

// 常规模板
template <typename T>           // 注意 <typename T> 中没有逗号也没有分号
void Swap(T &a, T &b)
{
    T tmp = a;
    a = b;
    b = tmp;
}

// 显示具体化的模板函数
template <> void Swap<job>(job &j1, job& j2)     // 对 job 类型进行"显示具体化", 这里说明的是 "job类型不适用于上面定义的函数模板"
{
    double t1;
    int t2;

    // 交换 工资 的数值
    t1 = j1.salary;
    j1.salary = j2.salary;
    j2.salary = t1;

    // 交换 楼层 的数值
    t2 = j1.floor;
    j1.floor = j2.floor;
    j2.floor = t2;
} 

void show(job &j)
{
    cout << j.name << ": " << j.salary << " on floor " << j.floor << endl;
}
```

### 8.5.4 实例化和具体化
#### 在函数 声明 阶段设置函数模板的显示实例化
- 注意**函数模板并不是函数定义**.
- 函数模板在代码中并不会自动创建任何`函数定义`, 它只是一个`用于生成函数定义的方案`.
  - 有函数模板在`被调用`的时候**编译器才会自动生成**对应的函数定义, 此时得到的就是`模板的实例(instantiation)`, 这个过程称为`隐式实例化(implicit instantiation)`.
- 除了隐式实例化之外, 也存在一种`显式实例化(explicit instantiation)`, 无论这个模板是否在代码中存在调用的语句, 编译器都一定会为它生成对应类型的函数定义, 它的语法为:
  ```cpp
  template void 函数名<类型名>(参数列表);    // 显式实例化, 使用 <> 把具体类型写进去

  // 如:
  template void swap<int>(int &, int &);         
  ```


#### 在函数 调用 阶段设置函数模板的显示实例化
代码例子:
```cpp
template <typename T>
T Add(T a, T b)
{
    return a + b;
}

// 中间省略若干代码

// 调用函数
int m  = 6;
double x = 10.2;
cout << Add<double>(m, x) << endl; 
```
- 在这个例子中, 函数模板与函数调用的类型并不能精准匹配, 因为参数列表里要求传入的两个参数的类型是相同的, 但是, 我们可以通过 `Add<double>( )` 这种方式, 强制为double类型进行实例化 (显示实例化), 这时候编译器会生成一个 `Add<double>(double a, double b)`的函数定义, 然后在调用函数的时候, int会被强制转换为 double 类型, 因此, 这个函数调用就是合法的了. 

但是这么做并不一定每次都有效果, 如使用前面的Swap函数例子:
```cpp
// 函数的声明为
template <class T>
void Swap(T &a, T &b);

int m =  5;
double x = 14.3;
Swap<double>(m, x);     // 编译出错
```
- 此时, 编译器会首先为`Swap<double>(double &a, double &b)`创建函数定义, 然后回到调用的过程, 我们会发现这里使用的是`变量的引用`, 此时`double &a`这个形参无法匹配到`int m`的引用!! 于是就报错了.  

#### 函数模板的显示具体化 和 显式实例化 的异同
```cpp
// 函数模板的显示具体化 (explicit specialization)
template <> void 函数名<类型名> (参数列表);

// 函数模板的显式实例化 (explicit instantiation)
template void 函数名<类型名> (参数列表);
```
- 不难看出, 它们在`定义`时, 代码上的区别只是 `在template后面有没有尖括号 <>`
  - 在`调用`时, `函数具体化(specialization)`是不需要额外写其他东西的, 直接当普通函数调用就可以了, 但是`显示实例化(instantiation)`在使用时, 需要在函数名后面加上尖括号, 把具体的类型写进去.
- 从实际使用角度来说:
  - 模板的显示具体化, 本质上是为`特定的数据类型重新量身定制一个处理方式, 虽然可能得到的最终效果是一样的, 但是内部算法可能具有本质的不同`.
  - 函数模板的显示实例化, 则是`针对编译器的工作流程进行修改`, 此时, 特定的数据类型在算法/代码层面并没有被特殊处理, 它仅仅是在编译时一定会被生成对应的函数声明罢了.

显示实例化的优点:
- 只生成一次, 节省了空间 (隐式实例化的时候, 每调用一次就会生成一次函数定义)
- 节省时间, 理由也是隐式实例化在多次调用时会多次生成函数定义.

代码例子 -- 注意观察代码中调用函数的时候对应了什么操作:
```cpp
// 假设有结构体job
struct job
{
    char name[40];
    double salary;
    int floor;
};

// 函数声明
template <tyname T>
void Swap(T &a, T &b)      // 通用函数模板
{
    // 函数的通用实现
}

template <> void Swap<job>(job &a, job &b)     // 通用模板的显示具体化 (explicit specialization)
{
    // 针对job类型的进行特殊处理
}

int mian(void)
{
    template void Swap<char>(char &a, &b);      // 在main函数中, 对通用模板进行了显示实例化(explicit instantiation), 编译器走到这里就会生成一个char类型的函数定义

    short a, b;
    Swap(a, b);     // 使用通用模板, 编译时为"隐式实例化", 生成了一个short类型的函数定义

    job n, m;
    Swap(a,b);      // 使用显示具体化的函数定义, 编译时为"隐式实例化", 生成了一个job类型的函数定义

    char g, h;
    Swap(g,h);      // 使用通用模板, 编译时使用"显示实例化", 这里不生成函数定义, 而是使用前面生成的函数定义.

}
```
---
**警告!** 如果在同一个文件(或转换单元)中, 同时对同**一种类型**使用`显式实例化`和`显示具体化` 会报错!

---

#### 重载解析(overloading resolution)
当代码中存在多个函数重载时, 函数具体调用的函数定义是由编译器根据参数类型来决定的, 这个过程就叫做`重载解析(overloading resolution)`. 它的过程逻辑为:
- 1. 创建候选函数列表 (包含与调用函数同名的`函数`和`函数模板`)
  - 注意: 此时`不关注函数的返回类型, 也不关心返回多少个参数`, 而只`关心参数列表(特征标)`
- 2. 使用候选函数列表创建可行函数列表, 这个列表里的函数会确保的`参数数量是正确的`; 在构建过程中, 还会涉及到一个`隐式转换序列`(包含实参类型与形参类型完全匹配的情况), 隐式转换指的是 float 可以转成 double 这种参数转换, 这个序列可以确保找到所有可能被匹配的函数.
- 3. 从列表中确定是否有最佳的可行函数, 如果有, 直接调用, 否则直接抛出 error.

![](第八章笔记_images/完全匹配和最佳匹配.png)


例子1 --> 完全匹配:
```cpp
// 考虑只有一个参数的函数 may();
may('B');

// 第一步, 编译器会寻找候选函数, 即名为 may() 的 "函数" 和 "函数模板", 然后再去寻找可以用一个参数调用的函数. 比如下面这三个函数, 它们的名字都是 may(), 满足第一步的要求.
void may(int);                  // #1
float may(float, float =3);     // #2
void may(char);                 // #3
char * may(const char *);       // #4  
char may(const char &);         // #5
template <class T> void may(const T &);  // #6
template <class T> void may(T &*);       // #7

// 第二步, 从候选函数列表中筛选
/*
    #4 和 #7 首先剔除, 因为 int 和 char 不能转指针
    #1 和 #2 勉强可行, 因为 'B' 是char型, 可以被隐士提升为 int 和 float 类型
    #3, #5 和 #6 比 #1, #2 好, 因为它们不需要隐式转换, 直接就可以匹配

    进一步比较, 模板函数的调用优先级低于常规函数, 所以 #3 和 #5 优先于 #6
*/


// 第三步, 选出最佳可行函数. 涉及到 "完全匹配" 与 "最佳匹配"
/*
    #3 和 #5 都是 char 类型, 此时这辆个就属于 "完全匹配"
    此时, 需要走 最佳匹配 的准则, 如果最佳匹配也有多个, 则会报错(ambiguous).
*/
```

##### 最佳匹配1: 如果函数原型涉及"引用和指针", 则根据实参有无const进行精准匹配
例子2 --> 最佳匹配:
```cpp
// 假设有结构体 blot
struct blot
{
    int a;
    char b[10];
};

// 假设函数调用语句为:
blot ink = {25, "spots"};
recycle(ink);

// 此时, 编译器会去寻找对应的候选函数, 并找到完全匹配的函数原型, 假设是下面这几个:
void recycle(blot);         // #1 blot-to-blot
void recycle(const blot);   // #2 blot-to-(const blot)
void recycle(blot &);       // #3 blot-to-(blot &)
void recycle(const blot &)  // #4 blot-to-(const blot &)

/*
    分析: 
    1. ink 是 blot 类型, 所以上面这4个都是 "完全匹配" 的函数原型, 都不存在任何数据类型的隐式转换.
    2. 此时, 这四个都是可行的, 没有规则可以筛选出一个 "最佳匹配", 所以会报错(ambiguous).
---------
    如果 只定义了 #3 和 #4, 那么编译器会根据 "实参有const优先匹配 const 的原则", 会选择 #4, 但要注意, 这个规则 "只用于 引用 和 指针";  换句话说, 如果我们只有 #1 和 #2, 这两个函数原型都不涉及指针和引用, 此时没有任何规则能筛选出最佳匹配函数, 此时编译器直接报错 ambiguous.
*/

```
##### 最佳匹配2: 如果完全匹配的函数都是模板函数, 则优先使用"非模板"的函数

##### 最佳匹配3: 如果完全匹配的函数都是模板函数, 则优先使用"显示具体化"的模板

##### 最佳匹配4: 在选择最佳匹配函数时, 编译器优先选择"最省事"的函数
例子:
```cpp
template <class Type> void recycle(Type t);   // #1
template <class Type> void recycle(Type * t); // #2

// 调用语句为
struct blot
{
    int a;
    char b[10];
};
blot ink = {25, "spots"};
recycle(&ink);
```
在上面给出的 #1 和 #2 模板中(这两个都是`完全匹配`), 由于调用语句`recycle(&ink)`的实参是一个`blot 类型的地址`, 此时: 
- 如果使用 #1 模板, 则编译器首先需要将type转换为 blot 类型, 然后再将 t 替换为指针类型, 最后才能匹配成功.
- 如果使用 #2 模板, 则编译器只需要将 t 替换为 blot 类型, 就能匹配成功.
  - 因此, 最佳匹配是 #2 模板, 因为它更省事.

代码例子:
```cpp
#include <iostream>

using namespace std;

template <typename T>
void ShowArray(T arr[], int n);      // #1

template <typename T>
void ShowArray(T * arr[], int n);    // #2

struct debts
{
    char name[50];
    double amount;
};

int main(void)
{
    int things[6] = {13, 31, 03, 301, 310, 130};

    ShowArray(things, 6);

    struct debts mr_E[3] =      // 这个 struct 加不加都可以
    {
        {"Rick", 2400.00},
        {"Jack", 1300.00},
        {"Rose", 1800.00}
    };

    double *pd[3];   // 指针数组, 数组有3个元素, 每个元素都是double类型的指针

    for(int i = 0; i < 3; i++){
        pd[i] = &mr_E[i].amount;        // 传递数据的指针
    }
    
    ShowArray(pd, 3);       // 此时若匹配到 #1, 打印出来的是地址; 如果匹配到 #2, 则正常输出.
                            // 从实验结果来看, 会匹配到#2, 而且 #2 确实是"最省事"的

    return 0;
}

template <typename T>
void ShowArray(T arr[], int n)      // #1 
{
    cout << "Template A: " << endl;
    for (int i = 0; i < n; i++){
        cout << arr[i] << " " ;
    }
    cout << endl;
}

template <typename T>
void ShowArray(T * arr[], int n)    // #2
{
    cout << "Template B: " << endl;
    for (int i = 0; i < n; i++){
        cout << *arr[i] << " " ;
    }
    cout << endl;
}
```

##### 用户指定调用模板函数, 并选择是否对参数进行强制类型转换
代码例子:
```cpp
#include <iostream>

using namespace std;

// 模板函数
template <class T>
T lesser(T a, T b) 
{
    return a < b ? a : b;
}

// 非模板函数: 返回绝对值的最小者
int lesser(int a, int b)
{
    a = a < 0 ? -a: a;
    b = b < 0 ? -b: b;
    return a < b ? a : b;
}

int main(void)
{
    int m = 20;
    int n = -30;
    double x = 15.5;
    double y = 25.9;

    // 让编译器去选择调用的函数
    cout << lesser(m, n) << endl;   // 优先调用非模板函数(返回绝对值最小者)
    cout << lesser(x, y) << endl;   // 非模板函数不是完全匹配, 此时调用模板函数

    // 用户指定调用哪个函数, 不让编译器自己去选
    cout << "\n用户使用 <> 来指定调用模板函数:" << endl;
    cout << lesser<>(m, n) << endl;     // <> 什么都不写, 表示指定选择模板函数, 并且自动选择正确的参数类型
    cout << lesser<int>(x, y) << endl;  // <int> 表示 将实参进行一次强制类型转换, 然后调用模板函数, 最后输出 15, 小数部分直接被砍掉.

    return 0;
}
```
- 使用`<>`可以让编译器强制使用强制类型转换, 如果尖括号中填入指定的数据类型, 则会先对实参进行强制类型转换, 然后再使用模板函数, 如上面代码例子中的`<int>`表示强制将 double 类型的 x和y 转换为 int 类型(此时小数部分直接去掉, 不会发生四舍五入), 然后再调用模板函数. 


### 8.5.6 模板函数 与 decltype 关键字
#### decltype 关键字的基本使用方式
decltype 关键字的是在 C++98 发展而来的, 它是`C++11`新增的功能, 用于决定表达式的返回类型. 问题场景如下:
```cpp
// 在C++98中存在的表达式返回类型不确定问题:
template <class T1, class T2>
void ft(T1 x, T2 y)
{
    ...
    ?Type? xpy = x + y;   // 由于存在隐式类型转换, 所以 xpy 的类型是无法直接确定的
}
```
为了让编译器知道 xpy 的类型, C++11 引入关键字 `decltype`, 它的代码语法为:
```cpp
decltype(expression) varname;   // varname 的类型为 expression 的返回类型
```

---
decltype 关键字在使用时会`遍历一个核对表`, 这个核对表会像 if-elseif-else 语句一样, 按照如下3个步骤的优选顺序进行判断:
* step 1: 如果代码是 `decltype (标识符)`, 此时表达式没有任何括号而仅仅是一个标识符, 此时 decltype 指定的类型与标识符的类型完全一致, 例子如下:
   ```cpp
    int x = 10;
    decltype(x) y = x;     // y 的类型为 int

    double x = 9;
    decltype(x) y = x;    // y 的类型为 double

    double &rx = x;
    decltype (rx) ry = x;   // ry 的类型为 double &

    const double * pd;
    decltype(pd) pc;        // pc 的类型为 const double *
   ```
* step 2: 如果代码是 `decltype(函数调用)`, 表达式位置是一个函数调用, 此时 decltype 指定的类型为函数的返回类型, 注意 `此时编译器并不会实际调用这个函数, 而是仅仅查看函数的返回类型`, 例子如下:
  ```cpp
    long indeed(int);
    decltype(indeed(10)) x;     // x 的类型为 long
  ``` 
* step 3: 如果代码是 `decltype ((expression))`, 表达式用括号括起来了, 此时 decltype 都指定为`引用`类型, 例子如下
   ```cpp
    int x = 10;
    decltype((x)) y = x;     // y 的类型为 int &

    double x = 9;
    decltype((x)) y = x;    // y 的类型为 double &

    double &rx = x;
    decltype ((rx)) ry = x;   // ry 的类型为 double &

    const double * pd;
    decltype((pd)) pc;        // pc 的类型为 const double * &
   ```
   *  需要注意的是`括号并不会使得原来的变量的左值性质发生改变`:
        ```cpp
        int x;
        x = 10;     // x 是一个左值
        (x) = 10;   // 用括号括起来的 x 仍然是一个左值    
        ```

* step 4: 如果代码不是前3种 case, 则 `decltype(expression)` 直接使用表达式返回的类型, 如:
  ```cpp
    int j = 3;
    int &k = j;
    int &n = j;
    decltype(j + 1) a;   // a 的类型为 int
    decltype(100L) b;   // b 的类型为 long
    decltype(k+n) c;   // c 的类型为 int (哪怕k和n都是j的引用, 由于表达式返回int, 所以c的类型也是int)
  ```

如果需要多次使用 decltype (expression) 声明某个类型, 可以结合 typedef 关键字来简化代码, 如:
```cpp
template <class T1, class T2>
void ft(T1 x, T2 y)
{
    ...
    typedef decltype(x + y) XYType;   // XYType 的类型为 x+y 的返回类型
    XYType xpy = x + y;
    XYTppe xty arr[10];
    XYType & rxy = arr[10];           // rxy 的类型为 (x+y) 返回类型的引用
}
```

---
#### decltype 与 后置返回类型
C++98 还有一个类型问题, 如下:
```cpp
template <class T1, class T2>
?type? gt(T1 x, T2 y)
{
    ...
    return x + y;   // 由于存在隐式类型转换, 所以返回值的类型是无法直接确定的
}
```
- 函数 gt 的返回类型无法确定, 因为 x 和 y 是在函数体里的, 编译器在没有进入函数体之前看不到 x y 的类型, 所以无法确定返回值的类型.
  - 注: 编译是`从左到右, 从上到下`的, 所以编译器在编译时, 先看到template这句话, 意识到这是一个模板函数, 然后到下一句时, 它先看 gt 的返回类型, 此时编译器还没有进入函数体, 所以看不到 x y 的类型, 所以无法确定返回值的类型, 就寄了.


C++11 中为了解决这个问题, 搞出了`后置返回类型`, 语法为:
```cpp
template <class T1, class T2>
auto gt(T1 x, T2 y) -> 类型名

// 结合decltype的话, 就可以写成
template <class T1, class T2>
auto gt(T1 x, T2 y) -> decltype(x+y)
```
- 这里的 auto 相当于一个占位符, 先占着返回值的位置, 但是仍不确定具体的类型, 然后走完gt的函数体, 这时候回到 `->decltype(x+y)`, 此时 decltype 里的 x, y 都已经见过了, 所以可以确定返回值的类型了, 在这之后才会把 auto 替换为具体的类型.

