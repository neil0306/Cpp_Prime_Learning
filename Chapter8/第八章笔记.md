# 第八章 函数探幽 
这是C++ 特有的东西, C之后新增的内容.

## 8.1 C++ 内联函数
- 内联函数是 C++ 为提高程序运行速度所做的一项改进, 它与普通函数的区别主要在C++编译器如何将他们组合到程序中.
  - 普通函数在经过编译器编译之后, 执行方式通常是`通过跳转`到函数代码所在的内存空间, 等执行完函数之后, 再跳回到原来执行的主程序位置.
  - 内联函数则是在编译的时候, 将`函数调用处用函数体替换`, 也就是说, `内联函数的执行不需要跳转到函数体`, 而是直接执行函数体, 这样就提高了程序的运行速度. 
    - 内联函数的代价是占用更多内存.
    - 内敛函数与常规函数的调用流程图:
    ![](第八章笔记_images/内敛函数与常规函数的调用流程图.png)

内联函数使用建议:
- 函数较短, 代码量不大时, 可以考虑使用内联函数
- 函数执行时间相比于函数调用时间较`短`时, 可以考虑使用内联函数. (主要思想是`以空间换时间`, 看看是不是收益比较大)

--- 
内敛函数的使用方法(二选一):
- 在`函数声明`前面加上关键字`inline`
- 在`函数定义`前面加上关键字`inline`

内敛函数的使用注意: 
1. 通常做法是`省略函数声明`, 直接把`函数整个定义`(函数头和函数体)都给写完, 然后在函数定义前面加上关键字`inline`.
2. 哪怕我们加上了 inline 关键字, `编译器也不一定会将其作为内联函数`, 比如编译器认为函数过长(过大), 或者这个函数调用了自己(一个递归函数, `递归函数不能作为内联函数`), 此时编译器就不会启用内联函数这种特性.

使用示例1: 
```cpp
#include <iostream>

using namespace std;

// 定义内联函数 (写法像一个宏, 但是比宏的功能更强)
inline double square(double x){return x*x;}

int main(void)
{
    double a,b;
    double c = 13.0;

    a = square(5.0);
    b = square(4.5+7.5);
    cout << "a = " << a << ", b = " << b << endl;
    cout << "c = " << c << endl;
    cout << "c square = " << square(c++) << endl;
    cout << "Now c = " << c << endl;

    return 0;
}
```

---

内联与宏:
- `函数宏`的写法: `#define SQUARE(X) X*X`
  - 有时候函数宏会出问题, 因为`函数宏不能按值传递`, `函数宏只进行文本替换, 很容易产生逻辑问题`!
  - 尽可能`使用内联函数, 而不是函数宏`.
  ![](第八章笔记_images/内联与宏.png)


---
## 8.2 引用变量
### 8.2.1 创建引用变量
- 变量的引用指的是原来变量的`别名`, 引用变量的声明方式为: 
  ```cpp 
  类型 &引用名 = 原来的变量名;
  int rat; 
  int &rodent = rat; // rodent 是 rat 的引用
  ```
- 如果在函数中使用变量的引用, 则真正使用的是`原来的变量`, 而不是变量的`副本`.

引用的代码例子:
```cpp
#include <iostream>
using namespace std;

int main(void)
{
    int rat = 10;
    int & rodent = rat;
    
    cout << "rat = " << rat << endl;
    cout << "rodent = " << rodent << endl;

    // 改变rodent
    rodent ++;
    cout << "rat = " << rat << endl;
    cout << "rodent = " << rodent << endl;

    // 观察地址
    cout << "rat's address: " << &rat << endl;
    cout << "rodent's address: " << &rodent << endl;

    return 0;
}
```
--- 
引用和指针的异同:
- 引用和指针**都可以直接操作原来的变量的值**, 而不是副本.
- `引用变量必须在初始化的时候就赋值`, 而指针可以先定义, 再赋值.
  ```cpp
  // 这里的写法是非法的!!
  int rat;
  int & rodent; // 不正确的写法, 会报错
  rodent = rat; // 不正确的写法, 会报错
  ```
- `引用变量一旦声明, 就不能改变`, 而**指针变量可以改变指向的变量**.
  - 也就是说, 引用`从始至终都效忠于同一个变量, 永不改变`.
  ```cpp
  #include <iostream>
  using namespace std;

  int main(void)
  {
      int rat = 101;
      int & rodent = rat;
      
      cout << "rat = " << rat << endl;
      cout << "rodent = " << rodent << endl;

      int bunnies = 50;
      rodent = bunnies;       // 关联成功了吗? no!
      cout << "bunnies = " << bunnies << endl;
      cout << "rodent = " << rodent << endl;      // 发现rodent的值变成了50

      cout << "rat = " << rat << endl;  
      /* 会发现 rat 也变成了50, 这说明上面的 
          rodent = bunnies 
          并不表示 rodent 成为了 bunnies 的别名, 这句代码仅仅是赋值语句
      */

      // 观察地址
      cout << "bunnies' address:\t" << &bunnies << endl;
      cout << "rat's address:\t\t" << &rat << endl;
      cout << "rodent's address:\t" << &rodent << endl;

      return 0;
  }
  ```

引用变量 与 指针: 
```cpp
// 指针可以随意改变指向的对象, 但是引用变量一旦声明, 就不能改变
int rats = 20;
int *pt = &rats; // pt 指向 rats
int &rodent = rat; // rodent 是 rats 的引用
int bunnies = 50;
pt = &bunnies; // pt 指向 bunnies
```


### 8.2.2 在函数中使用引用变量
代码例子1:
```cpp
#include <iostream>

using namespace std;

void swapr(int &a, int &b);
void swapp(int *a, int *b);
void swapv(int a, int b);

int main(void)
{
    int wallet1 = 300;
    int wallet2 = 350;

    cout << "wallet1 = " << wallet1 << endl;
    cout << "wallet2 = " << wallet2 << endl;

    cout << "Using reference to swap contents: " << endl;
    swapr(wallet1, wallet2);
    cout << "wallet1 = " << wallet1 << endl;
    cout << "wallet2 = " << wallet2 << endl;

    cout << "Using pointers to swap contents: " << endl;
    swapp(&wallet1, &wallet2);
    cout << "wallet1 = " << wallet1 << endl;
    cout << "wallet2 = " << wallet2 << endl;

    cout << "Trying to use passing by value:" << endl;
    swapv(wallet1, wallet2);        // 会发现没有发生交换
    cout << "wallet1 = " << wallet1 << endl;
    cout << "wallet2 = " << wallet2 << endl;

    return 0;
}

void swapr(int &a, int &b)
{
    int tmp = a;
    a = b;
    b = tmp;
}

void swapp(int * a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

void swapv(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```


代码例子2:
- 不适合使用引用的情况: 不希望值发生改变.
- 通常在传入结构体的并希望修改结构体的值时, 会使用引用.
```cpp
#include <iostream>

using namespace std;
double cube(double x);
double recube(double &ra);

int main(void)
{
    double x = 3.0;
    cout << "Cube of X: " << cube(x) << endl;

    cout << "Recube of X: " << recube(x) << endl;
    cout << "X = " << x << endl;

    return 0;
}

double cube(double x)
{
    x *= x * x;
    return x;
}

double recube(double &ra)
{
    ra *= ra * ra;
    return ra;
    // 换成  return ra * ra * ra; 此时 ra 就不会发生更改
}
```
- 注意: 
  - 在函数调用时, 如果使用`变量的引用`, 则**一定不能**在引用变量的位置上写`表达式`!!! 此时会编译报错! 解决办法就加const.
    ```cpp
    int a = 5;
    // 假设使用上面定义好的recube, 这种用法就会发生变异报错
    recube(5+x);
    ```
  - 如果引用变量的位置上加了`const`, 则此时可以使用表达式.
    ```cpp
    int a = 5;
    // 假设使用上面定义好的recube, 但是增加一个const
    recube(const int & a);
    rebube (5+a);  // 这种用法就不会报错
    ```
    - 不会报错的原因是:
      - 增加了`const`关键字之后, `C++内部会自动生成一个临时变量`, 用来存储表达式的值, 然后将这个`临时变量的引用`与函数那个引用变量关联起来, 此时, 如果函数内部对引用变量的值进行了更改操作, 此时被改掉的只是临时变量的值, 因此不会报错.


在函数中使用引用时, 应该尽可能使用`const`:
![](第八章笔记_images/函数中使用引用时应尽可能使用const.png)


---
### 8.2.3 引用与结构体

代码例子 -- 函数返回结构体的引用:
```cpp
#include <iostream>
#include <string>
using namespace std;

struct free_throws
{
    string name;
    int made;
    int attemps;
    float percent;
};

void set_pc (free_throws & ft);
void display(const free_throws & ft);        // 显示的时候不应该修改任何东西, 加 const
// 注意: 这里的 accumulate 返回的是一个引用, 这样才能实现链式赋值
free_throws & accumulate(free_throws & target, free_throws & src);

int main(void)
{
    // percet 默认为0
    free_throws one = {"Rick", 13, 14};
    free_throws two = {"Jack", 10, 16};
    free_throws three = {"Jerry", 7,9 };
    free_throws four = {"Jason", 8, 11};
    free_throws five = {"Michael", 5, 14};
    free_throws team = {"Class 6", 0, 0};

    // 用函数填充percent, 再显示
    set_pc(one);
    display(one);

    // 累加并显示
    accumulate(team, one);
    display(team);

    display(accumulate(team, two));


    // 链式赋值
    accumulate(accumulate(accumulate(team, three), four), five);
    /*
    等价于:
        // accumulate(team, three);
        // accumulate(team, four);
        // accumulate(team, five);
    */
    display(team);

    return 0;
}

void set_pc (free_throws & ft)
{
    if (ft.attemps != 0){
        ft.percent = 100 * static_cast<float>(ft.made) / static_cast<float>(ft.attemps);
    }
    else{
        ft.percent = 0;
    }
}

void display(const free_throws & ft)        // 显示的时候不应该修改任何东西, 加 const
{
    cout << "Name: " << ft.name << endl;
    cout << "Made: " << ft.made << "\t";
    cout << "Attemps: " << ft.attemps << "\t";
    cout << "Percent: " << ft.percent << endl;
}

free_throws & accumulate(free_throws & target, free_throws & src)
{
    target.attemps += src.attemps;
    target.made += src.made;
    set_pc(target);
    return target;
}
```
- 如果 return 一个结构体, 此时编译的操作是:
  - 情况1: return 出去的结构体`不是引用`:
    - 编译器会先临时开辟一个内存空间, 用来存放这个结构体
    - 然后在函数调用的位置把这个临时的结构体空间返回出去 (如果有变量等待接收, 就把这个内存赋值给它)
  - 情况2: return 出去的`结构体是一个引用变量`:
    - 直接`执行结构体的对拷`操作, 效率更高. 比如:
    ```cpp
    // accumulate函数按照上面的例子的定义
    free_throws dup = accumulate(team, one);
    /* 
      由于 accumulate 返回的结构体是 team 的引用, 所以编译器在函数调用结束时, 
        是直接执行 dup 和 team 的对拷操作, 没有开辟临时内存空间!!!
    */
    ```

- 返回引用需要注意, 引用变量一定要确保没有被释放!!
![](第八章笔记_images/函数返回引用需要注意原来的变量没有被释放.png)
- 如果使用`指针`来实现返回引用, 则一定要注意指针是否被释放, `是否容易出现内存泄露`问题!
![](第八章笔记_images/使用指针来实现返回引用的功能.png)

---
### 8.2.5 引用 与 类对象

代码例子:
```cpp
#include <iostream>
#include <string>

using namespace std;
string version1(const string & s1, const string &s2);
const string & version2(string &s1, const string &s2);
const string & version3(string &s1, const string &s2);

int main(void)
{
    string Input;
    string Result;
    string copyStr;

    cout << "Enter a string: ";
    getline(cin, Input);
    copyStr = Input;
    cout << "Your string as entered: " << Input << endl;
    cout << "--------------------" << endl;

    Result = version1(Input, "***");      // 在字符串的前缀和后缀加*
    cout << "Your string enhanced: " << Result << endl;
    cout << "Your original string: " << Input <<  endl;
    cout << "--------------------" << endl;

    Result = version2(Input, "###");        // 注意version2返回的是 "引用" 哦!
    cout << "Your string enhanced: " << Result << endl;
    cout << "Input now becomes: " << Input <<  endl;
    
    cout << "--------------------" << endl;
    Input = copyStr;        // 恢复到初始值
    // 此时 version3 返回的值已经被释放掉了, 在linux中, 程序运行到这里会崩掉
    Result = version3(Input, "@@@");
    cout << "Your string enhanced: " << Result << endl;
    cout << "Input now becomes: " << Input <<  endl;

    return 0;
}

// 1. string类中定义了 char* 到 string类型的转换, 使得我们可以用 char* 直接初始化string对象
// 2. 在函数中, 如果在引用变量前加 const, 那么当引用类型 与 传入的实参类型不匹配时(但可以被正确转换), 
//   编译器会自动创建一个临时变量进行适配
// 3. version1 返回的是"值", 走的是"按值传递"的方式, 变量的值在return时存放到临时内存空间中.
string version1(const string & s1, const string &s2)
{
    return s2 + s1 + s2;
}

// version2 返回的是引用!!!
const string & version2(string &s1, const string &s2)
{
    s1 = s2 + s1 + s2;
    return s1;
}


const string & version3(string &s1, const string &s2)
{
    string tmp;
    tmp = s2 + s1 + s2;
    return tmp;     // 返回引用的时候 tmp 会在函数调用结束时被释放!
}
```
- 注意看上面例子中的注释部分.

---
### 8.2.6 对象, 继承和引用
- 继承中最常用的特性: 
  - 派生类**继承**了基类的方法, 因此`派生类可以直接使用基类的方法`. 
    - 如 ofstream 是由 ostream 派生出来的, 所以 ofstream 可以使用 ostream 的方法, 如格式化方法 `precision()` 和 `setf()`.
  - 基类**引用**可以`指向派生类的对象`.  

代码例子:
```cpp
/*
    当物镜焦距一定时, 计算不同目镜焦距下的放大倍数.
*/
#include <iostream>
#include <fstream>

using namespace std;
const int LIMIT = 5;
void file_it(ostream &OS, double fo, const double fe[], int n);

int main(void)
{
    fstream fout;
    const char *fn = "ep-data.txt";

    fout.open(fn);
    if(!fout.is_open()){        // 打开失败
        cout << "Can't open " << fn << ".Bye" << endl;
        exit(EXIT_FAILURE);     // 直接结束程序
    }

    double objective;       // 物镜的焦距
    cout << "Enter the focal length of telescope objective in mm:" << endl;
    cin >> objective;

    double eps[LIMIT];      // 目镜的焦距(数组)
    for (int i = 0; i < LIMIT; i++){
        cout << "EyePieces #" << i+1 << endl;
        cin >> eps[i];
    }

    file_it(cout, objective, eps, LIMIT);      // 在终端中显示结果
    file_it(fout, objective, eps, LIMIT);      // 在文件中记录结果

    cout << "Done!" << endl;
    return 0;
}

/* 
形参的定义中使用到知识点: 
    1. 基类对象的引用既可以"指向基类对象", 也可以指向"派生类对象"
    2. 数组可以使用数组表示法, 也可以使用指针表示法(本质上两种都是在传递指针)
*/
void file_it(ostream &OS, double fo, const double fe[], int n)
{
    // OS 是基类对象的引用, 通过传入对象的不同可以实现不同的执行效果
    OS << "Focal Length of objective: " << fo << endl;
    OS << "f.1. eyepieces " << "magnification" << endl;
    for (int i = 0; i < LIMIT; i++){
        OS << "\t" << fe[i] << "\t" << static_cast<int>(fo/fe[i] + 0.5) << endl;
    }
}
```
- ostream 是基类, ofstream 是派生类
  - 引用参数 OS 是 ostream 类型的引用, 因此可以传入 ofstream 类型的对象, 因为 ofstream 是 ostream 的派生类.
    - 通过引用对象绑定对象的不同(派生类与基类), 实现了完全不一样的效果.

---
### 8.2.7 何时使用引用参数
![](第八章笔记_images/何时使用引用参数.png)

- 小结:
  - `数组`: 一定且只能使用`指针`!
  - 类的对象: 用`引用`
  - 传递结构体: 指针或引用都可以. 
  - **基本类型**且**想修改**数值: 用指针
  - **不修改原始数据**或**数据量不大**: 按值传递 

---
## 8.3 函数的默认参数

代码例子:
```cpp
#include <iostream>
#include <cstring>  // left函数中还以选择使用这个库函数里的 strlen() 来计算char数组的长度; 但由于发生函数调用, 存在时间成本

using namespace std;

char * left(const char *str, int n = 1);
const int ArSIZE = 80;

int main(void){
    char sample[ArSIZE];
    cout << "Enter a string:";
    cin.get(sample, ArSIZE);

    // char *ps = left(sample, 4);
    char *ps = left(sample, 400000);  // 如果使用版本1, 就会浪费很多空间
    cout << ps << endl;

    ps = left(sample); // 使用默认值
    cout << ps << endl;

    delete ps;      // 在 left 里面 new, 这里delete
    
    return 0;
}

// // 版本1: 速度快, 但存在空间浪费
// char * left(const char *str, int n)
// {
//     if (n < 0)
//         n = 0;      // n < 0 是非法的, 此时直接置零, 相当于什么都不干

//     char *p = new char [n+1];               // 要多一个, 存放结束符 '\0'

//     int i = 0;
//     for(i = 0; i < n && str[i]; i++){       // str[i] 如果为空字符, 此时for循环的条件语句就返回false
//         p[i] = str[i];
//     }
//     while (i <= n){
//         // 先对第i个位置赋值, 然后 i++
//         p[i++] = '\0';      // 如果p没有存满(此时str里的元素不足n个), 此时就把空出来的位置全部填 '\0'
//     }
//     return p;
// }

// 版本2: 不但节省空间, 运行速度也快
char * left(const char *str, int n)
{
    // 自己遍历一次数组, 直接确定数组里的元素个数
    int m = 0;
    while ( m < n && str[m] != '\0'){
        m++;
    }
    char * p = new char[m+1];
    int i = 0;
    for (; i < m; i++){
        p[i] = str[i];
    }
    p[i] = '\0';  // 最后一个元素填入空字符.
    return p;
} 
```
---
## 8.4 左值/优值引用(before 函数重载)
详细知识点看代码注释.
```cpp
/*
    本例子主要与C++的 "左值/右值引用" 相关.
        left, rigt 通常与赋值运算符相关(= , +=), 赋值运算符左侧就成为"左值", 右侧的就叫做"右值".

        巧记: 凡是能进行[取地址]操作的都是左值, 不能取地址的都是右值.
*/

#include <iostream>

using namespace std;

int main(void)
{
    int a = 10;     // a 是左值(可读可写的变量), 10 是右值(只读变量)
    int b = a;      // b 是左值(可读可写的变量), a 是右值(只读变量)

    int *p = &a;    // 能取地址, 此时的a还是左值

    // int *p = &(a+b);    // 编译时会报错(cannot take the address of an rvalue of type 'int'), 
                           // 说明(a+b) 这个整体是一个"右值", 报错信息里的关键词是 "rvalue"

    // 左值引用
    int &c = a;         // c 相当于是a的"别名", 这种引用方式叫做 "左值引用"
    // int &d = 10;        // 会报错 (initial value of reference to non-const must be an lvalue), 这是因为10是右值, 而"左值引用"要求 引用的对象一定是 "左值", 简单来讲就是 = 号右侧一定要能 "取地址"
    // int &d = (a+b);     // 同样报错(initial value of reference to non-const must be an lvalue), 原因就是 (a+b) 不是"左值", 特点就是没办法取地址.

    // 加const之后, 这种引用已经是 "常引用(阉割版引用)" 了. 此时的引用是与"一个临时变量"进行绑定的, 绑定之后, 这个引用变量只能读取数据, 无法修改数据.
    const int &d = 10;      // 加 const 之后就合法了, 因为10在内存中产生了一个 "临时变量", 这时候 d 就会和那个临时变量绑定在一起
    const int &e = (a+b);   // 加 const 之后就合法了, 因为a+b在内存中产生了一个 "临时变量", 这时候 e 就会和那个临时变量绑定在一起

    // C++ 11 中新增的 "右值引用", 编译的时候可能会有相关的版本提示.
    /*
        1. 两个 && 表示是右值引用
        2. 右值引用并不是为了取代左值引用, 它的存在是为了"移动语义", 这在析构函数中非常有用.
    */
    int &&x = 10;           // x 是右值引用
    int &&y = (a+b);        // y 也是右值引用

    return 0;
}
```
---
### 8.4 函数重载
`函数多态` 与 `函数重载` 都是同一回事, 虽然术语的文字理解可以表达为:
- "多态" 指的是: 一个函数有多种形式.
- "函数多态"则是指: 允许存在多个同名函数.

函数重载的关键主要看`函数的参数列表`, 也称为`函数的特征标 (function signature)`.
- 如果两个函数的`参数数目`和`参数类型相同`, 同时`参数的排列顺序`也相同, 则这两个函数的特征标相同. (变量名是无关紧要的)
- 只要函数的特征标不相同, 这两个函数哪怕名字相同, 也会被认为是不同的函数.
  - 因此, 函数重载需要保证`函数的特征标`不一样, 以下三个至少有一个不同:
    - 参数排列顺序
    - 参数类型
    - 参数数目

注意:
- 如果在函数调用时, 我们传递进去的参数与已有的函数定义都不匹配的话, 编译器会自动使用`强制类型转换`, 但是, `如果转换结束之后, 发现有多个可用的重载`, 此时编译器不知道应该使用哪一种的话, 最终`编译器会直接丢出一个错误`.
- 一些不能共存的特征标:
  ```cpp
  // 1. 编译器通常将 类型引用 和 类型本身 视为同一种特征标
  double cube(double x);
  double cube(double &x);       // 编译器认为 "double &x" 等同于 "double x"
  ```

-  函数的类型(函数的返回值)并不能用于决定函数是否能重载:
    ```cpp
    // 这两个函数定义中只有返回类型不一致, 但是函数的特征标(参数列表)是相同的, 因此这两个函数在编译器的角度来看是相同的函数, 会发生"重定义"错误.
    long gronk(int n, float m);
    double gronk(int n, float m);
    ```
---

函数在`调用`时, `编译器不区分const 和 非const`:
```cpp
// 函数原型
void dribble(char * bits);          // overloaded
void dribble (const char *cbits);   // overloaded
void dabble(char * bits);           // not overloaded
void drivel (const char * bits);    // not overloaded


const char p1[20]= "How's the weather?";
char p2[20]= "How's business?";
// 调用函数
dribble(p1);  // dribble(const char *);
dribble(p2);  // dribb1e(char *);
dabb1e(p1);   // no match
dabble(p2);   // dabble(char *);
drivel(p1);   // drivel (const char *);
drivel (p2);  // drivel(const char *);      // 传入非const指针时, 也匹配到 带const的函数原型
```
---
函数重载中使用`右值引用`的例子:
```cpp
// 假设有以下函数声明
void staff(double & rs);  // rs是左值引用
void staff(const double & rcs);  // 重载, 左值引用, 带const
void stove(double &r1);   // 左值引用
void stove(const double & r2);  // 重载, 带 const 的左值引用
void stove(double && r3);  // 重载, 右值引用

// 调用函数的场景
double x = 55.5;
const double y = 32.0;
stove(x);       // 调用 stove(double &r1);
stove(y);       // 调用 stove(const double &r2);
stove(x+y);     // 调用 stove(double &&r3);  假如代码中没有这个右值引用的函数声明, 编译器会默认调用 void stove(const double & r2);
```

- 函数重载的例子
```cpp
#include <iostream>
#include <cstring>  // left函数中还以选择使用这个库函数里的 strlen() 来计算char数组的长度; 但由于发生函数调用, 存在时间成本

using namespace std;

char * left(const char *str, int n = 1);
unsigned long left(unsigned long num, unsigned int ct);

const int ArSIZE = 80;

int main(void){
    const char * trip = "Hawaii!!";
    unsigned long n = 12345678;
    char * temp;
    int i;
    for (i = 0; i < 10; i++){
        cout << left(n, i) << endl;
        temp = left(trip, i);
        cout << temp << endl;
        delete [] temp;
    }
    return 0;
}

char * left(const char *str, int n)
{
    // 自己遍历一次数组, 直接确定数组里的元素个数
    int m = 0;
    while ( m < n && str[m] != '\0'){
        m++;
    }
    char * p = new char[m+1];
    int i = 0;
    for (; i < m; i++){
        p[i] = str[i];
    }
    p[i] = '\0';  // 最后一个元素填入空字符.
    return p;
} 

// 重载 left, 功能是取出数组的前n位
unsigned long left(unsigned long num, unsigned int ct)
{
    unsigned int digits = 1;              // num 的位数
    unsigned long tmp = num;

    if(ct == 0 || num == 0){
        return 0;
    }

    while(tmp /= 10){       // 除值为0时, 相当于false, 跳出循环
        digits++;
    }

    if (digits > ct){
        ct = digits - ct;            // 计算要除多少次10 
        while (ct --){
            num /= 10;
        }
        return num;
    }
    else {
        return num;
    }
}
```
---
什么时候才应该使用`函数重载`?
- 仅当函数基本上执行相同的任务, 但是使用不同形式的数据时, 才应该使用函数重载.

## 8.5 函数模板
函数模板的格式:
```cpp
template <typename AnyType>     // 图省事, AnyType 常常只写字母T
void swap(AnyType &a, AnyType &b)
{
    AnyType temp;
    temp = a;
    a = b;
    b = temp;
}

// 注意: C++98 之前是没有 typename 这个关键字的, 当时使用的是class, 这两者是等价的. 即:
template <class AnyType>
void swap(AnyType &a. AnyType &b)
{
    AnyType temp;
    temp = a;
    a = b;
    b = temp;
}
```

函数模板的使用例子:
```cpp
#include <iostream>

using namespace std;

template <typename T>
void Swap(T &a, T &b);

int main(void)
{
    int i = 10;
    int j = 20;
    cout << "i = " << i << endl;
    cout << "j = " << j << endl;

    Swap(i,j);              // swap 接收 int 类型
    cout << "After Swap, now i,j = " << i << ", "<< j << endl;

    double x = 24.5;
    double y = 81.7;
    cout << "x = " << x << endl;
    cout << "y = " << y << endl;
    Swap(x,y);              // swap 接收 double 类型
    cout << "After Swap, now x,y = " << x << ", "<< y << endl;

    return 0;
}

// 定义一个模板函数, 来完成任意类型的参数接收. (在调用时, 编译器自动生成独立的重载函数)
template <typename T>           // 注意 <typename T> 中没有逗号也没有分号
void Swap(T &a, T &b)
{
    T tmp = a;
    a = b;
    b = tmp;
}
```
- 函数模板通常放在某个头文件中, 使用的时候直接包含某个头文件就完成了多个重载函数的声明和定义.

---
### 8.5.1 重载的模板
- 前面是`函数的重载`, 现在是`模板的重载`
  - 前面的swap函数可以处理任意的数据类型, 但是它没办法处理数组之类的复杂/复合数据类型, 所以这里就需要重载一个函数模板来处理数组了.  
  - 对于数组, 通常需要改变算法的一些执行过程, 这时候也需要使用`函数模板的重载`.

代码例子:
```cpp
#include <iostream>

using namespace std;

const int Lim = 8;

template <typename T>
void Swap(T &a, T &b);

void show(int arr[], int n);

template <typename T>
void Swap(T a[], T b [], int n); 

int main(void)
{
    int i = 10;
    int j = 20;
    cout << "i = " << i << endl;
    cout << "j = " << j << endl;

    Swap(i,j);              // swap 接收 int 类型
    cout << "After Swap, now i,j = " << i << ", "<< j << endl;

    int d1[Lim] = {0, 7, 0, 4, 1, 7, 7, 6};
    int d2[Lim] = {0, 7, 2, 0, 1, 9, 6, 9};
    cout << "Original arrays: " << endl;
    show(d1, Lim);
    show(d2, Lim);
    Swap(d1, d2, Lim);      // 使用了重载的函数模板 
    cout << "Swapped Arrays, Now they are:" << endl;
    show(d1, Lim);
    show(d2, Lim);

    return 0;
}

// 定义一个模板函数, 来完成任意类型的参数接收. (在调用时, 编译器自动生成独立的重载函数)
template <typename T>           // 注意 <typename T> 中没有逗号也没有分号
void Swap(T &a, T &b)
{
    T tmp = a;
    a = b;
    b = tmp;
}

template <typename T>
void Swap(T a[], T b [], int n)     // 重载了函数模板, 同样使用了模板, 但是特征标不一样
{
    T temp;
    for (int i = 0; i < n; i++)
    {
        temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }
}

void show(int arr[], int n)
{
    for (int i = 0; i < n; i++)
    {
        cout << arr[i] << " ";
    }
    cout << endl;
}
```

### 8.5.2 模板的局限性 (显示具体化的使用)
对于结构来说, 因为结构体支持`对拷`, 所以此时直接使用**函数模板**的话, 考虑上面swap函数的例子, 它会把所有的数值交换, 而不是只针对某些数值成员的值进行交换 即有时候这是不符合需求的, 但此时我们也没办法使用`函数模板的重载`来解决这个问题.
- 对于`结构体`的数据类型, 一般需要使用`显示具体化`才能补足`函数模板`的短板.

显示具体化的书写格式:
```cpp
template <> 函数返回类型 函数名<具体类型>(参数列表)
{
    函数体
}
```

代码例子:
```cpp
#include <iostream>

using namespace std;

struct job
{
    char name[40];
    double salary;
    int floor;
};

template <typename T>
void Swap(T &a, T &b);

template <> void Swap<job>(job &j1, job& j2);  // 显示具体化

void show(job &j);

int main(void)
{
    int i = 10;
    int j = 20;
    cout << "i = " << i << endl;
    cout << "j = " << j << endl;

    Swap(i,j);              // swap 接收 int 类型
    cout << "After Swap, now i,j = " << i << ", "<< j << endl;

    double x = 24.5;
    double y = 81.7;
    cout << "x = " << x << endl;
    cout << "y = " << y << endl;
    Swap(x,y);              // swap 接收 double 类型
    cout << "After Swap, now x,y = " << x << ", "<< y << endl;

    job Rick = {"Rick", 1000, 10};
    job Jack = {"Jack", 1100, 11};
    show(Rick);
    show(Jack);
    Swap(Rick, Jack);       // 如果直接用第一个Swap定义, 结构体的所有值都会被交换; 
                            // 如果我们不希望把名字交换, 这时候就没办法用 [重载函数模板] 的方式去实现了.
                            // 可以用 "显示具体化" 来处理
    cout << "After Swap:" << endl;
    show(Rick);
    show(Jack);

    return 0;
}

// 定义一个模板函数, 来完成任意类型的参数接收. (在调用时, 编译器自动生成独立的重载函数)
template <typename T>           // 注意 <typename T> 中没有逗号也没有分号
void Swap(T &a, T &b)
{
    T tmp = a;
    a = b;
    b = tmp;
}

template <> void Swap<job>(job &j1, job& j2)     // 对 job 类型进行"显示具体化", 这里说明的是 "job类型不适用于上面定义的函数模板"
{
    double t1;
    int t2;

    // 交换 工资 的数值
    t1 = j1.salary;
    j1.salary = j2.salary;
    j2.salary = t1;

    // 交换 楼层 的数值
    t2 = j1.floor;
    j1.floor = j2.floor;
    j2.floor = t2;
} 

void show(job &j)
{
    cout << j.name << ": " << j.salary << " on floor " << j.floor << endl;
}
```

函数调与函数调用的`优先级`:
- 对于给定的函数名, 可以有`非模板函数`, `模板函数` 和 `显示具体化模板函数`以及他们的`重载版本`.
- 显示具体化的原型和定义应该以`template<>`打头, 并通过名称来指出类型.
- `具体化`优先于`常规模板`, 而`非模板函数`优先于`具体化`和`常规模板`.
  - 在写代码时, 只要遇到`结构体`类型, 我们应该优先使用`显示具体化模板函数` 而非常规模板.

小实验 -- 验证一下调用优先级:
  - 理论上优先调用非模板函数.
```cpp
#include <iostream>

using namespace std;

struct job
{
    char name[40];
    double salary;
    int floor;
};

template <typename T>
void Swap(T &a, T &b);

template <> void Swap<job>(job &j1, job& j2);  // 显示具体化

void show(job &j);

int main(void)
{
    int i = 10;
    int j = 20;
    cout << "i = " << i << endl;
    cout << "j = " << j << endl;

    Swap(i,j);              // swap 接收 int 类型, 此时应该调用 非模板函数
    cout << "After Swap, now i,j = " << i << ", "<< j << endl;

    double x = 24.5;
    double y = 81.7;
    cout << "x = " << x << endl;
    cout << "y = " << y << endl;
    Swap(x,y);              // swap 接收 double 类型
    cout << "After Swap, now x,y = " << x << ", "<< y << endl;

    job Rick = {"Rick", 1000, 10};
    job Jack = {"Jack", 1100, 11};
    show(Rick);
    show(Jack);
    Swap(Rick, Jack);       // 如果直接用第一个Swap定义, 结构体的所有值都会被交换; 
                            // 如果我们不希望把名字交换, 这时候就没办法用 [重载函数模板] 的方式去实现了.
                            // 可以用 "显示具体化" 来处理
    cout << "After Swap:" << endl;
    show(Rick);
    show(Jack);

    return 0;
}

// 非模板函数
void Swap(int a, int b)
{
    cout << "Hello World. a = " << a << " b = " << b << endl;
    cout << "\n\n" << endl;

}

// 常规模板
template <typename T>           // 注意 <typename T> 中没有逗号也没有分号
void Swap(T &a, T &b)
{
    T tmp = a;
    a = b;
    b = tmp;
}

// 显示具体化的模板函数
template <> void Swap<job>(job &j1, job& j2)     // 对 job 类型进行"显示具体化", 这里说明的是 "job类型不适用于上面定义的函数模板"
{
    double t1;
    int t2;

    // 交换 工资 的数值
    t1 = j1.salary;
    j1.salary = j2.salary;
    j2.salary = t1;

    // 交换 楼层 的数值
    t2 = j1.floor;
    j1.floor = j2.floor;
    j2.floor = t2;
} 

void show(job &j)
{
    cout << j.name << ": " << j.salary << " on floor " << j.floor << endl;
}
```


