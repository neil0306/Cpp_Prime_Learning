# 11.1 运算符重载
常见的就是 * 号, 它既可以表示乘法, 也可以表示"地址中的内容".
- 编译器通过`操作数的个数`, `操作数的类型`来区分运算符使用哪一种实现.


语法格式:
```cpp
    operatorOP(形参表) {        // 注意是 "operator" + "OP", OP为具体需要重载的运算符
        // 函数体
    }

    // 比如 operator*(参数列表)  // 这里是重载了 * 号
```
- OP必须是**C++已有的运算符**, 不能自定义.

代码例子:
- 头文件`mytimer1.h`
```cpp
#ifndef __MYTIMER0_H__
#define __MYTIMER0_H__

#include <iostream>

using namespace std;

class Time
{
    private:
        int hours;
        int minute;

    public:
        Time();
        Time(int h, int m = 0);
        void AddMin(int m);
        void AddHr(int h);
        void Reset(int h = 0, int m = 0);

        // Time Sum(const Time &t) const;   // 替换为运算符重载
        Time operator+(const Time &t) const;

        void show() const;
};

#endif
```

- 源文件`mytimer1.cpp`
```cpp
#include "mytimer1.h"

Time::Time()
{
    hours = minute = 0;
}

Time::Time(int h, int m)
{
    hours = h;
    minute = m;
}

void Time::AddMin(int m)
{
    minute += m;                // step1: 更新分钟数
    hours += minute / 60;       // step2: 进位
    minute %= 60;               // step3: 进位后刷新分钟数.
}

void Time::AddHr(int h)
{
    hours += h;
}

void Time::Reset(int h, int m)
{
    hours = h;
    minute = m;
}

// Time Time::Sum(const Time &t) const
// {
//     Time sum;
//     sum.minute = minute + t.minute;
//     sum.hours = hours + t.hours;

//     // 考虑进位
//     sum.hours += sum.minute / 60;
//     sum.minute %= 60;
//     return sum;
// }

Time Time::operator+(const Time &t) const
{
    Time sum;
    sum.minute = minute + t.minute;
    sum.hours = hours + t.hours;

    // 考虑进位
    sum.hours += sum.minute / 60;
    sum.minute %= 60;
    return sum;
}

void Time::show() const
{
    cout << "Hours = " << hours << ", Minutes = " << minute << endl;
}
```

- 源文件`useTimer1.cpp`
```cpp
#include <iostream>
#include "mytimer1.h"
using namespace std;

int main(void)
{
    Time coding(2, 40);
    Time fixing(5, 55);
    Time total;

    cout << "coding time:\n";
    coding.show();

    cout << "fixing time:\n";
    fixing.show();

    // total = coding.Sum(fixing);
    total = coding + fixing;        // 使用运算符重载
    cout << "Total time:\n";
    total.show();

    // 运算符重载的使用方式也可以写为下面的语句(当做成员函数来使用)
    Time Planning = coding.operator+(fixing);
    cout << "Planning time:\n";
    Planning.show();

    return 0;
}
```

## 运算符重载的限制
- `不能创建新的运算符`
- 运算符的操作数必须`至少有一个操作数是用户自定义的类型`.
- 使用运算符时`不能违反运算符原来的句法规则`.
  - 如: 求模运算符(%), 它是一个双目运算符, 有两个操作数, 我们不能改变它的操作数个数.
- 不能修改运算符的`优先级`和`结合性`.
- 不能重载以下运算符
  - sizeof
  - . (成员运算符)
  - .*(成员指针运算符)
  - :: (域运算符)
  - ?: (条件运算符)
  - typeid (类型识别运算符, 一个RTTI运算符)
  - const_cast (强制类型转换运算符)
  - dynamic_cast (强制类型转换运算符)
  - reinterpret_cast (强制类型转换运算符)
  - static_cast (强制类型转换运算符)
- 以下运算符只能通过`(类的)成员函数`进行重载
    ```txt
    =       赋值运算符
    ()      函数调用运算符
    []      下标运算符
    ->      通过指针访问类成员的运算符
    ```
    - 根本原因是: 上面这几个运算符 与 类的构造函数会产生**匹配歧义**(看下面的几个代码例子)

代码例子 -- 非成员函数与成员函数的运算符重载
```cpp
#include <iostream>

using namespace std;

class Num
{
    private:
    public:    // 为了使得 重载非成员运算符的方式能顺利访问n, 把n设置为public
        int n;
    public:
        Num();
        Num(int m);
        // Num operator+(const Num &t) const;      // 成员函数的运算符重载
        void show() const;
};

Num::Num()
{
    n = 0;
}

Num::Num(int m)
{
    n = m;
}

// 成员函数的运算符重载
// Num Num::operator+(const Num &t) const
// {
//     Num temp;
//     temp.n = n + t.n;
//     return temp;
// }


// 非成员运算符的重载方式
Num operator+(const Num &m, const Num &l)
{
    Num temp;
    temp.n = m.n + l.n;     // 要注意 n 是否为 Num 里的公有变量
    return temp;
}


void Num::show() const
{
    cout << "n = " << n << endl;
}

int main(void)
{
    Num a(10);
    a.show();

    Num b(20);
    b.show();

    // 测试成员函数 & 非成员函数的运算符重载方式
    Num c = a + b;
    c.show();

    return 0;
}
```

代码例子 -- 赋值运算符`=`的重载
- 没有进行赋值运算符的重载时:
    ```cpp
    #include <iostream>
    using namespace std;

    class Num
    {
        private:
            int n;
        public:
            Num();
            Num(int m);

    };

    Num::Num()
    {
        n = 0;
        cout << "Hello World!" << endl;
    }

    Num::Num(int m)
    {
        n = m;
        cout << "Good Morning." << endl;
    }


    int main(void)
    {
        Num a;

        // 触发自定义构造函数 Num::Num(int m)
        //   这是因为 "当一个类的声明中没有重载赋值运算符(=)时, 编译器会自动调用与右侧变量具有相同类型的类的构造函数", 此时的赋值运算符的具体功能是由编译器提供的, 本质上是编译器提供了一个默认的运算符重载.
        //   即: 在 Num 中我们没有重载 = 号, 而下面的赋值语句右侧是10, 是int类型, 恰好构造函数 Num(int m) 的输入参数是int类型, 于是直接调用了它.
        a = 10;     // 此语句等价于 a(10)

        return 0;
    }
    ```
    - 当一个类的声明中没有重载赋值运算符(=)时, **编译器会自动调用与右侧变量具有相同类型的类的构造函数**.

- 在类的成员函数中进行赋值运算符的重载时:
    ```cpp
    #include <iostream>
    using namespace std;

    class Num
    {
        private:
            int n;
        public:
            Num();
            Num(int m);
            void operator=(int l);      // 重载赋值运算符
    };

    Num::Num()
    {
        n = 0;
        cout << "Hello World!" << endl;
    }

    Num::Num(int m)
    {
        n = m;
        cout << "Good Morning." << endl;
    }

    void Num::operator=(int l)
    {
        n = l;
        cout << "I love you Rick." << endl;
    }

    int main(void)
    {
        Num a;

        //////// 测试没有进行赋值运算符重载的情况(需要注释掉上面的 operater+(int l) ) ////////
        /// 触发自定义构造函数 Num::Num(int m)
        ///   这是因为 "当一个类的声明中没有重载赋值运算符(=)时, 编译器会自动调用与右侧变量具有相同类型的类的构造函数", 此时的赋值运算符的具体功能是由编译器提供的, 本质上是编译器提供了一个默认的运算符重载.
        ///   即: 在 Num 中我们没有重载 = 号, 而下面的赋值语句右侧是10, 是int类型, 恰好构造函数 Num(int m) 的输入参数是int类型, 于是直接调用了它.
        // a = 10;     // 此语句等价于 a(10)

        //////// 测试重载后的赋值运算符 /////////
        a = 10;
        return 0;
    }
    ```
    - 这个例子说明的是:
      - 赋值运算符只能在类的成员函数中重载的根本原因在于 `赋值运算符会默认跟类的构造函数关联起来`, 如果不在类的成员函数中进行重载, 就会**引发匹配规则的歧义**, 编译器不知道应该调用重载的赋值运算符还是类的构造函数.

下图的运算符大多数都**可以通过成员或非成员函数进行重载**:
![](第十一章笔记_images/可重载的运算符.png)


