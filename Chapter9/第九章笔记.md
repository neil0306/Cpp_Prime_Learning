# 第九章 内存模型和名称空间

## 9.1 单独编译

头文件:
- 函数原型/函数声明
- 使用`#define`或`const`定义的符号常量
- 结构(体)声明
- 类声明
- 模板声明
- 内联函数
  - 通常情况下, 除了内联函数之外, 函数定义都不要放在头文件中
  - 内联函数可以放在头文件的原因是: 内联函数本身不会很长, 而且通常不会被多次声明(并且是在调用内联函数的地方, 编译器直接用内联函数的函数体进行了代码替换, 或称为"展开")

源码文件(.cpp):
- 包含与结构有关的函数代码(函数体)
- 包含`函数调用`与`结构(体)`相关的函数代码

## 9.2 存储持续性, 作用域和链接性
C++一共有4种不同的方案存储数据:
- 自动存储持续性
  - `函数定义中声明的变量(包括参数)`的存储持续性为**自动**的. 在**程序开始执行时被创建, 执行完代码块之后就自动释放**.
  - 也称为`局部变量`.

- 静态存储持续性
  - `函数定义之外定义的变量`和`使用关键字static`定义的变量的存储持续性都是**静态**的, 他们在**程序整个运行过程都存在**.
    - 注意是: 整个函数文件(整个源代码)的运行结束之前都不会被自动释放!!
    - `static`关键字一般用在函数内部, 此时函数中定义的变量只会被初始化一次, 哪怕多次调用到包含static语句的函数, 这个变量也不会被再次初始化, 并且单次调用完这个函数之后, 这个变量也不会释放.
    - 也称为`全局变量`.
    - 这个变量的作用域为`此文件的开头到此文件的结尾`, 这个文件内的所有函数都能访问这个变量, 但是`跨文件时该变量仍不可访问`, 如果需要实现`跨文件访问`, 则可以使用`关键字extern对"全局变量"进一步声明`, 此时这个变量具有`外部链接性(external Linkage)`.

- 线程存储持续性(涉及并行编程, 这里不展开)

- 动态存储持续性
  - 这个特指`使用 new 分配的内存空间`, 如果不使用 `delete`去释放, 则这个变量就会出现`内存泄露`问题.
  - 这种内存存储特性有时被称为`自由存储(free store)`或者`堆(heap)`


### 9.2.2 作用域
可从下面的代码例子的运行结果中进行观察:
```cpp
/*
    验证变量的作用域.
    包含: 
    1. 自动变量
    2. 不同函数里的自动变量
    3. 函数形参里的变量
*/
#include <iostream>

using namespace std;

void oil(int x);

int main(void)
{
    // 自动变量
    int texas = 31; 
    int year = 2011; 
    cout << "In main(), texas = " << texas << ", ";
    cout << "&texas = " << &texas << endl;
    cout << "In main(), year = " << year << ", ";
    cout << "&year = " << &year << endl;

    cout << "------------------------------" << endl;
    cout << "Let run function oil()..." << endl;
    // 测试一下函数形参里的变量 & 不同函数里定义的"同名"自动变量
    oil(texas);
    /*
        运行代码时可以观察到结论:
        1. 在不同函数里, 哪怕是同名的变量texas, 他们也不是同一个(因为变量在内存中的地址不相同)
        2. 应函数形参, 哪怕是传入的参数, 它在函数里会自动执行一次拷贝, 留意 oil 函数的x, 我们传入的是 texas, 
            但是它的地址已经不是 main 函数中 texas 的地址了, 可以看到在函数中 x 使用的是一个新的内存地址来存放传入参数 texas 的值 31
        3. 从2的结果看, 它也证明了函数形参中书写的变量, 在传入的过程中, 它的影响范围(作用域)也仅限于 "参数列表" 这个括号范围内, 因为在函数体里面使用的是一个全新的变量.
            对于引用变量和指针变量, 我们可以理解为: 编译器也还是重新定义了新的"引用变量/指针变量", 并且做了对应的赋值操作.
        4. 当发生作用域重叠时, 编译器会自动访问 "作用域最近" 的那个变量
        5. 代码块的自动变量在 "代码块运行结束时" 就会被自动释放, 此时编译器索引的 "作用域最近" 的自动变量将不包含代码块里的内容.
    */

    cout << "------------------------------" << endl;
    cout << "After running oil(), we have:" << endl;
    cout << "In main(), texas = " << texas << ", ";
    cout << "&texas = " << &texas << endl;
    cout << "In main(), year = " << year << ", ";
    cout << "&year = " << &year << endl;

    return 0;
}

void oil(int x)
{
    // 不同函数里的"同名"自动变量
    int texas = 5;

    cout << "In oil(), texas = " << texas << ", ";
    cout << "&texas = " << &texas << endl;

    // 测试形参变量
    cout << "In oil(), x = " << x << ", ";
    cout << "&x = " << &x << endl;

    {
        int texas = 113;    // 在代码块中重新定义了一个texas, 由于是不同的作用域, 它不会出发"重定义"错误.
        cout << "In oil()'s block, texas = " << texas << ", ";    // 这个语句会使用"作用域最近"的变量定义, 也就是在这个 block 中的texas
        cout << "&texas = " << &texas << endl;

        // 尝试访问一下同一个函数, 不同代码块中的变量x
        cout << "In oil()'s block, x = " << x << ", ";  // 由于处于同一个函数中, x的作用域是包含这个block的, 所以x仍然有效
        cout << "&x = " << &x << endl;                  // 打印结果是: 这个x与上面打印的x是同一个(内存地址也相同)
    }

    cout << "Post-block, texas = " << texas << ", ";
    cout << "&texas = " << &texas << endl;              // 可以看到, 这个texas并不是代码块里的texas, 而是函数体里定义的 texas, 
                                                        // 说明代码块中的 texas 作用域不会超出 block, 并且 block 里的 texas 其实已经被释放掉了.
}

```
运行结果:
![](第九章笔记_images/9_2_2代码例子的运行结果.png)


### 9.2.4 静态持续性, 外部链接性
代码例子 -- 如何在另一个`.cpp`文件中使用`另一个.cpp`文件的变量和函数
- 本例子一共定义三个子文件: `support.h`, `support.cpp` 和 `external.cpp`
```cpp
/*
  support.h
*/
#ifndef __SUPPORT_H__
#define __SUPPORT_H__

#include <iostream>

// 声明一个外部变量, 这个变量的初始声明位置不是在本文件中, 而是在external.cpp里
// 经过外部声明的变量, 就可以使用其他地方声明的全局变量了(extern关键词表明当前这个变量是从外面来的).
extern double warming;  // 注意, 这里的warming不要进行赋值!

void update(double dt);

void local(void);

#endif
```

```cpp
/*
  support.cpp
*/
#include <iostream>
#include "support.h"

using namespace std;

/// @brief 修改全局变量, dt是增加值
/// @param dt 
void update(double dt)
{
    warming  += dt;
    cout << "Updating Global Warming to " << warming << " degrees." << endl;
}

void local(void)
{
    // 局部变量, 只在local函数内部可见
    double warming = 0.8;
    cout << "Local Warming = " << warming << " degrees." << endl;

    // 使用作用域解析运算符 "::" (两个冒号), 表明这个变量是全局变量
    cout << "But global warming = " << ::warming << " degrees." << endl;
}
```

```cpp
/*
external.cpp
*/
#include <iostream>
#include "support.h"

using namespace std;

double warming = 0.3;       // 全局变量

int main(void)
{
    cout << "Global warming is " << warming << " degrees." << endl;
    update(0.1);
    cout << "Global warming is " << warming << " degrees." << endl;

    local();
    cout << "Global warming is " << warming << " degrees." << endl;

    return 0;
}
```
- 主要的知识点有:
  - 其他文件中如果需要另一个文件里的`全局变量`, 需要使用关键词`extern`进行声明, 如`extern double warming; // 注意不要赋值,如 extern double warming = 0.1;`
  - 在函数中如果需要使用全局变量(避免使用到可能存在的同名局部变量), 可以使用`作用域解析运算符 ::`(双冒号).

