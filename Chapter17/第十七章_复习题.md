# 题目
![](第十七章_复习题_images/第十七章_复习题_1-7.png)
![](第十七章_复习题_images/第十七章_复习题_8_1.png)
![](第十七章_复习题_images/第十七章_复习题_8-9.png)


# 1.
```txt
定义了管理(标准)输入输出的类.
这些类不仅可以输出到屏幕, 也可以输出到文件.
```


# 2.
```txt
键盘输入时, 存入缓冲区的其实是字符 (char 类型), 因此当我们需要存入某个变量时, 是需要进行类型转换的(由运算符 >> 来完成).
    转换后, 存储在变量对象的内存地址中的其实是二进制表示(无论它是 long, double, float 还是 int)
```

# 3.
```txt
标准输出与标准错误, 默认都是输出到显示器上.
    标准输出如果后面紧跟着一个 "重定向( > 运算符)", 则不会输出到屏幕上, 而是输出到指定的位置(如文件)
    标准错误是一定要显示到显示器上的.
```

# 4. 
```txt
中文书 page 737.
    对于每一种数据类型, ostream 类都提供了 operator<<() 的函数定义(重载函数), 因此, 在使用 "cout << " 时, 就会自动调用相应的重载函数进行输出.
```

# 5.
```txt
拼接输出: 
    cout << 内容1 << 内容2 << ... << << endl;     // 将多段内容拼接输出

能拼接输出的理由是 operator<<() 返回了 "ostream &", 所以可以继续调用对象的 operator<<() 函数.
```

# 6.
```cpp
#include <iostream>
#include <iomanip>  // 为了设置显示宽度必须引入

using namespace std;

int main(void)
{
    int n;
    cout << "Enter a integer: ";
    cin >> n;

    // 宽度15
    cout << showbase;       // 设置输出数字时加上进制的前缀
    cout << setw(15) << n                   // 到这里显示的是宽度15的十进制数
        << hex << setw(15) << n             // 到这里显示的是宽度15的十六进制数
        << setw(15) << oct << n << endl;    // 到这里显示的是宽度15的八进制数
    return 0;
}
```

# 7.

```cpp
#include <iostream>
#include <string>
#include <iomanip>

using namespace std;

int main(void)
{
    string name;
    double hourly, hours;

    cout << "Enter your name: ";
    getline(cin, name);
    cout << "Enter your hourly wages: ";
    cin >> hourly;
    cout << "Enter number of hours worked: ";
    cin >> hours;

    cout << "First format: "<< endl;
    cout << fixed << showpoint;     // 不使用科学计数法 + 显示小数点
    // 默认右对齐, 第一字段宽30; 第二个字段宽20, 保留两位小数; 第三个字段宽10, 保留一位小数
    cout << setw(30) << name << ": " << setw(20) << setprecision(2) << hourly << setw(10) << setprecision(1) << hours << endl;

    cout << "Second format: " << endl;
    // 前面已经设置过不使用科学计数法 + 显示小数点
    cout << left;           // 设置为左对齐
    cout << setw(30) << name << ": " << setw(20) << setprecision(2) << hourly << setw(10) << setprecision(1) << hours << endl;

    return 0;
}
```

# 8.
知识点:
```txt
cin捕获会 "跳过空白字符", cin.get() 不会跳过任何字符.
    空白字符包括: 回车('\n'), 空格(' '), 制表符('\t')
```

运行结果: 
```txt
ct1 = 5
ct2 = 9
```

# 9.
```txt
while(cin.get() != '\n) {
    continue;
}
    这段代码执行时, cin.get() 会从输入缓冲区一个个读取字符, 然后一个个判断当前读取的字符是否为回车, 执行效率比较低


cin.ignore(80, '\n');
    这行语句包含两个条件(执行逻辑是"或逻辑", 如果缓冲区的字符满足两个条件之一, 就忽略):
        1. 从输入缓冲区第一个字符开始扫描, 前80个字符直接被忽略
        2. 从输入缓冲区第一个字符开始扫描, 遇到第一个换行符之前的字符都会被忽略

        两个条件结合之后的执行逻辑为:
            case1: 从输入缓冲区开始扫描, 如果没有到达80个字符就遇到了一个换行符, 此时将忽略第一个字符到换行符之间的所有字符, 然后退出这个函数. (超过这个换行符之后的字符仍留在缓冲区中)

            case2: 从输入缓冲区开始扫描, 如果前面80个字符都不包含换行符, 那么直接忽略这80个字符, 然后退出这个函数. (哪怕第81个字符是换行符, 这个换行符也会继续留在缓冲区中)
```


