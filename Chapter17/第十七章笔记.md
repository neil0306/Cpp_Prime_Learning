# 输入, 输出 和 文件
文件操作是这章的重点.

## 使用cout输出
C++把所有的信息都当做"字节流"进行处理, 比如输入流, 输出流.
![](第十七章笔记_images/第十七章_C++的输入和输出.png)

在输入和输出时, 都需要经过一次 内存的缓冲区.
![](第十七章笔记_images/第十七章_有缓冲区的流.png)


### 重定向
有时候我们并不希望将流直接输出到屏幕或者文件中, 而是输出到某些用户想指定的位置, 此时就需要借助**重定向**功能来实现.
- 输入重定向 (<)
- 输出重定向 (>)

输出重定向演示:
```cpp
#include <iostream>
using namespace std;

int main(void)
{
    cout << "Hello World." << endl;     // 默认会直接输出到屏幕上
    return 0;
}
```
- 这是一段简单的 hello world 程序, 直接编译运行时, 屏幕会输出 `Hello World.`
- 如果我们在运行代码的时候使用 输出重定向`>` 的话, 就可以将这个输出信息写入指定的位置(比如文件)
![](第十七章笔记_images/第十七章_输出重定义效果演示.png)
  - 此时, test.txt 文件中原来的内容会被删除, 并写入 `Hello World.`

### 回顾 cout 的一些功能
- 连续输出
```cpp
// 由于 cout 内部对插入运算符 (<<) 进行了重载, 所以当我们使用"cout <<" 的时候, 实现的功能是输出
// 而由于cout进行重载时使用的是下面的声明, 所以才能进行连续输出
ostream & operator<<(类型);   // 由于返回的是 ostream &, 所以可以继续识别 <<, 从而实现连续输出

/*
    注: cout 对所有基本数据类型都有进行上述的重载操作.
        在输出字符串的时候, 双引号"" 字符串本身是一个 const char * 类型的地址
*/
```

cout 的其他輸出方法:
- cout.put(): 显式单个字符 
- cout.write(): 可以控制显式多少个字符

### 刷新缓冲区
背景:
```txt
1. 缓冲区的大小为 512字节 或者 512字节的整数倍
2. 对于输出缓冲区来说, 如果缓冲区没有填满的话, 是不会输出到设备(如屏幕)上的, 但有时候我们就是填不满缓冲区, 并且希望内容能正常输出, 此时就需要刷新缓冲区来正常输出(刷新的时候就把里面所有的内容输出出去了)

另:
缓冲区存在的意义是: 
    假如目前用户在输入密码, 如果输入错误, 此时用户会使用 backspace 删除之前输入的某些字符, 这时候就需要用到缓冲区, 否则用户就没有修改当前输入的机会.
```

刷新缓冲区的方式有以下两种:
- 用 `flush` 刷新缓冲区
- 用 `endl` 刷新缓冲区

endl 与 flush 的区别:
- flush只是将缓冲区的内容输出(不管缓冲区满没满都输出), endl不仅进行输出, **还多一个换行**的操作

### 格式化显示
同一段代码, 在不同C++编译器(不同平台, 不同版本)编译后执行出来的效果可能不一样.
具体的功能在使用的时候再上网去搜吧...太tm多了, 没必要背.

### 调整字段宽度
使用 `width()`:
```cpp
// width() 函数的声明有以下两种
int width();        // 不带参数时, 执行效果是 "返回当前设置" 
int width(int i);   // 带int参数时, 执行效果是 "使用当前输出的值作为宽度, 并返回**之前**设置的宽度"
```
- width() 只影响接下来显式的项目, 但不会一直生效下去
  - 比如当前有3行输出语句, width 只会对第一行输出语句生效, 而不会对后面剩下的两行输出语句生效.

代码示例:
```cpp
#include <iostream>

using namespace std;

int main(void)
{
    int w = cout.width(30);     // w 是默认的宽度(为0), 执行玩这行语句之后, 下一次输出时, 字段宽度将设置为30
    cout <<  "default field width = " << w << "\n";     // 输出时, 字段宽度采用30, w 则输出0, 因为0是默认字段宽度
    // 注: 这里字段宽度一共设置为30, 但是这行语句并没有达到30个字符, 此时输出是 **按右对齐** 的方式输出, 我们会看到这行输出靠右侧(没有字符的位置用空格填充)

    cout.width(5);
    cout << "N" << ":";
    cout.width(8);
    cout << "N * N" << ":\n";

    for(long i = 1; i <= 100; i *= 10){
        cout.width(5);
        cout << "i" << ":";
        cout.width(8);
        cout << i*i << ":\n";
    }

    return 0;
}
```
![](第十七章笔记_images/第十七章_代码例子输出_设置输出字段宽度.png)

代码例子中可以看到, 如果需要输出的字符没有达到设置的字段宽度数值, 则默认使用`空格`进行填充; 我们也可以使用 `cout.fill()` 来指定填充的内容.


### 设置浮点数显示精度
默认显示的精度为`六位有效数字`(包括了整数和小数).
- 用`cout.precision()`可以修改显示的有效数字位数.

### 小数数字末尾加0
使用`cout.setf(ios_base::showopint)`.
setf功能还挺多的, 可以用到的时候去网上搜一搜例子. 主要用到 `ios_base` 命名空间的内容.

## 使用cin进行输入
cin的输入方式总会涉及到**类型转换**, 因为从键盘或者其他位置进行输入时, 缓冲区中其实存放的是**字符**类型 (哪怕输入的是数字), 当我们给目标变量赋值时, cin会根据目标变量的类型进行一次转换.
```cpp
// cin 使用的 >>运算符重载为
istream & operator>>(类型);         // 由于返回的是 istream 对象, 因此可以连续输入 
```

来看一个代码例子:
```cpp
#include <iostream>

using namespace std;

int main(void)
{
    cout << "Enter Numbers: " << endl;
    int sum = 0;
    int input;
    while(cin >> input){
        sum += input;
    }
    cout << "Last value entered: " << input << endl;
    cout << "Sum = " << sum << endl;
    return 0;
}
```
分析:
```txt
针对 cin, 如果如果我们输入下面的内容:
    10 -50 -123Z 60    (输入完60按回车)

此时这些内容会全部存入输入缓冲区, 然后cin开始从缓冲区起始位置开始读取数据, 直到遇到 "空白字符" 时停止读取, 并把读取到的内容传递给程序.  
    空白字符指的是 "空格", "换行", "制表符"

针对这行输入, 读取10没问题, 读取-50也没问题, 读取到-123Z的时候将有如下过程:
    cin 是按照 "一个个字节" 进行读取的, 所以会先读 -号, 然后1, 到2, 再到3, 再到Z;
        读完-123, cin此时遇到Z, Z不是数字, 于是先把 -123 发送给程序(Z留在缓冲区), 然后执行 while 里面的 sum+= input.
        此时cin再去缓冲区中捞数据, 看到一个Z, 这时候发现不满足input的类型要求, while 直接结跳出循环执行后面的语句. 
```
执行代码后的输出:
![](第十七章笔记_images/第十七章_代码例子输出_测试cin输入.png)
- 可以看到, 程序结束的时候sum的值输出是-163, 刚好为`10-50-123`的结果.




