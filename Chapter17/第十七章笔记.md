# 输入, 输出 和 文件
文件操作是这章的重点.

## 输入/输出
C++把所有的信息都当做"字节流"进行处理, 比如输入流, 输出流.
![](第十七章笔记_images/第十七章_C++的输入和输出.png)

在输入和输出时, 都需要经过一次 内存的缓冲区.
![](第十七章笔记_images/第十七章_有缓冲区的流.png)


### 重定向
有时候我们并不希望将流直接输出到屏幕或者文件中, 而是输出到某些用户想指定的位置, 此时就需要借助**重定向**功能来实现.
- 输入重定向 (<)
- 输出重定向 (>)

输出重定向演示:
```cpp
#include <iostream>
using namespace std;

int main(void)
{
    cout << "Hello World." << endl;     // 默认会直接输出到屏幕上
    return 0;
}
```
- 这是一段简单的 hello world 程序, 直接编译运行时, 屏幕会输出 `Hello World.`
- 如果我们在运行代码的时候使用 输出重定向`>` 的话, 就可以将这个输出信息写入指定的位置(比如文件)
![](第十七章笔记_images/第十七章_输出重定义效果演示.png)
  - 此时, test.txt 文件中原来的内容会被删除, 并写入 `Hello World.`

### 回顾 cout 的一些功能
- 连续输出
```cpp
// 由于 cout 内部对插入运算符 (<<) 进行了重载, 所以当我们使用"cout <<" 的时候, 实现的功能是输出
// 而由于cout进行重载时使用的是下面的声明, 所以才能进行连续输出
ostream & operator<<(类型);   // 由于返回的是 ostream &, 所以可以继续识别 <<, 从而实现连续输出

/*
    注: cout 对所有基本数据类型都有进行上述的重载操作.
        在输出字符串的时候, 双引号"" 字符串本身是一个 const char * 类型的地址
*/
```

cout 的其他輸出方法:
- cout.put(): 显式单个字符 
- cout.write(): 可以控制显式多少个字符

### 刷新缓冲区
背景:
```txt
1. 缓冲区的大小为 512字节 或者 512字节的整数倍
2. 对于输出缓冲区来说, 如果缓冲区没有填满的话, 是不会输出到设备(如屏幕)上的, 但有时候我们就是填不满缓冲区, 并且希望内容能正常输出, 此时就需要刷新缓冲区来正常输出(刷新的时候就把里面所有的内容输出出去了)

另:
缓冲区存在的意义是: 
    假如目前用户在输入密码, 如果输入错误, 此时用户会使用 backspace 删除之前输入的某些字符, 这时候就需要用到缓冲区, 否则用户就没有修改当前输入的机会.
```

刷新缓冲区的方式有以下两种:
- 用 `flush` 刷新缓冲区
- 用 `endl` 刷新缓冲区

endl 与 flush 的区别:
- flush只是将缓冲区的内容输出(不管缓冲区满没满都输出), endl不仅进行输出, **还多一个换行**的操作

### 格式化显示
同一段代码, 在不同C++编译器(不同平台, 不同版本)编译后执行出来的效果可能不一样.
具体的功能在使用的时候再上网去搜吧...太tm多了, 没必要背.


