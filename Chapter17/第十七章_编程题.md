# 题目
![](第十七章_编程题_images/第十七章_编程题_1-5.png)
![](第十七章_编程题_images/第十七章_编程题_6_1.png)
![](第十七章_编程题_images/第十七章_编程题_6_2.png)
![](第十七章_编程题_images/第十七章_编程题_7_1.png)
![](第十七章_编程题_images/第十七章_编程题_7_2.png)


# 1.
涉及输入流, 一般会使用 `cin.peek()`.
- peek()方法不会直接从输入缓冲区中取走数据, 它仅仅做一个`检查`的操作, 数据仍保留在缓冲区中.

```cpp
#include <iostream>

using namespace std;

int main(void)
{
    int cnt = 0;
    char ch;

    cout << "Enter a string: ";
    while(cin.peek() != '$')            // 检查字符, 不是 $ 就继续从输入缓冲区中读取
    {
        cin.get(ch);
        cnt++;
    }
    cout << "count = " << cnt << endl;

    return 0;
}
```

# 2.
```cpp
#include <iostream>
#include <fstream>
#include <cstdlib>      // 使用 EOF

using namespace std;

int main(int argc, char * argv[])       // 为了接收终端参数, 第二个参数得是指针数组
{
    char ch;
    ofstream fout;      // 要写入文件, 需要用 ofstream 对象

    if(argc < 2){
        cout << "Usage: filename val1 val2" << endl;
        exit(0);
    }

    fout.open(argv[1]);
    if (fout.is_open()){
        cout << "Please enter the data: ";
        while (cin.get(ch) && ch != EOF )
        {
            fout << ch;     // 将输入的内容写入文件
        }
    }
    else{
        cout << "Cannot open/create the file " << argv[1] << endl; 
    }
    return 0;
}
```
- 注意: 键盘输入的时候, `EOF` 可以用组合键 `Ctrl + d`来模拟.


# 3.
```cpp
#include <iostream>
#include <fstream>
#include <cstdlib>

using namespace std;

int main(int argc, char * argv[])
{
    if (argc != 3){
        cout << "Wrong argument number! Please check your input!" << endl;
        exit(0);
    }

    ifstream fin;
    ofstream fout;
    char ch;

    fin.open(argv[1]);
    fout.open(argv[2]);

    if (fin.is_open() && fout.is_open())
    {
        while(fin.get(ch)){
            fout << ch;
        }
    }

    fin.close();
    fout.close();
    return 0;
}
```



# 4.
```cpp
#include <iostream>
#include <fstream>
#include <string>

using namespace std;

int main(void)
{
    ifstream fin1;
    ifstream fin2;
    ofstream fout;

    fin1.open("t1.dat");
    fin2.open("t2.dat");
    fout.open("t3.dat");

    string str;
    while(!fin1.eof() || !fin2.eof()){
        // 拷贝第一个文件
        if (getline(fin1, str) && str.size() > 0){
            fout << str;
        }

        // 拷贝第二个文件
        fout << " ";
        if (getline(fin2, str) && str.size() > 0){
            fout << str;
        }
        fout << endl;
    }
    fin1.close();
    fin2.close();
    fout.close();
    return 0;
}
```

# 5
```cpp
#include <iostream>
#include <set>
#include <string>
#include <fstream>

using namespace std;

int main(void)
{
    set<string> Mat, Pat, Guest;
    string name;
    ifstream fin1;
    ifstream fin2;
    fin1.open("mat.dat");
    fin2.open("pat.dat");

    while(getline(fin1, name) && name.size() > 0){
        Mat.insert(name);
    }
    while(getline(fin2, name) && name.size() > 0){
        Pat.insert(name);
    }

    // 合并: 由于 set 本身就排序 & 去重, 所以直接丢进去就好了
    Guest.insert(Mat.begin(), Mat.end());
    Guest.insert(Pat.begin(), Pat.end());

    ofstream fout;
    fout.open("matnpat.dat");

    set<string>::iterator pd;
    for(pd = Guest.begin(); pd != Guest.end(); pd++){
        fout << *pd << endl;
    }

    fin1.close();
    fin2.close();
    fout.close();
    return 0;
}
```

# 6
太麻烦了... 先不写了.

# 7.
```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>

using namespace std;

void ShowStr(const string &str);
void GetStrs(ifstream &fin, vector<string> &v);

class Store
{
    private:
        ofstream &fout;
    public:
        Store(ofstream &out) : fout(out){}
        void operator()(const string &str);
};

void Store::operator()(const string &str)
{
    size_t len = str.size();
    fout.write((char *)&len, sizeof len);   // 先写入字符串长度
    fout.write(str.data(), len);            // 把内容写入文件
}

int main(void)
{
    vector<string> vostr;
    string temp;

    cout << "Enter strings (empty line to quit):\n";
    while (getline(cin, temp) && temp[0] != '\0'){
        vostr.push_back(temp);
    }

    cout << "Here is your input.\n";
    for_each(vostr.begin(), vostr.end(), ShowStr);
    
    ofstream fout ("strings.dat", ios_base::out | ios_base::binary);
    for_each(vostr.begin(), vostr.end(), Store(fout));
    fout.close();

    vector<string> vistr;
    ifstream fin("strings.dat", ios_base::in | ios_base::binary);
    if (!fin.is_open()){
        cerr << "Could not open file for input.\n";
        exit(EXIT_FAILURE);
    }

    GetStrs(fin, vistr);
    cout << "\nHere are the strings read from the file: \n";
    for_each(vistr.begin(), vistr.end(), ShowStr);
    return 0;
}

void ShowStr(const string &str)
{
    cout << str << endl;
}

void GetStrs(ifstream &fin, vector<string> &v)
{
    size_t len;
    char * pt;

    // 借助 fin 对象读取文件内容
    while (fin.read((char *)&len, sizeof len)){ // read 函数第一个参数是 "存放读到的内容" 的变量地址, 第二个参数是 读取长度
        pt = new char[len];                     // 从堆中, 开辟一段空间用来临时存放读取的内容, 注意是字符数组
        fin.read(pt, len);
        v.push_back(pt);                        // 字符串常量可以直接用字符数组的名字表示 (他们两是等价的)
        delete [] pt;                           // 字符数组在释放内存时, 需要用 delete []
    }
}
```

